import { defineComponent as Ue, nextTick as qe, openBlock as Ge, createElementBlock as $e } from "vue";
class Ne {
  constructor() {
    this._listeners = /* @__PURE__ */ new Map();
  }
  addEventListener(e, t) {
    var i;
    this.removeEventListener(e, t), this._listeners.get(e) || this._listeners.set(e, []), (i = this._listeners.get(e)) === null || i === void 0 || i.push(t);
  }
  dispatchEvent(e, t) {
    var i;
    (i = this._listeners.get(e)) === null || i === void 0 || i.forEach((s) => s(t));
  }
  hasEventListener(e) {
    return !!this._listeners.get(e);
  }
  removeAllEventListeners(e) {
    e ? this._listeners.delete(e) : this._listeners = /* @__PURE__ */ new Map();
  }
  removeEventListener(e, t) {
    const i = this._listeners.get(e);
    if (!i)
      return;
    const s = i.length, o = i.indexOf(t);
    o < 0 || (s === 1 ? this._listeners.delete(e) : i.splice(o, 1));
  }
}
class C {
  constructor(e, t, i) {
    if (typeof e != "number" && e) {
      this.x = e.x, this.y = e.y;
      const s = e;
      this.z = s.z ? s.z : 0;
    } else if (e !== void 0 && t !== void 0)
      this.x = e, this.y = t, this.z = i != null ? i : 0;
    else
      throw new Error("tsParticles - Vector3d not initialized correctly");
  }
  static get origin() {
    return C.create(0, 0, 0);
  }
  get angle() {
    return Math.atan2(this.y, this.x);
  }
  set angle(e) {
    this.updateFromAngle(e, this.length);
  }
  get length() {
    return Math.sqrt(this.getLengthSq());
  }
  set length(e) {
    this.updateFromAngle(this.angle, e);
  }
  static clone(e) {
    return C.create(e.x, e.y, e.z);
  }
  static create(e, t, i) {
    return new C(e, t, i);
  }
  add(e) {
    return C.create(this.x + e.x, this.y + e.y, this.z + e.z);
  }
  addTo(e) {
    this.x += e.x, this.y += e.y, this.z += e.z;
  }
  copy() {
    return C.clone(this);
  }
  distanceTo(e) {
    return this.sub(e).length;
  }
  distanceToSq(e) {
    return this.sub(e).getLengthSq();
  }
  div(e) {
    return C.create(this.x / e, this.y / e, this.z / e);
  }
  divTo(e) {
    this.x /= e, this.y /= e, this.z /= e;
  }
  getLengthSq() {
    return this.x ** 2 + this.y ** 2;
  }
  mult(e) {
    return C.create(this.x * e, this.y * e, this.z * e);
  }
  multTo(e) {
    this.x *= e, this.y *= e, this.z *= e;
  }
  rotate(e) {
    return C.create(this.x * Math.cos(e) - this.y * Math.sin(e), this.x * Math.sin(e) + this.y * Math.cos(e), 0);
  }
  setTo(e) {
    this.x = e.x, this.y = e.y;
    const t = e;
    this.z = t.z ? t.z : 0;
  }
  sub(e) {
    return C.create(this.x - e.x, this.y - e.y, this.z - e.z);
  }
  subFrom(e) {
    this.x -= e.x, this.y -= e.y, this.z -= e.z;
  }
  updateFromAngle(e, t) {
    this.x = Math.cos(e) * t, this.y = Math.sin(e) * t;
  }
}
class V extends C {
  constructor(e, t) {
    super(e, t, 0);
  }
  static get origin() {
    return V.create(0, 0);
  }
  static clone(e) {
    return V.create(e.x, e.y);
  }
  static create(e, t) {
    return new V(e, t);
  }
}
let Xe = Math.random;
function D() {
  return Oe(Xe(), 0, 1 - 1e-16);
}
function Oe(n, e, t) {
  return Math.min(Math.max(n, e), t);
}
function W(n) {
  const e = le(n);
  let t = ae(n);
  return e === t && (t = 0), D() * (e - t) + t;
}
function y(n) {
  return typeof n == "number" ? n : W(n);
}
function ae(n) {
  return typeof n == "number" ? n : n.min;
}
function le(n) {
  return typeof n == "number" ? n : n.max;
}
function _(n, e) {
  if (n === e || e === void 0 && typeof n == "number")
    return n;
  const t = ae(n), i = le(n);
  return e !== void 0 ? {
    min: Math.min(t, e),
    max: Math.max(i, e)
  } : _(t, i);
}
function Ye(n) {
  const e = n.random, { enable: t, minimumValue: i } = typeof e == "boolean" ? {
    enable: e,
    minimumValue: 0
  } : e;
  return y(t ? _(n.value, i) : n.value);
}
function je(n, e) {
  const t = n.x - e.x, i = n.y - e.y;
  return { dx: t, dy: i, distance: Math.sqrt(t * t + i * i) };
}
function he(n, e) {
  return je(n, e).distance;
}
function Je(n, e, t) {
  if (typeof n == "number")
    return n * Math.PI / 180;
  switch (n) {
    case "top":
      return -Math.PI / 2;
    case "top-right":
      return -Math.PI / 4;
    case "right":
      return 0;
    case "bottom-right":
      return Math.PI / 4;
    case "bottom":
      return Math.PI / 2;
    case "bottom-left":
      return 3 * Math.PI / 4;
    case "left":
      return Math.PI;
    case "top-left":
      return -3 * Math.PI / 4;
    case "inside":
      return Math.atan2(t.y - e.y, t.x - e.x);
    case "outside":
      return Math.atan2(e.y - t.y, e.x - t.x);
    case "none":
    default:
      return D() * Math.PI * 2;
  }
}
function Ze(n) {
  const e = V.origin;
  return e.length = 1, e.angle = n, e;
}
function Qe(n) {
  var e, t;
  return ((e = n.position) === null || e === void 0 ? void 0 : e.x) !== void 0 && ((t = n.position) === null || t === void 0 ? void 0 : t.y) !== void 0 ? {
    x: n.position.x * n.size.width / 100,
    y: n.position.y * n.size.height / 100
  } : void 0;
}
function Ke(n) {
  var e, t, i, s;
  return {
    x: (t = (e = n.position) === null || e === void 0 ? void 0 : e.x) !== null && t !== void 0 ? t : D() * n.size.width,
    y: (s = (i = n.position) === null || i === void 0 ? void 0 : i.y) !== null && s !== void 0 ? s : D() * n.size.height
  };
}
function Se(n) {
  return n.endsWith("%") ? parseFloat(n) / 100 : parseFloat(n);
}
function K() {
  return typeof window > "u" || !window || typeof window.document > "u" || !window.document;
}
function et() {
  return !K() && typeof matchMedia < "u";
}
function ce(n) {
  if (!!et())
    return matchMedia(n);
}
function tt() {
  return K() ? (n) => setTimeout(n) : (n) => (requestAnimationFrame || setTimeout)(n);
}
function it() {
  return K() ? (n) => clearTimeout(n) : (n) => (cancelAnimationFrame || clearTimeout)(n);
}
function me(n, e) {
  return n === e || e instanceof Array && e.indexOf(n) > -1;
}
function st(n) {
  return Math.floor(D() * n.length);
}
function ue(n, e, t = !0) {
  return n[e !== void 0 && t ? e % n.length : st(n)];
}
function M(n, ...e) {
  for (const t of e) {
    if (t == null)
      continue;
    if (typeof t != "object") {
      n = t;
      continue;
    }
    const i = Array.isArray(t);
    i && (typeof n != "object" || !n || !Array.isArray(n)) ? n = [] : !i && (typeof n != "object" || !n || Array.isArray(n)) && (n = {});
    for (const s in t) {
      if (s === "__proto__")
        continue;
      const o = t, r = o[s], a = typeof r == "object", l = n;
      l[s] = a && Array.isArray(r) ? r.map((c) => M(l[s], c)) : M(l[s], r);
    }
  }
  return n;
}
function U(n, e) {
  return n instanceof Array ? n.map((t) => e(t)) : e(n);
}
function N(n, e, t) {
  return n instanceof Array ? ue(n, e, t) : n;
}
const nt = "random", ee = /* @__PURE__ */ new Map();
function Re(n) {
  ee.set(n.key, n);
}
function ie(n, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n;
}
function ot(n) {
  for (const [, o] of ee)
    if (n.startsWith(o.stringPrefix))
      return o.parseString(n);
  const e = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])?$/i, t = n.replace(e, (o, r, a, l, c) => r + r + a + a + l + l + (c !== void 0 ? c + c : "")), i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i, s = i.exec(t);
  return s ? {
    a: s[4] !== void 0 ? parseInt(s[4], 16) / 255 : 1,
    b: parseInt(s[3], 16),
    g: parseInt(s[2], 16),
    r: parseInt(s[1], 16)
  } : void 0;
}
function B(n, e, t = !0) {
  if (!n)
    return;
  const i = typeof n == "string" ? { value: n } : n;
  if (typeof i.value == "string")
    return Ie(i.value, e, t);
  if (i.value instanceof Array)
    return B({
      value: ue(i.value, e, t)
    });
  for (const [, s] of ee) {
    const o = s.handleRangeColor(i);
    if (o)
      return o;
  }
}
function Ie(n, e, t = !0) {
  if (!n)
    return;
  const i = typeof n == "string" ? { value: n } : n;
  if (typeof i.value == "string")
    return i.value === nt ? ht() : at(i.value);
  if (i.value instanceof Array)
    return Ie({
      value: ue(i.value, e, t)
    });
  for (const [, s] of ee) {
    const o = s.handleColor(i);
    if (o)
      return o;
  }
}
function ge(n, e, t = !0) {
  const i = B(n, e, t);
  return i ? rt(i) : void 0;
}
function rt(n) {
  const e = n.r / 255, t = n.g / 255, i = n.b / 255, s = Math.max(e, t, i), o = Math.min(e, t, i), r = {
    h: 0,
    l: (s + o) / 2,
    s: 0
  };
  return s !== o && (r.s = r.l < 0.5 ? (s - o) / (s + o) : (s - o) / (2 - s - o), r.h = e === s ? (t - i) / (s - o) : r.h = t === s ? 2 + (i - e) / (s - o) : 4 + (e - t) / (s - o)), r.l *= 100, r.s *= 100, r.h *= 60, r.h < 0 && (r.h += 360), r.h >= 360 && (r.h -= 360), r;
}
function at(n) {
  return ot(n);
}
function re(n) {
  const e = { b: 0, g: 0, r: 0 }, t = {
    h: n.h / 360,
    l: n.l / 100,
    s: n.s / 100
  };
  if (!t.s)
    e.b = t.l, e.g = t.l, e.r = t.l;
  else {
    const i = t.l < 0.5 ? t.l * (1 + t.s) : t.l + t.s - t.l * t.s, s = 2 * t.l - i;
    e.r = ie(s, i, t.h + 1 / 3), e.g = ie(s, i, t.h), e.b = ie(s, i, t.h - 1 / 3);
  }
  return e.r = Math.floor(e.r * 255), e.g = Math.floor(e.g * 255), e.b = Math.floor(e.b * 255), e;
}
function lt(n) {
  const e = re(n);
  return {
    a: n.a,
    b: e.b,
    g: e.g,
    r: e.r
  };
}
function ht(n) {
  const e = n != null ? n : 0;
  return {
    b: Math.floor(W(_(e, 256))),
    g: Math.floor(W(_(e, 256))),
    r: Math.floor(W(_(e, 256)))
  };
}
function Q(n, e) {
  return `rgba(${n.r}, ${n.g}, ${n.b}, ${e != null ? e : 1})`;
}
function ye(n, e) {
  return `hsla(${n.h}, ${n.s}%, ${n.l}%, ${e != null ? e : 1})`;
}
function _e(n) {
  return n !== void 0 ? {
    h: n.h.value,
    s: n.s.value,
    l: n.l.value
  } : void 0;
}
function ct(n, e, t) {
  n.save(), n.fillStyle = t != null ? t : "rgba(0,0,0,0)", n.fillRect(0, 0, e.width, e.height), n.restore();
}
function se(n, e) {
  n.clearRect(0, 0, e.width, e.height);
}
function ut(n) {
  var e, t, i, s, o, r, a, l, c, d;
  const { container: u, context: h, particle: p, delta: f, colorStyles: m, backgroundMask: v, composite: g, radius: k, opacity: S, shadow: P, transform: w } = n, x = p.getPosition();
  h.save(), w.a !== void 0 || w.b !== void 0 || w.c !== void 0 || w.d !== void 0 ? h.setTransform((e = w.a) !== null && e !== void 0 ? e : 1, (t = w.b) !== null && t !== void 0 ? t : 0, (i = w.c) !== null && i !== void 0 ? i : 0, (s = w.d) !== null && s !== void 0 ? s : 1, x.x, x.y) : h.translate(x.x, x.y), h.beginPath();
  const T = p.rotation + (p.pathRotation ? p.velocity.angle : 0);
  T !== 0 && h.rotate(T), v && (h.globalCompositeOperation = g);
  const L = p.shadowColor;
  P.enable && L && (h.shadowBlur = P.blur, h.shadowColor = Q(L), h.shadowOffsetX = P.offset.x, h.shadowOffsetY = P.offset.y), m.fill && (h.fillStyle = m.fill);
  const A = p.stroke;
  h.lineWidth = (o = p.strokeWidth) !== null && o !== void 0 ? o : 0, m.stroke && (h.strokeStyle = m.stroke), dt(u, h, p, k, S, f), ((r = A == null ? void 0 : A.width) !== null && r !== void 0 ? r : 0) > 0 && h.stroke(), p.close && h.closePath(), p.fill && h.fill(), h.restore(), h.save(), w.a !== void 0 || w.b !== void 0 || w.c !== void 0 || w.d !== void 0 ? h.setTransform((a = w.a) !== null && a !== void 0 ? a : 1, (l = w.b) !== null && l !== void 0 ? l : 0, (c = w.c) !== null && c !== void 0 ? c : 0, (d = w.d) !== null && d !== void 0 ? d : 1, x.x, x.y) : h.translate(x.x, x.y), p.rotation && h.rotate(p.rotation), v && (h.globalCompositeOperation = g), ft(u, h, p, k, S, f), h.restore();
}
function dt(n, e, t, i, s, o) {
  if (!t.shape)
    return;
  const r = n.drawers.get(t.shape);
  !r || r.draw(e, t, i, s, o, n.retina.pixelRatio);
}
function ft(n, e, t, i, s, o) {
  if (!t.shape)
    return;
  const r = n.drawers.get(t.shape);
  !(r != null && r.afterEffect) || r.afterEffect(e, t, i, s, o, n.retina.pixelRatio);
}
function pt(n, e, t) {
  !e.draw || (n.save(), e.draw(n, t), n.restore());
}
function vt(n, e, t, i) {
  !e.drawParticle || (n.save(), e.drawParticle(n, t, i), n.restore());
}
function mt(n, e, t) {
  return {
    h: n.h,
    s: n.s,
    l: n.l + (e === "darken" ? -1 : 1) * t
  };
}
const X = "generated", be = "touchend", gt = "pointerdown", yt = "pointerup", we = "pointermove", _t = "touchstart", bt = "touchmove", xe = "pointerleave", wt = "pointerout", xt = "touchcancel", zt = "resize", Mt = "visibilitychange";
function Pt(n, e, t) {
  var i;
  const s = e[t];
  s !== void 0 && (n[t] = ((i = n[t]) !== null && i !== void 0 ? i : 1) * s);
}
class kt {
  constructor(e) {
    this.container = e, this.size = {
      height: 0,
      width: 0
    }, this._context = null, this._generatedCanvas = !1, this._preDrawUpdaters = [], this._postDrawUpdaters = [], this._resizePlugins = [], this._colorPlugins = [];
  }
  clear() {
    const e = this.container.actualOptions, t = e.particles.move.trail;
    e.backgroundMask.enable ? this.paint() : t.enable && t.length > 0 && this._trailFillColor ? this._paintBase(Q(this._trailFillColor, 1 / t.length)) : this.draw((i) => {
      se(i, this.size);
    });
  }
  destroy() {
    var e;
    this._generatedCanvas ? (e = this.element) === null || e === void 0 || e.remove() : this._resetOriginalStyle(), this.draw((t) => {
      se(t, this.size);
    }), this._preDrawUpdaters = [], this._postDrawUpdaters = [], this._resizePlugins = [], this._colorPlugins = [];
  }
  draw(e) {
    if (!!this._context)
      return e(this._context);
  }
  drawParticle(e, t) {
    var i;
    if (e.spawning || e.destroyed)
      return;
    const s = e.getRadius();
    if (s <= 0)
      return;
    const o = e.getFillColor(), r = (i = e.getStrokeColor()) !== null && i !== void 0 ? i : o;
    let [a, l] = this._getPluginParticleColors(e);
    a || (a = o), l || (l = r), !(!a && !l) && this.draw((c) => {
      var d, u, h, p, f;
      const m = this.container.actualOptions, v = e.options.zIndex, g = (1 - e.zIndexFactor) ** v.opacityRate, k = (h = (d = e.bubble.opacity) !== null && d !== void 0 ? d : (u = e.opacity) === null || u === void 0 ? void 0 : u.value) !== null && h !== void 0 ? h : 1, S = (f = (p = e.stroke) === null || p === void 0 ? void 0 : p.opacity) !== null && f !== void 0 ? f : k, P = k * g, w = S * g, x = {}, T = {
        fill: a ? ye(a, P) : void 0
      };
      T.stroke = l ? ye(l, w) : T.fill, this._applyPreDrawUpdaters(c, e, s, P, T, x), ut({
        container: this.container,
        context: c,
        particle: e,
        delta: t,
        colorStyles: T,
        backgroundMask: m.backgroundMask.enable,
        composite: m.backgroundMask.composite,
        radius: s * (1 - e.zIndexFactor) ** v.sizeRate,
        opacity: P,
        shadow: e.options.shadow,
        transform: x
      }), this._applyPostDrawUpdaters(e);
    });
  }
  drawParticlePlugin(e, t, i) {
    this.draw((s) => {
      vt(s, e, t, i);
    });
  }
  drawPlugin(e, t) {
    this.draw((i) => {
      pt(i, e, t);
    });
  }
  init() {
    this.resize(), this._initStyle(), this._initCover(), this._initTrail(), this.initBackground(), this.initUpdaters(), this.initPlugins(), this.paint();
  }
  initBackground() {
    const e = this.container.actualOptions, t = e.background, i = this.element, s = i == null ? void 0 : i.style;
    if (!!s) {
      if (t.color) {
        const o = B(t.color);
        s.backgroundColor = o ? Q(o, t.opacity) : "";
      } else
        s.backgroundColor = "";
      s.backgroundImage = t.image || "", s.backgroundPosition = t.position || "", s.backgroundRepeat = t.repeat || "", s.backgroundSize = t.size || "";
    }
  }
  initPlugins() {
    this._resizePlugins = [];
    for (const [, e] of this.container.plugins)
      e.resize && this._resizePlugins.push(e), (e.particleFillColor || e.particleStrokeColor) && this._colorPlugins.push(e);
  }
  initUpdaters() {
    this._preDrawUpdaters = [], this._postDrawUpdaters = [];
    for (const e of this.container.particles.updaters)
      e.afterDraw && this._postDrawUpdaters.push(e), (e.getColorStyles || e.getTransformValues || e.beforeDraw) && this._preDrawUpdaters.push(e);
  }
  loadCanvas(e) {
    var t;
    this._generatedCanvas && ((t = this.element) === null || t === void 0 || t.remove()), this._generatedCanvas = e.dataset && X in e.dataset ? e.dataset[X] === "true" : this._generatedCanvas, this.element = e, this._originalStyle = M({}, this.element.style), this.size.height = e.offsetHeight, this.size.width = e.offsetWidth, this._context = this.element.getContext("2d"), this.container.retina.init(), this.initBackground();
  }
  paint() {
    const e = this.container.actualOptions;
    this.draw((t) => {
      e.backgroundMask.enable && e.backgroundMask.cover ? (se(t, this.size), this._paintBase(this._coverColorStyle)) : this._paintBase();
    });
  }
  resize() {
    if (!this.element)
      return;
    const e = this.container, t = e.retina.pixelRatio, i = e.canvas.size, s = {
      width: this.element.offsetWidth * t,
      height: this.element.offsetHeight * t
    };
    if (s.height === i.height && s.width === i.width && s.height === this.element.height && s.width === this.element.width)
      return;
    const o = Object.assign({}, i);
    this.element.width = i.width = this.element.offsetWidth * t, this.element.height = i.height = this.element.offsetHeight * t, this.container.started && (this.resizeFactor = {
      width: i.width / o.width,
      height: i.height / o.height
    });
  }
  async windowResize() {
    if (!this.element)
      return;
    this.resize();
    const e = this.container, t = e.updateActualOptions();
    e.particles.setDensity(), this._applyResizePlugins(), t && await e.refresh();
  }
  _applyPostDrawUpdaters(e) {
    var t;
    for (const i of this._postDrawUpdaters)
      (t = i.afterDraw) === null || t === void 0 || t.call(i, e);
  }
  _applyPreDrawUpdaters(e, t, i, s, o, r) {
    var a;
    for (const l of this._preDrawUpdaters) {
      if (l.getColorStyles) {
        const { fill: c, stroke: d } = l.getColorStyles(t, e, i, s);
        c && (o.fill = c), d && (o.stroke = d);
      }
      if (l.getTransformValues) {
        const c = l.getTransformValues(t);
        for (const d in c)
          Pt(r, c, d);
      }
      (a = l.beforeDraw) === null || a === void 0 || a.call(l, t);
    }
  }
  _applyResizePlugins() {
    var e;
    for (const t of this._resizePlugins)
      (e = t.resize) === null || e === void 0 || e.call(t);
  }
  _getPluginParticleColors(e) {
    let t, i;
    for (const s of this._colorPlugins)
      if (!t && s.particleFillColor && (t = ge(s.particleFillColor(e))), !i && s.particleStrokeColor && (i = ge(s.particleStrokeColor(e))), t && i)
        break;
    return [t, i];
  }
  _initCover() {
    const e = this.container.actualOptions, t = e.backgroundMask.cover, i = t.color, s = B(i);
    if (s) {
      const o = {
        r: s.r,
        g: s.g,
        b: s.b,
        a: t.opacity
      };
      this._coverColorStyle = Q(o, o.a);
    }
  }
  _initStyle() {
    const e = this.element, t = this.container.actualOptions;
    if (!!e) {
      t.fullScreen.enable ? (this._originalStyle = M({}, e.style), e.style.setProperty("position", "fixed", "important"), e.style.setProperty("z-index", t.fullScreen.zIndex.toString(10), "important"), e.style.setProperty("top", "0", "important"), e.style.setProperty("left", "0", "important"), e.style.setProperty("width", "100%", "important"), e.style.setProperty("height", "100%", "important")) : this._resetOriginalStyle();
      for (const i in t.style) {
        if (!i || !t.style)
          continue;
        const s = t.style[i];
        !s || e.style.setProperty(i, s, "important");
      }
    }
  }
  _initTrail() {
    const e = this.container.actualOptions, t = e.particles.move.trail, i = B(t.fillColor);
    if (i) {
      const s = e.particles.move.trail;
      this._trailFillColor = {
        r: i.r,
        g: i.g,
        b: i.b,
        a: 1 / s.length
      };
    }
  }
  _paintBase(e) {
    this.draw((t) => {
      ct(t, this.size, e);
    });
  }
  _resetOriginalStyle() {
    const e = this.element, t = this._originalStyle;
    e && t && (e.style.position = t.position, e.style.zIndex = t.zIndex, e.style.top = t.top, e.style.left = t.left, e.style.width = t.width, e.style.height = t.height);
  }
}
function O(n, e, t, i, s) {
  if (i) {
    let o = { passive: !0 };
    typeof s == "boolean" ? o.capture = s : s !== void 0 && (o = s), n.addEventListener(e, t, o);
  } else {
    const o = s;
    n.removeEventListener(e, t, o);
  }
}
class Ct {
  constructor(e) {
    this.container = e, this.canPush = !0, this.mouseMoveHandler = (t) => this.mouseTouchMove(t), this.touchStartHandler = (t) => this.mouseTouchMove(t), this.touchMoveHandler = (t) => this.mouseTouchMove(t), this.touchEndHandler = () => this.mouseTouchFinish(), this.mouseLeaveHandler = () => this.mouseTouchFinish(), this.touchCancelHandler = () => this.mouseTouchFinish(), this.touchEndClickHandler = (t) => this.mouseTouchClick(t), this.mouseUpHandler = (t) => this.mouseTouchClick(t), this.mouseDownHandler = () => this.mouseDown(), this.visibilityChangeHandler = () => this.handleVisibilityChange(), this.themeChangeHandler = (t) => this.handleThemeChange(t), this.oldThemeChangeHandler = (t) => this.handleThemeChange(t), this.resizeHandler = () => this.handleWindowResize();
  }
  addListeners() {
    this.manageListeners(!0);
  }
  removeListeners() {
    this.manageListeners(!1);
  }
  doMouseTouchClick(e) {
    const t = this.container, i = t.actualOptions;
    if (this.canPush) {
      const s = t.interactivity.mouse.position;
      if (!s)
        return;
      t.interactivity.mouse.clickPosition = Object.assign({}, s), t.interactivity.mouse.clickTime = new Date().getTime();
      const o = i.interactivity.events.onClick;
      U(o.mode, (r) => this.handleClickMode(r));
    }
    e.type === "touchend" && setTimeout(() => this.mouseTouchFinish(), 500);
  }
  handleClickMode(e) {
    this.container.handleClickMode(e);
  }
  handleThemeChange(e) {
    const t = e, i = t.matches ? this.container.options.defaultDarkTheme : this.container.options.defaultLightTheme, s = this.container.options.themes.find((o) => o.name === i);
    s && s.default.auto && this.container.loadTheme(i);
  }
  handleVisibilityChange() {
    const e = this.container, t = e.actualOptions;
    this.mouseTouchFinish(), t.pauseOnBlur && (document != null && document.hidden ? (e.pageHidden = !0, e.pause()) : (e.pageHidden = !1, e.getAnimationStatus() ? e.play(!0) : e.draw(!0)));
  }
  handleWindowResize() {
    this.resizeTimeout && (clearTimeout(this.resizeTimeout), delete this.resizeTimeout), this.resizeTimeout = setTimeout(async () => {
      var e;
      return (e = this.container.canvas) === null || e === void 0 ? void 0 : e.windowResize();
    }, 500);
  }
  manageListeners(e) {
    var t;
    const i = this.container, s = i.actualOptions, o = s.interactivity.detectsOn;
    let r = xe;
    if (o === "window")
      i.interactivity.element = window, r = wt;
    else if (o === "parent" && i.canvas.element) {
      const d = i.canvas.element;
      i.interactivity.element = (t = d.parentElement) !== null && t !== void 0 ? t : d.parentNode;
    } else
      i.interactivity.element = i.canvas.element;
    const a = ce("(prefers-color-scheme: dark)");
    a && (a.addEventListener !== void 0 ? O(a, "change", this.themeChangeHandler, e) : a.addListener !== void 0 && (e ? a.addListener(this.oldThemeChangeHandler) : a.removeListener(this.oldThemeChangeHandler)));
    const l = i.interactivity.element;
    if (!l)
      return;
    const c = l;
    (s.interactivity.events.onHover.enable || s.interactivity.events.onClick.enable) && (O(l, we, this.mouseMoveHandler, e), O(l, _t, this.touchStartHandler, e), O(l, bt, this.touchMoveHandler, e), s.interactivity.events.onClick.enable ? (O(l, be, this.touchEndClickHandler, e), O(l, yt, this.mouseUpHandler, e), O(l, gt, this.mouseDownHandler, e)) : O(l, be, this.touchEndHandler, e), O(l, r, this.mouseLeaveHandler, e), O(l, xt, this.touchCancelHandler, e)), i.canvas.element && (i.canvas.element.style.pointerEvents = c === i.canvas.element ? "initial" : "none"), s.interactivity.events.resize && (typeof ResizeObserver < "u" ? this.resizeObserver && !e ? (i.canvas.element && this.resizeObserver.unobserve(i.canvas.element), this.resizeObserver.disconnect(), delete this.resizeObserver) : !this.resizeObserver && e && i.canvas.element && (this.resizeObserver = new ResizeObserver((d) => {
      !d.find((h) => h.target === i.canvas.element) || this.handleWindowResize();
    }), this.resizeObserver.observe(i.canvas.element)) : O(window, zt, this.resizeHandler, e)), document && O(document, Mt, this.visibilityChangeHandler, e, !1);
  }
  mouseDown() {
    const e = this.container.interactivity;
    if (e) {
      const t = e.mouse;
      t.clicking = !0, t.downPosition = t.position;
    }
  }
  mouseTouchClick(e) {
    const t = this.container, i = t.actualOptions, s = t.interactivity.mouse;
    s.inside = !0;
    let o = !1;
    const r = s.position;
    if (!(!r || !i.interactivity.events.onClick.enable)) {
      for (const [, a] of t.plugins)
        if (!!a.clickPositionValid && (o = a.clickPositionValid(r), o))
          break;
      o || this.doMouseTouchClick(e), s.clicking = !1;
    }
  }
  mouseTouchFinish() {
    const e = this.container.interactivity;
    if (!e)
      return;
    const t = e.mouse;
    delete t.position, delete t.clickPosition, delete t.downPosition, e.status = xe, t.inside = !1, t.clicking = !1;
  }
  mouseTouchMove(e) {
    var t, i, s, o, r, a, l;
    const c = this.container, d = c.actualOptions;
    if (!(!((t = c.interactivity) === null || t === void 0) && t.element))
      return;
    c.interactivity.mouse.inside = !0;
    let u;
    const h = c.canvas.element;
    if (e.type.startsWith("pointer")) {
      this.canPush = !0;
      const f = e;
      if (c.interactivity.element === window) {
        if (h) {
          const m = h.getBoundingClientRect();
          u = {
            x: f.clientX - m.left,
            y: f.clientY - m.top
          };
        }
      } else if (d.interactivity.detectsOn === "parent") {
        const m = f.target, v = f.currentTarget, g = c.canvas.element;
        if (m && v && g) {
          const k = m.getBoundingClientRect(), S = v.getBoundingClientRect(), P = g.getBoundingClientRect();
          u = {
            x: f.offsetX + 2 * k.left - (S.left + P.left),
            y: f.offsetY + 2 * k.top - (S.top + P.top)
          };
        } else
          u = {
            x: (i = f.offsetX) !== null && i !== void 0 ? i : f.clientX,
            y: (s = f.offsetY) !== null && s !== void 0 ? s : f.clientY
          };
      } else
        f.target === c.canvas.element && (u = {
          x: (o = f.offsetX) !== null && o !== void 0 ? o : f.clientX,
          y: (r = f.offsetY) !== null && r !== void 0 ? r : f.clientY
        });
    } else {
      this.canPush = e.type !== "touchmove";
      const f = e, m = f.touches[f.touches.length - 1], v = h == null ? void 0 : h.getBoundingClientRect();
      u = {
        x: m.clientX - ((a = v == null ? void 0 : v.left) !== null && a !== void 0 ? a : 0),
        y: m.clientY - ((l = v == null ? void 0 : v.top) !== null && l !== void 0 ? l : 0)
      };
    }
    const p = c.retina.pixelRatio;
    u && (u.x *= p, u.y *= p), c.interactivity.mouse.position = u, c.interactivity.status = we;
  }
}
function Ot(n, e = 60, t = !1) {
  return {
    value: n,
    factor: t ? 60 / e : 60 * n / 1e3
  };
}
class St {
  constructor(e) {
    this.container = e;
  }
  async nextFrame(e) {
    var t;
    try {
      const i = this.container;
      if (!i.smooth && i.lastFrameTime !== void 0 && e < i.lastFrameTime + 1e3 / i.fpsLimit) {
        i.draw(!1);
        return;
      }
      (t = i.lastFrameTime) !== null && t !== void 0 || (i.lastFrameTime = e);
      const s = Ot(e - i.lastFrameTime, i.fpsLimit, i.smooth);
      if (i.lifeTime += s.value, i.lastFrameTime = e, s.value > 1e3) {
        i.draw(!1);
        return;
      }
      if (await i.particles.draw(s), i.duration > 0 && i.lifeTime > i.duration) {
        i.destroy();
        return;
      }
      i.getAnimationStatus() && i.draw(!1);
    } catch (i) {
      console.error("tsParticles error in animation loop", i);
    }
  }
}
class I {
  constructor() {
    this.value = "";
  }
  static create(e, t) {
    const i = new I();
    return i.load(e), t !== void 0 && (typeof t == "string" || t instanceof Array ? i.load({ value: t }) : i.load(t)), i;
  }
  load(e) {
    (e == null ? void 0 : e.value) !== void 0 && (this.value = e.value);
  }
}
class Rt {
  constructor() {
    this.color = new I(), this.color.value = "", this.image = "", this.position = "", this.repeat = "", this.size = "", this.opacity = 1;
  }
  load(e) {
    !e || (e.color !== void 0 && (this.color = I.create(this.color, e.color)), e.image !== void 0 && (this.image = e.image), e.position !== void 0 && (this.position = e.position), e.repeat !== void 0 && (this.repeat = e.repeat), e.size !== void 0 && (this.size = e.size), e.opacity !== void 0 && (this.opacity = e.opacity));
  }
}
class It {
  constructor() {
    this.color = new I(), this.color.value = "#fff", this.opacity = 1;
  }
  load(e) {
    !e || (e.color !== void 0 && (this.color = I.create(this.color, e.color)), e.opacity !== void 0 && (this.opacity = e.opacity));
  }
}
class Tt {
  constructor() {
    this.composite = "destination-out", this.cover = new It(), this.enable = !1;
  }
  load(e) {
    if (!!e) {
      if (e.composite !== void 0 && (this.composite = e.composite), e.cover !== void 0) {
        const t = e.cover, i = typeof e.cover == "string" ? { color: e.cover } : e.cover;
        this.cover.load(t.color !== void 0 ? t : { color: i });
      }
      e.enable !== void 0 && (this.enable = e.enable);
    }
  }
}
class Et {
  constructor() {
    this.enable = !0, this.zIndex = 0;
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.zIndex !== void 0 && (this.zIndex = e.zIndex));
  }
}
class Dt {
  constructor() {
    this.enable = !1, this.mode = [];
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode));
  }
}
class ze {
  constructor() {
    this.selectors = [], this.enable = !1, this.mode = [], this.type = "circle";
  }
  get el() {
    return this.elementId;
  }
  set el(e) {
    this.elementId = e;
  }
  get elementId() {
    return this.ids;
  }
  set elementId(e) {
    this.ids = e;
  }
  get ids() {
    return U(this.selectors, (e) => e.replace("#", ""));
  }
  set ids(e) {
    this.selectors = U(e, (t) => `#${t}`);
  }
  load(e) {
    var t, i;
    if (!e)
      return;
    const s = (i = (t = e.ids) !== null && t !== void 0 ? t : e.elementId) !== null && i !== void 0 ? i : e.el;
    s !== void 0 && (this.ids = s), e.selectors !== void 0 && (this.selectors = e.selectors), e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), e.type !== void 0 && (this.type = e.type);
  }
}
class At {
  constructor() {
    this.enable = !1, this.force = 2, this.smooth = 10;
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.force !== void 0 && (this.force = e.force), e.smooth !== void 0 && (this.smooth = e.smooth));
  }
}
class Lt {
  constructor() {
    this.enable = !1, this.mode = [], this.parallax = new At();
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), this.parallax.load(e.parallax));
  }
}
class Ft {
  constructor() {
    this.onClick = new Dt(), this.onDiv = new ze(), this.onHover = new Lt(), this.resize = !0;
  }
  get onclick() {
    return this.onClick;
  }
  set onclick(e) {
    this.onClick = e;
  }
  get ondiv() {
    return this.onDiv;
  }
  set ondiv(e) {
    this.onDiv = e;
  }
  get onhover() {
    return this.onHover;
  }
  set onhover(e) {
    this.onHover = e;
  }
  load(e) {
    var t, i, s;
    if (!e)
      return;
    this.onClick.load((t = e.onClick) !== null && t !== void 0 ? t : e.onclick);
    const o = (i = e.onDiv) !== null && i !== void 0 ? i : e.ondiv;
    o !== void 0 && (this.onDiv = U(o, (r) => {
      const a = new ze();
      return a.load(r), a;
    })), this.onHover.load((s = e.onHover) !== null && s !== void 0 ? s : e.onhover), e.resize !== void 0 && (this.resize = e.resize);
  }
}
class Ht {
  constructor(e, t) {
    this._engine = e, this._container = t;
  }
  load(e) {
    if (!!e && this._container) {
      const t = this._engine.plugins.interactors.get(this._container);
      if (t)
        for (const i of t)
          i.loadModeOptions && i.loadModeOptions(this, e);
    }
  }
}
class Te {
  constructor(e, t) {
    this.detectsOn = "window", this.events = new Ft(), this.modes = new Ht(e, t);
  }
  get detect_on() {
    return this.detectsOn;
  }
  set detect_on(e) {
    this.detectsOn = e;
  }
  load(e) {
    var t;
    if (!e)
      return;
    const i = (t = e.detectsOn) !== null && t !== void 0 ? t : e.detect_on;
    i !== void 0 && (this.detectsOn = i), this.events.load(e.events), this.modes.load(e.modes);
  }
}
class Vt {
  load(e) {
    var t, i;
    !e || (e.position !== void 0 && (this.position = {
      x: (t = e.position.x) !== null && t !== void 0 ? t : 50,
      y: (i = e.position.y) !== null && i !== void 0 ? i : 50
    }), e.options !== void 0 && (this.options = M({}, e.options)));
  }
}
class Wt {
  constructor() {
    this.factor = 4, this.value = !0;
  }
  load(e) {
    !e || (e.factor !== void 0 && (this.factor = e.factor), e.value !== void 0 && (this.value = e.value));
  }
}
class Bt {
  constructor() {
    this.disable = !1, this.reduce = new Wt();
  }
  load(e) {
    !e || (e.disable !== void 0 && (this.disable = e.disable), this.reduce.load(e.reduce));
  }
}
class Ut {
  constructor() {
    this.maxWidth = 1 / 0, this.options = {}, this.mode = "canvas";
  }
  load(e) {
    !e || (e.maxWidth !== void 0 && (this.maxWidth = e.maxWidth), e.mode !== void 0 && (e.mode === "screen" ? this.mode = "screen" : this.mode = "canvas"), e.options !== void 0 && (this.options = M({}, e.options)));
  }
}
class qt {
  constructor() {
    this.auto = !1, this.mode = "any", this.value = !1;
  }
  load(e) {
    !e || (e.auto !== void 0 && (this.auto = e.auto), e.mode !== void 0 && (this.mode = e.mode), e.value !== void 0 && (this.value = e.value));
  }
}
class Gt {
  constructor() {
    this.name = "", this.default = new qt();
  }
  load(e) {
    !e || (e.name !== void 0 && (this.name = e.name), this.default.load(e.default), e.options !== void 0 && (this.options = M({}, e.options)));
  }
}
class ne {
  constructor() {
    this.count = 0, this.enable = !1, this.offset = 0, this.speed = 1, this.decay = 0, this.sync = !0;
  }
  load(e) {
    !e || (e.count !== void 0 && (this.count = _(e.count)), e.enable !== void 0 && (this.enable = e.enable), e.offset !== void 0 && (this.offset = _(e.offset)), e.speed !== void 0 && (this.speed = _(e.speed)), e.decay !== void 0 && (this.decay = _(e.decay)), e.sync !== void 0 && (this.sync = e.sync));
  }
}
class $t {
  constructor() {
    this.h = new ne(), this.s = new ne(), this.l = new ne();
  }
  load(e) {
    !e || (this.h.load(e.h), this.s.load(e.s), this.l.load(e.l));
  }
}
class Y extends I {
  constructor() {
    super(), this.animation = new $t();
  }
  static create(e, t) {
    const i = new Y();
    return i.load(e), t !== void 0 && (typeof t == "string" || t instanceof Array ? i.load({ value: t }) : i.load(t)), i;
  }
  load(e) {
    if (super.load(e), !e)
      return;
    const t = e.animation;
    t !== void 0 && (t.enable !== void 0 ? this.animation.h.load(t) : this.animation.load(e.animation));
  }
}
class Nt {
  constructor() {
    this.enable = !0, this.retries = 0;
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.retries !== void 0 && (this.retries = e.retries));
  }
}
class Xt {
  constructor() {
    this.enable = !1, this.minimumValue = 0;
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), e.minimumValue !== void 0 && (this.minimumValue = e.minimumValue));
  }
}
class j {
  constructor() {
    this.random = new Xt(), this.value = 0;
  }
  load(e) {
    !e || (typeof e.random == "boolean" ? this.random.enable = e.random : this.random.load(e.random), e.value !== void 0 && (this.value = _(e.value, this.random.enable ? this.random.minimumValue : void 0)));
  }
}
class Me extends j {
  constructor() {
    super(), this.random.minimumValue = 0.1, this.value = 1;
  }
}
class Ee {
  constructor() {
    this.horizontal = new Me(), this.vertical = new Me();
  }
  load(e) {
    !e || (this.horizontal.load(e.horizontal), this.vertical.load(e.vertical));
  }
}
class Yt {
  constructor() {
    this.bounce = new Ee(), this.enable = !1, this.mode = "bounce", this.overlap = new Nt();
  }
  load(e) {
    !e || (this.bounce.load(e.bounce), e.enable !== void 0 && (this.enable = e.enable), e.mode !== void 0 && (this.mode = e.mode), this.overlap.load(e.overlap));
  }
}
class jt {
  constructor() {
    this.offset = 0, this.value = 90;
  }
  load(e) {
    !e || (e.offset !== void 0 && (this.offset = _(e.offset)), e.value !== void 0 && (this.value = _(e.value)));
  }
}
class Jt {
  constructor() {
    this.distance = 200, this.enable = !1, this.rotate = {
      x: 3e3,
      y: 3e3
    };
  }
  get rotateX() {
    return this.rotate.x;
  }
  set rotateX(e) {
    this.rotate.x = e;
  }
  get rotateY() {
    return this.rotate.y;
  }
  set rotateY(e) {
    this.rotate.y = e;
  }
  load(e) {
    var t, i, s, o;
    if (!e)
      return;
    e.distance !== void 0 && (this.distance = _(e.distance)), e.enable !== void 0 && (this.enable = e.enable);
    const r = (i = (t = e.rotate) === null || t === void 0 ? void 0 : t.x) !== null && i !== void 0 ? i : e.rotateX;
    r !== void 0 && (this.rotate.x = r);
    const a = (o = (s = e.rotate) === null || s === void 0 ? void 0 : s.y) !== null && o !== void 0 ? o : e.rotateY;
    a !== void 0 && (this.rotate.y = a);
  }
}
class Zt {
  constructor() {
    this.acceleration = 9.81, this.enable = !1, this.inverse = !1, this.maxSpeed = 50;
  }
  load(e) {
    !e || (e.acceleration !== void 0 && (this.acceleration = _(e.acceleration)), e.enable !== void 0 && (this.enable = e.enable), e.inverse !== void 0 && (this.inverse = e.inverse), e.maxSpeed !== void 0 && (this.maxSpeed = _(e.maxSpeed)));
  }
}
class Qt extends j {
  constructor() {
    super();
  }
}
class Kt {
  constructor() {
    this.clamp = !0, this.delay = new Qt(), this.enable = !1, this.options = {};
  }
  load(e) {
    !e || (e.clamp !== void 0 && (this.clamp = e.clamp), this.delay.load(e.delay), e.enable !== void 0 && (this.enable = e.enable), this.generator = e.generator, e.options && (this.options = M(this.options, e.options)));
  }
}
class ei {
  constructor() {
    this.enable = !1, this.length = 10, this.fillColor = new I(), this.fillColor.value = "#000000";
  }
  load(e) {
    !e || (e.enable !== void 0 && (this.enable = e.enable), this.fillColor = I.create(this.fillColor, e.fillColor), e.length !== void 0 && (this.length = e.length));
  }
}
class ti {
  constructor() {
    this.default = "out";
  }
  load(e) {
    var t, i, s, o;
    !e || (e.default !== void 0 && (this.default = e.default), this.bottom = (t = e.bottom) !== null && t !== void 0 ? t : e.default, this.left = (i = e.left) !== null && i !== void 0 ? i : e.default, this.right = (s = e.right) !== null && s !== void 0 ? s : e.default, this.top = (o = e.top) !== null && o !== void 0 ? o : e.default);
  }
}
class ii {
  constructor() {
    this.acceleration = 0, this.enable = !1;
  }
  load(e) {
    !e || (e.acceleration !== void 0 && (this.acceleration = _(e.acceleration)), e.enable !== void 0 && (this.enable = e.enable), this.position = e.position ? M({}, e.position) : void 0);
  }
}
class si {
  constructor() {
    this.angle = new jt(), this.attract = new Jt(), this.center = {
      x: 50,
      y: 50,
      mode: "percent",
      radius: 0
    }, this.decay = 0, this.distance = {}, this.direction = "none", this.drift = 0, this.enable = !1, this.gravity = new Zt(), this.path = new Kt(), this.outModes = new ti(), this.random = !1, this.size = !1, this.speed = 2, this.spin = new ii(), this.straight = !1, this.trail = new ei(), this.vibrate = !1, this.warp = !1;
  }
  get bounce() {
    return this.collisions;
  }
  set bounce(e) {
    this.collisions = e;
  }
  get collisions() {
    return !1;
  }
  set collisions(e) {
  }
  get noise() {
    return this.path;
  }
  set noise(e) {
    this.path = e;
  }
  get outMode() {
    return this.outModes.default;
  }
  set outMode(e) {
    this.outModes.default = e;
  }
  get out_mode() {
    return this.outMode;
  }
  set out_mode(e) {
    this.outMode = e;
  }
  load(e) {
    var t, i, s, o;
    if (!e)
      return;
    this.angle.load(typeof e.angle == "number" ? { value: e.angle } : e.angle), this.attract.load(e.attract), this.center = M((t = this.center) !== null && t !== void 0 ? t : {}, e.center), e.decay !== void 0 && (this.decay = e.decay), e.direction !== void 0 && (this.direction = e.direction), e.distance !== void 0 && (this.distance = typeof e.distance == "number" ? {
      horizontal: e.distance,
      vertical: e.distance
    } : Object.assign({}, e.distance)), e.drift !== void 0 && (this.drift = _(e.drift)), e.enable !== void 0 && (this.enable = e.enable), this.gravity.load(e.gravity);
    const r = (s = (i = e.outModes) !== null && i !== void 0 ? i : e.outMode) !== null && s !== void 0 ? s : e.out_mode;
    r !== void 0 && (typeof r == "object" ? this.outModes.load(r) : this.outModes.load({
      default: r
    })), this.path.load((o = e.path) !== null && o !== void 0 ? o : e.noise), e.random !== void 0 && (this.random = e.random), e.size !== void 0 && (this.size = e.size), e.speed !== void 0 && (this.speed = _(e.speed)), this.spin.load(e.spin), e.straight !== void 0 && (this.straight = e.straight), this.trail.load(e.trail), e.vibrate !== void 0 && (this.vibrate = e.vibrate), e.warp !== void 0 && (this.warp = e.warp);
  }
}
class De {
  constructor() {
    this.count = 0, this.enable = !1, this.speed = 1, this.decay = 0, this.sync = !1;
  }
  load(e) {
    !e || (e.count !== void 0 && (this.count = _(e.count)), e.enable !== void 0 && (this.enable = e.enable), e.speed !== void 0 && (this.speed = _(e.speed)), e.decay !== void 0 && (this.decay = _(e.decay)), e.sync !== void 0 && (this.sync = e.sync));
  }
}
class ni extends De {
  constructor() {
    super(), this.destroy = "none", this.enable = !1, this.speed = 2, this.startValue = "random", this.sync = !1;
  }
  get opacity_min() {
    return this.minimumValue;
  }
  set opacity_min(e) {
    this.minimumValue = e;
  }
  load(e) {
    var t;
    !e || (super.load(e), e.destroy !== void 0 && (this.destroy = e.destroy), e.enable !== void 0 && (this.enable = e.enable), this.minimumValue = (t = e.minimumValue) !== null && t !== void 0 ? t : e.opacity_min, e.speed !== void 0 && (this.speed = e.speed), e.startValue !== void 0 && (this.startValue = e.startValue), e.sync !== void 0 && (this.sync = e.sync));
  }
}
class oi extends j {
  constructor() {
    super(), this.animation = new ni(), this.random.minimumValue = 0.1, this.value = 1;
  }
  get anim() {
    return this.animation;
  }
  set anim(e) {
    this.animation = e;
  }
  load(e) {
    var t;
    if (!e)
      return;
    super.load(e);
    const i = (t = e.animation) !== null && t !== void 0 ? t : e.anim;
    i !== void 0 && (this.animation.load(i), this.value = _(this.value, this.animation.enable ? this.animation.minimumValue : void 0));
  }
}
class ri {
  constructor() {
    this.enable = !1, this.area = 800, this.factor = 1e3;
  }
  get value_area() {
    return this.area;
  }
  set value_area(e) {
    this.area = e;
  }
  load(e) {
    var t;
    if (!e)
      return;
    e.enable !== void 0 && (this.enable = e.enable);
    const i = (t = e.area) !== null && t !== void 0 ? t : e.value_area;
    i !== void 0 && (this.area = i), e.factor !== void 0 && (this.factor = e.factor);
  }
}
class ai {
  constructor() {
    this.density = new ri(), this.limit = 0, this.value = 100;
  }
  get max() {
    return this.limit;
  }
  set max(e) {
    this.limit = e;
  }
  load(e) {
    var t;
    if (!e)
      return;
    this.density.load(e.density);
    const i = (t = e.limit) !== null && t !== void 0 ? t : e.max;
    i !== void 0 && (this.limit = i), e.value !== void 0 && (this.value = e.value);
  }
}
class li {
  constructor() {
    this.blur = 0, this.color = new I(), this.enable = !1, this.offset = {
      x: 0,
      y: 0
    }, this.color.value = "#000";
  }
  load(e) {
    !e || (e.blur !== void 0 && (this.blur = e.blur), this.color = I.create(this.color, e.color), e.enable !== void 0 && (this.enable = e.enable), e.offset !== void 0 && (e.offset.x !== void 0 && (this.offset.x = e.offset.x), e.offset.y !== void 0 && (this.offset.y = e.offset.y)));
  }
}
class Ae {
  constructor() {
    this.options = {}, this.type = "circle";
  }
  get character() {
    var e;
    return (e = this.options.character) !== null && e !== void 0 ? e : this.options.char;
  }
  set character(e) {
    this.options.character = e, this.options.char = e;
  }
  get custom() {
    return this.options;
  }
  set custom(e) {
    this.options = e;
  }
  get image() {
    var e;
    return (e = this.options.image) !== null && e !== void 0 ? e : this.options.images;
  }
  set image(e) {
    this.options.image = e, this.options.images = e;
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
  get polygon() {
    var e;
    return (e = this.options.polygon) !== null && e !== void 0 ? e : this.options.star;
  }
  set polygon(e) {
    this.options.polygon = e, this.options.star = e;
  }
  get stroke() {
    return [];
  }
  set stroke(e) {
  }
  load(e) {
    var t, i, s;
    if (!e)
      return;
    const o = (t = e.options) !== null && t !== void 0 ? t : e.custom;
    if (o !== void 0)
      for (const r in o) {
        const a = o[r];
        a && (this.options[r] = M((i = this.options[r]) !== null && i !== void 0 ? i : {}, a));
      }
    this.loadShape(e.character, "character", "char", !0), this.loadShape(e.polygon, "polygon", "star", !1), this.loadShape((s = e.image) !== null && s !== void 0 ? s : e.images, "image", "images", !0), e.type !== void 0 && (this.type = e.type);
  }
  loadShape(e, t, i, s) {
    var o, r;
    if (!e)
      return;
    const a = e instanceof Array, l = a ? [] : {}, c = a !== this.options[t] instanceof Array, d = a !== this.options[i] instanceof Array;
    c && (this.options[t] = l), d && s && (this.options[i] = l), this.options[t] = M((o = this.options[t]) !== null && o !== void 0 ? o : l, e), (!this.options[i] || s) && (this.options[i] = M((r = this.options[i]) !== null && r !== void 0 ? r : l, e));
  }
}
class hi extends De {
  constructor() {
    super(), this.destroy = "none", this.enable = !1, this.speed = 5, this.startValue = "random", this.sync = !1;
  }
  get size_min() {
    return this.minimumValue;
  }
  set size_min(e) {
    this.minimumValue = e;
  }
  load(e) {
    var t;
    super.load(e), e && (e.destroy !== void 0 && (this.destroy = e.destroy), e.enable !== void 0 && (this.enable = e.enable), this.minimumValue = (t = e.minimumValue) !== null && t !== void 0 ? t : e.size_min, e.speed !== void 0 && (this.speed = e.speed), e.startValue !== void 0 && (this.startValue = e.startValue), e.sync !== void 0 && (this.sync = e.sync));
  }
}
class ci extends j {
  constructor() {
    super(), this.animation = new hi(), this.random.minimumValue = 1, this.value = 3;
  }
  get anim() {
    return this.animation;
  }
  set anim(e) {
    this.animation = e;
  }
  load(e) {
    var t;
    if (super.load(e), !e)
      return;
    const i = (t = e.animation) !== null && t !== void 0 ? t : e.anim;
    i !== void 0 && (this.animation.load(i), this.value = _(this.value, this.animation.enable ? this.animation.minimumValue : void 0));
  }
}
class Pe {
  constructor() {
    this.width = 0;
  }
  load(e) {
    !e || (e.color !== void 0 && (this.color = Y.create(this.color, e.color)), e.width !== void 0 && (this.width = e.width), e.opacity !== void 0 && (this.opacity = e.opacity));
  }
}
class ui extends j {
  constructor() {
    super(), this.opacityRate = 1, this.sizeRate = 1, this.velocityRate = 1;
  }
  load(e) {
    super.load(e), e && (e.opacityRate !== void 0 && (this.opacityRate = e.opacityRate), e.sizeRate !== void 0 && (this.sizeRate = e.sizeRate), e.velocityRate !== void 0 && (this.velocityRate = e.velocityRate));
  }
}
class di {
  constructor(e, t) {
    this._engine = e, this._container = t, this.bounce = new Ee(), this.collisions = new Yt(), this.color = new Y(), this.color.value = "#fff", this.groups = {}, this.move = new si(), this.number = new ai(), this.opacity = new oi(), this.reduceDuplicates = !1, this.shadow = new li(), this.shape = new Ae(), this.size = new ci(), this.stroke = new Pe(), this.zIndex = new ui();
  }
  load(e) {
    var t, i, s, o, r, a;
    if (!e)
      return;
    if (this.bounce.load(e.bounce), this.color.load(Y.create(this.color, e.color)), e.groups !== void 0)
      for (const d in e.groups) {
        const u = e.groups[d];
        u !== void 0 && (this.groups[d] = M((t = this.groups[d]) !== null && t !== void 0 ? t : {}, u));
      }
    this.move.load(e.move), this.number.load(e.number), this.opacity.load(e.opacity), e.reduceDuplicates !== void 0 && (this.reduceDuplicates = e.reduceDuplicates), this.shape.load(e.shape), this.size.load(e.size), this.shadow.load(e.shadow), this.zIndex.load(e.zIndex);
    const l = (s = (i = e.move) === null || i === void 0 ? void 0 : i.collisions) !== null && s !== void 0 ? s : (o = e.move) === null || o === void 0 ? void 0 : o.bounce;
    l !== void 0 && (this.collisions.enable = l), this.collisions.load(e.collisions), e.interactivity !== void 0 && (this.interactivity = M({}, e.interactivity));
    const c = (r = e.stroke) !== null && r !== void 0 ? r : (a = e.shape) === null || a === void 0 ? void 0 : a.stroke;
    if (c && (this.stroke = U(c, (d) => {
      const u = new Pe();
      return u.load(d), u;
    })), this._container) {
      const d = this._engine.plugins.updaters.get(this._container);
      if (d)
        for (const h of d)
          h.loadOptions && h.loadOptions(this, e);
      const u = this._engine.plugins.interactors.get(this._container);
      if (u)
        for (const h of u)
          h.loadParticlesOptions && h.loadParticlesOptions(this, e);
    }
  }
}
function Le(n, ...e) {
  for (const t of e)
    n.load(t);
}
function Fe(n, e, ...t) {
  const i = new di(n, e);
  return Le(i, ...t), i;
}
class fi {
  constructor(e, t) {
    this._engine = e, this._container = t, this.autoPlay = !0, this.background = new Rt(), this.backgroundMask = new Tt(), this.fullScreen = new Et(), this.detectRetina = !0, this.duration = 0, this.fpsLimit = 120, this.interactivity = new Te(e, t), this.manualParticles = [], this.motion = new Bt(), this.particles = Fe(this._engine, this._container), this.pauseOnBlur = !0, this.pauseOnOutsideViewport = !0, this.responsive = [], this.smooth = !1, this.style = {}, this.themes = [], this.zLayers = 100;
  }
  get backgroundMode() {
    return this.fullScreen;
  }
  set backgroundMode(e) {
    this.fullScreen.load(e);
  }
  get fps_limit() {
    return this.fpsLimit;
  }
  set fps_limit(e) {
    this.fpsLimit = e;
  }
  get retina_detect() {
    return this.detectRetina;
  }
  set retina_detect(e) {
    this.detectRetina = e;
  }
  load(e) {
    var t, i, s, o, r;
    if (!e)
      return;
    e.preset !== void 0 && U(e.preset, (u) => this._importPreset(u)), e.autoPlay !== void 0 && (this.autoPlay = e.autoPlay);
    const a = (t = e.detectRetina) !== null && t !== void 0 ? t : e.retina_detect;
    a !== void 0 && (this.detectRetina = a), e.duration !== void 0 && (this.duration = e.duration);
    const l = (i = e.fpsLimit) !== null && i !== void 0 ? i : e.fps_limit;
    l !== void 0 && (this.fpsLimit = l), e.pauseOnBlur !== void 0 && (this.pauseOnBlur = e.pauseOnBlur), e.pauseOnOutsideViewport !== void 0 && (this.pauseOnOutsideViewport = e.pauseOnOutsideViewport), e.zLayers !== void 0 && (this.zLayers = e.zLayers), this.background.load(e.background);
    const c = (s = e.fullScreen) !== null && s !== void 0 ? s : e.backgroundMode;
    typeof c == "boolean" ? this.fullScreen.enable = c : this.fullScreen.load(c), this.backgroundMask.load(e.backgroundMask), this.interactivity.load(e.interactivity), e.manualParticles !== void 0 && (this.manualParticles = e.manualParticles.map((u) => {
      const h = new Vt();
      return h.load(u), h;
    })), this.motion.load(e.motion), this.particles.load(e.particles), this.style = M(this.style, e.style), this._engine.plugins.loadOptions(this, e), e.smooth !== void 0 && (this.smooth = e.smooth);
    const d = this._engine.plugins.interactors.get(this._container);
    if (d)
      for (const u of d)
        u.loadOptions && u.loadOptions(this, e);
    if (e.responsive !== void 0)
      for (const u of e.responsive) {
        const h = new Ut();
        h.load(u), this.responsive.push(h);
      }
    if (this.responsive.sort((u, h) => u.maxWidth - h.maxWidth), e.themes !== void 0)
      for (const u of e.themes) {
        const h = new Gt();
        h.load(u), this.themes.push(h);
      }
    this.defaultDarkTheme = (o = this._findDefaultTheme("dark")) === null || o === void 0 ? void 0 : o.name, this.defaultLightTheme = (r = this._findDefaultTheme("light")) === null || r === void 0 ? void 0 : r.name;
  }
  setResponsive(e, t, i) {
    this.load(i);
    const s = this.responsive.find((o) => o.mode === "screen" && screen ? o.maxWidth > screen.availWidth : o.maxWidth * t > e);
    return this.load(s == null ? void 0 : s.options), s == null ? void 0 : s.maxWidth;
  }
  setTheme(e) {
    if (e) {
      const t = this.themes.find((i) => i.name === e);
      t && this.load(t.options);
    } else {
      const t = ce("(prefers-color-scheme: dark)"), i = t && t.matches, s = this._findDefaultTheme(i ? "dark" : "light");
      s && this.load(s.options);
    }
  }
  _findDefaultTheme(e) {
    var t;
    return (t = this.themes.find((i) => i.default.value && i.default.mode === e)) !== null && t !== void 0 ? t : this.themes.find((i) => i.default.value && i.default.mode === "any");
  }
  _importPreset(e) {
    this.load(this._engine.plugins.getPreset(e));
  }
}
class pi {
  constructor(e, t) {
    this.container = t, this._engine = e, this._interactors = this._engine.plugins.getInteractors(this.container, !0), this._externalInteractors = [], this._particleInteractors = [];
  }
  async externalInteract(e) {
    for (const t of this._externalInteractors)
      t.isEnabled() && await t.interact(e);
  }
  handleClickMode(e) {
    for (const t of this._externalInteractors)
      t.handleClickMode && t.handleClickMode(e);
  }
  init() {
    this._externalInteractors = [], this._particleInteractors = [];
    for (const e of this._interactors) {
      switch (e.type) {
        case 0:
          this._externalInteractors.push(e);
          break;
        case 1:
          this._particleInteractors.push(e);
          break;
      }
      e.init();
    }
  }
  async particlesInteract(e, t) {
    for (const i of this._externalInteractors)
      i.clear(e, t);
    for (const i of this._particleInteractors)
      i.isEnabled(e) && await i.interact(e, t);
  }
  async reset(e) {
    for (const t of this._externalInteractors)
      t.isEnabled() && await t.reset(e);
    for (const t of this._particleInteractors)
      t.isEnabled(e) && await t.reset(e);
  }
}
const ke = (n) => {
  !(me(n.outMode, n.checkModes) || me(n.outMode, n.checkModes)) || (n.coord > n.maxCoord - n.radius * 2 ? n.setCb(-n.radius) : n.coord < n.radius * 2 && n.setCb(n.radius));
};
class vi {
  constructor(e, t, i, s, o, r) {
    var a, l, c, d, u, h, p, f, m, v, g, k, S;
    this.id = t, this.container = i, this.group = r, this._engine = e, this.fill = !0, this.pathRotation = !1, this.close = !0, this.lastPathTime = 0, this.destroyed = !1, this.unbreakable = !1, this.rotation = 0, this.misplaced = !1, this.retina = {
      maxDistance: {}
    }, this.outType = "normal", this.ignoresResizeRatio = !0;
    const P = i.retina.pixelRatio, w = i.actualOptions, x = Fe(this._engine, i, w.particles), T = x.shape.type, L = x.reduceDuplicates;
    if (this.shape = N(T, this.id, L), o != null && o.shape) {
      if (o.shape.type) {
        const Be = o.shape.type;
        this.shape = N(Be, this.id, L);
      }
      const R = new Ae();
      R.load(o.shape), this.shape && (this.shapeData = this._loadShapeData(R, L));
    } else
      this.shapeData = this._loadShapeData(x.shape, L);
    x.load(o), x.load((a = this.shapeData) === null || a === void 0 ? void 0 : a.particles), this.interactivity = new Te(e, i), this.interactivity.load(i.actualOptions.interactivity), this.interactivity.load(x.interactivity), this.fill = (c = (l = this.shapeData) === null || l === void 0 ? void 0 : l.fill) !== null && c !== void 0 ? c : this.fill, this.close = (u = (d = this.shapeData) === null || d === void 0 ? void 0 : d.close) !== null && u !== void 0 ? u : this.close, this.options = x;
    const A = this.options.move.path;
    this.pathDelay = Ye(A.delay) * 1e3, A.generator && (this.pathGenerator = this._engine.plugins.getPathGenerator(A.generator), this.pathGenerator && i.addPath(A.generator, this.pathGenerator) && this.pathGenerator.init(i));
    const We = y(this.options.zIndex.value);
    i.retina.initParticle(this);
    const q = this.options.size, de = q.value, J = q.animation;
    if (this.size = {
      enable: q.animation.enable,
      value: y(q.value) * i.retina.pixelRatio,
      max: le(de) * P,
      min: ae(de) * P,
      loops: 0,
      maxLoops: y(q.animation.count)
    }, J.enable) {
      switch (this.size.status = 0, this.size.decay = 1 - y(J.decay), J.startValue) {
        case "min":
          this.size.value = this.size.min, this.size.status = 0;
          break;
        case "random":
          this.size.value = W(this.size) * P, this.size.status = D() >= 0.5 ? 0 : 1;
          break;
        case "max":
        default:
          this.size.value = this.size.max, this.size.status = 1;
          break;
      }
      this.size.velocity = ((h = this.retina.sizeAnimationSpeed) !== null && h !== void 0 ? h : i.retina.sizeAnimationSpeed) / 100 * i.retina.reduceFactor, J.sync || (this.size.velocity *= D());
    }
    this.bubble = {
      inRange: !1
    }, this.slow = {
      inRange: !1,
      factor: 1
    }, this.position = this._calcPosition(i, s, Oe(We, 0, i.zLayers)), this.initialPosition = this.position.copy();
    const fe = i.canvas.size, te = this.options.move.center, pe = te.mode === "percent";
    switch (this.moveCenter = {
      x: ((p = te.x) !== null && p !== void 0 ? p : 50) * (pe ? fe.width / 100 : 1),
      y: ((f = te.y) !== null && f !== void 0 ? f : 50) * (pe ? fe.height / 100 : 1),
      radius: (m = this.options.move.center.radius) !== null && m !== void 0 ? m : 0,
      mode: (v = this.options.move.center.mode) !== null && v !== void 0 ? v : "percent"
    }, this.direction = Je(this.options.move.direction, this.position, this.moveCenter), this.options.move.direction) {
      case "inside":
        this.outType = "inside";
        break;
      case "outside":
        this.outType = "outside";
        break;
    }
    this.initialVelocity = this._calculateVelocity(), this.velocity = this.initialVelocity.copy(), this.moveDecay = 1 - y(this.options.move.decay), this.offset = V.origin;
    const Z = i.particles;
    Z.needsSort = Z.needsSort || Z.lastZIndex < this.position.z, Z.lastZIndex = this.position.z, this.zIndexFactor = this.position.z / i.zLayers, this.sides = 24;
    let z = i.drawers.get(this.shape);
    z || (z = this._engine.plugins.getShapeDrawer(this.shape), z && i.drawers.set(this.shape, z)), z != null && z.loadShape && (z == null || z.loadShape(this));
    const ve = z == null ? void 0 : z.getSidesCount;
    ve && (this.sides = ve(this)), this.spawning = !1, this.shadowColor = B(this.options.shadow.color);
    for (const R of i.particles.updaters)
      (g = R.init) === null || g === void 0 || g.call(R, this);
    for (const R of i.particles.movers)
      (k = R.init) === null || k === void 0 || k.call(R, this);
    z != null && z.particleInit && z.particleInit(i, this);
    for (const [, R] of i.plugins)
      (S = R.particleCreated) === null || S === void 0 || S.call(R, this);
  }
  destroy(e) {
    if (!(this.unbreakable || this.destroyed)) {
      this.destroyed = !0, this.bubble.inRange = !1, this.slow.inRange = !1;
      for (const [, t] of this.container.plugins)
        t.particleDestroyed && t.particleDestroyed(this, e);
      for (const t of this.container.particles.updaters)
        t.particleDestroyed && t.particleDestroyed(this, e);
    }
  }
  draw(e) {
    const t = this.container;
    for (const [, i] of t.plugins)
      t.canvas.drawParticlePlugin(i, this, e);
    t.canvas.drawParticle(this, e);
  }
  getFillColor() {
    var e, t;
    const i = (e = this.bubble.color) !== null && e !== void 0 ? e : _e(this.color);
    if (i && this.roll && (this.backColor || this.roll.alter)) {
      const s = this.roll.horizontal && this.roll.vertical ? 2 : 1, o = this.roll.horizontal ? Math.PI / 2 : 0;
      if (Math.floor((((t = this.roll.angle) !== null && t !== void 0 ? t : 0) + o) / (Math.PI / s)) % 2) {
        if (this.backColor)
          return this.backColor;
        if (this.roll.alter)
          return mt(i, this.roll.alter.type, this.roll.alter.value);
      }
    }
    return i;
  }
  getMass() {
    return this.getRadius() ** 2 * Math.PI / 2;
  }
  getPosition() {
    return {
      x: this.position.x + this.offset.x,
      y: this.position.y + this.offset.y,
      z: this.position.z
    };
  }
  getRadius() {
    var e;
    return (e = this.bubble.radius) !== null && e !== void 0 ? e : this.size.value;
  }
  getStrokeColor() {
    var e, t;
    return (t = (e = this.bubble.color) !== null && e !== void 0 ? e : _e(this.strokeColor)) !== null && t !== void 0 ? t : this.getFillColor();
  }
  isInsideCanvas() {
    const e = this.getRadius(), t = this.container.canvas.size;
    return this.position.x >= -e && this.position.y >= -e && this.position.y <= t.height + e && this.position.x <= t.width + e;
  }
  isVisible() {
    return !this.destroyed && !this.spawning && this.isInsideCanvas();
  }
  reset() {
    this.opacity && (this.opacity.loops = 0), this.size.loops = 0;
  }
  _calcPosition(e, t, i, s = 0) {
    var o, r, a, l;
    for (const [, v] of e.plugins) {
      const g = v.particlePosition !== void 0 ? v.particlePosition(t, this) : void 0;
      if (g !== void 0)
        return C.create(g.x, g.y, i);
    }
    const c = e.canvas.size, d = Ke({
      size: c,
      position: t
    }), u = C.create(d.x, d.y, i), h = this.getRadius(), p = this.options.move.outModes, f = (v) => {
      ke({
        outMode: v,
        checkModes: ["bounce", "bounce-horizontal"],
        coord: u.x,
        maxCoord: e.canvas.size.width,
        setCb: (g) => u.x += g,
        radius: h
      });
    }, m = (v) => {
      ke({
        outMode: v,
        checkModes: ["bounce", "bounce-vertical"],
        coord: u.y,
        maxCoord: e.canvas.size.height,
        setCb: (g) => u.y += g,
        radius: h
      });
    };
    return f((o = p.left) !== null && o !== void 0 ? o : p.default), f((r = p.right) !== null && r !== void 0 ? r : p.default), m((a = p.top) !== null && a !== void 0 ? a : p.default), m((l = p.bottom) !== null && l !== void 0 ? l : p.default), this._checkOverlap(u, s) ? this._calcPosition(e, void 0, i, s + 1) : u;
  }
  _calculateVelocity() {
    const t = Ze(this.direction).copy(), i = this.options.move;
    if (i.direction === "inside" || i.direction === "outside")
      return t;
    const s = Math.PI / 180 * y(i.angle.value), o = Math.PI / 180 * y(i.angle.offset), r = {
      left: o - s / 2,
      right: o + s / 2
    };
    return i.straight || (t.angle += W(_(r.left, r.right))), i.random && typeof i.speed == "number" && (t.length *= D()), t;
  }
  _checkOverlap(e, t = 0) {
    const i = this.options.collisions, s = this.getRadius();
    if (!i.enable)
      return !1;
    const o = i.overlap;
    if (o.enable)
      return !1;
    const r = o.retries;
    if (r >= 0 && t > r)
      throw new Error("Particle is overlapping and can't be placed");
    let a = !1;
    for (const l of this.container.particles.array)
      if (he(e, l.position) < s + l.getRadius()) {
        a = !0;
        break;
      }
    return a;
  }
  _loadShapeData(e, t) {
    const i = e.options[this.shape];
    if (i)
      return M({}, N(i, this.id, t));
  }
}
class mi {
  constructor(e, t) {
    this.position = e, this.particle = t;
  }
}
class He {
  constructor(e, t) {
    this.position = {
      x: e,
      y: t
    };
  }
}
class Ve extends He {
  constructor(e, t, i) {
    super(e, t), this.radius = i;
  }
  contains(e) {
    return he(e, this.position) <= this.radius;
  }
  intersects(e) {
    const t = e, i = e, s = this.position, o = e.position, r = { x: Math.abs(o.x - s.x), y: Math.abs(o.y - s.y) }, a = this.radius;
    if (i.radius !== void 0) {
      const l = a + i.radius, c = Math.sqrt(r.x ** 2 + r.y ** 2);
      return l > c;
    } else if (t.size !== void 0) {
      const l = t.size.width, c = t.size.height;
      return Math.pow(r.x - l, 2) + Math.pow(r.y - c, 2) <= a ** 2 || r.x <= a + l && r.y <= a + c || r.x <= l || r.y <= c;
    }
    return !1;
  }
}
class E extends He {
  constructor(e, t, i, s) {
    super(e, t), this.size = {
      height: s,
      width: i
    };
  }
  contains(e) {
    const t = this.size.width, i = this.size.height, s = this.position;
    return e.x >= s.x && e.x <= s.x + t && e.y >= s.y && e.y <= s.y + i;
  }
  intersects(e) {
    e instanceof Ve && e.intersects(this);
    const t = this.size.width, i = this.size.height, s = this.position, o = e.position, r = e instanceof E ? e.size : { width: 0, height: 0 }, a = r.width, l = r.height;
    return o.x < s.x + t && o.x + a > s.x && o.y < s.y + i && o.y + l > s.y;
  }
}
class F {
  constructor(e, t) {
    this.rectangle = e, this.capacity = t, this.points = [], this.divided = !1;
  }
  insert(e) {
    var t, i, s, o, r;
    return this.rectangle.contains(e.position) ? this.points.length < this.capacity ? (this.points.push(e), !0) : (this.divided || this.subdivide(), (r = ((t = this.northEast) === null || t === void 0 ? void 0 : t.insert(e)) || ((i = this.northWest) === null || i === void 0 ? void 0 : i.insert(e)) || ((s = this.southEast) === null || s === void 0 ? void 0 : s.insert(e)) || ((o = this.southWest) === null || o === void 0 ? void 0 : o.insert(e))) !== null && r !== void 0 ? r : !1) : !1;
  }
  query(e, t, i) {
    var s, o, r, a;
    const l = i != null ? i : [];
    if (!e.intersects(this.rectangle))
      return [];
    for (const c of this.points)
      !e.contains(c.position) && he(e.position, c.position) > c.particle.getRadius() && (!t || t(c.particle)) || l.push(c.particle);
    return this.divided && ((s = this.northEast) === null || s === void 0 || s.query(e, t, l), (o = this.northWest) === null || o === void 0 || o.query(e, t, l), (r = this.southEast) === null || r === void 0 || r.query(e, t, l), (a = this.southWest) === null || a === void 0 || a.query(e, t, l)), l;
  }
  queryCircle(e, t, i) {
    return this.query(new Ve(e.x, e.y, t), i);
  }
  queryRectangle(e, t, i) {
    return this.query(new E(e.x, e.y, t.width, t.height), i);
  }
  subdivide() {
    const e = this.rectangle.position.x, t = this.rectangle.position.y, i = this.rectangle.size.width, s = this.rectangle.size.height, o = this.capacity;
    this.northEast = new F(new E(e, t, i / 2, s / 2), o), this.northWest = new F(new E(e + i / 2, t, i / 2, s / 2), o), this.southEast = new F(new E(e, t + s / 2, i / 2, s / 2), o), this.southWest = new F(new E(e + i / 2, t + s / 2, i / 2, s / 2), o), this.divided = !0;
  }
}
class gi {
  constructor(e, t) {
    this.container = t, this._engine = e, this.nextId = 0, this.array = [], this.zArray = [], this.limit = 0, this.needsSort = !1, this.lastZIndex = 0, this.interactionManager = new pi(this._engine, t);
    const i = this.container.canvas.size;
    this.quadTree = new F(new E(-i.width / 4, -i.height / 4, i.width * 3 / 2, i.height * 3 / 2), 4), this.movers = this._engine.plugins.getMovers(t, !0), this.updaters = this._engine.plugins.getUpdaters(t, !0);
  }
  get count() {
    return this.array.length;
  }
  addManualParticles() {
    const e = this.container, t = e.actualOptions;
    for (const i of t.manualParticles)
      this.addParticle(Qe({
        size: e.canvas.size,
        position: i.position
      }), i.options);
  }
  addParticle(e, t, i, s) {
    const o = this.container, r = o.actualOptions, a = r.particles.number.limit;
    if (a > 0) {
      const l = this.count + 1 - a;
      l > 0 && this.removeQuantity(l);
    }
    return this._pushParticle(e, t, i, s);
  }
  clear() {
    this.array = [], this.zArray = [];
  }
  destroy() {
    this.array = [], this.zArray = [], this.movers = [], this.updaters = [];
  }
  async draw(e) {
    const t = this.container, i = this.container.canvas.size;
    this.quadTree = new F(new E(-i.width / 4, -i.height / 4, i.width * 3 / 2, i.height * 3 / 2), 4), t.canvas.clear(), await this.update(e), this.needsSort && (this.zArray.sort((s, o) => o.position.z - s.position.z || s.id - o.id), this.lastZIndex = this.zArray[this.zArray.length - 1].position.z, this.needsSort = !1);
    for (const [, s] of t.plugins)
      t.canvas.drawPlugin(s, e);
    for (const s of this.zArray)
      s.draw(e);
  }
  handleClickMode(e) {
    this.interactionManager.handleClickMode(e);
  }
  init() {
    var e;
    const t = this.container, i = t.actualOptions;
    this.lastZIndex = 0, this.needsSort = !1;
    let s = !1;
    this.updaters = this._engine.plugins.getUpdaters(t, !0), this.interactionManager.init();
    for (const [, o] of t.plugins)
      if (o.particlesInitialization !== void 0 && (s = o.particlesInitialization()), s)
        break;
    this.interactionManager.init();
    for (const [, o] of t.pathGenerators)
      o.init(t);
    if (this.addManualParticles(), !s) {
      for (const o in i.particles.groups) {
        const r = i.particles.groups[o];
        for (let a = this.count, l = 0; l < ((e = r.number) === null || e === void 0 ? void 0 : e.value) && a < i.particles.number.value; a++, l++)
          this.addParticle(void 0, r, o);
      }
      for (let o = this.count; o < i.particles.number.value; o++)
        this.addParticle();
    }
  }
  push(e, t, i, s) {
    this.pushing = !0;
    for (let o = 0; o < e; o++)
      this.addParticle(t == null ? void 0 : t.position, i, s);
    this.pushing = !1;
  }
  async redraw() {
    this.clear(), this.init(), await this.draw({ value: 0, factor: 0 });
  }
  remove(e, t, i) {
    this.removeAt(this.array.indexOf(e), void 0, t, i);
  }
  removeAt(e, t = 1, i, s) {
    if (e < 0 || e > this.count)
      return;
    let o = 0;
    for (let r = e; o < t && r < this.count; r++) {
      const a = this.array[r];
      if (!a || a.group !== i)
        continue;
      a.destroy(s), this.array.splice(r--, 1);
      const l = this.zArray.indexOf(a);
      this.zArray.splice(l, 1), o++, this._engine.dispatchEvent("particleRemoved", {
        container: this.container,
        data: {
          particle: a
        }
      });
    }
  }
  removeQuantity(e, t) {
    this.removeAt(0, e, t);
  }
  setDensity() {
    const e = this.container.actualOptions;
    for (const t in e.particles.groups)
      this._applyDensity(e.particles.groups[t], 0, t);
    this._applyDensity(e.particles, e.manualParticles.length);
  }
  async update(e) {
    var t, i;
    const s = this.container, o = [];
    for (const [, r] of s.pathGenerators)
      r.update();
    for (const [, r] of s.plugins)
      (t = r.update) === null || t === void 0 || t.call(r, e);
    for (const r of this.array) {
      const a = s.canvas.resizeFactor;
      a && !r.ignoresResizeRatio && (r.position.x *= a.width, r.position.y *= a.height), r.ignoresResizeRatio = !1, await this.interactionManager.reset(r);
      for (const [, l] of this.container.plugins) {
        if (r.destroyed)
          break;
        (i = l.particleUpdate) === null || i === void 0 || i.call(l, r, e);
      }
      for (const l of this.movers)
        l.isEnabled(r) && l.move(r, e);
      if (r.destroyed) {
        o.push(r);
        continue;
      }
      this.quadTree.insert(new mi(r.getPosition(), r));
    }
    for (const r of o)
      this.remove(r);
    await this.interactionManager.externalInteract(e);
    for (const r of s.particles.array) {
      for (const a of this.updaters)
        a.update(r, e);
      !r.destroyed && !r.spawning && await this.interactionManager.particlesInteract(r, e);
    }
    delete s.canvas.resizeFactor;
  }
  _applyDensity(e, t, i) {
    var s;
    if (!(!((s = e.number.density) === null || s === void 0) && s.enable))
      return;
    const o = e.number, r = this._initDensityFactor(o.density), a = o.value, l = o.limit > 0 ? o.limit : a, c = Math.min(a, l) * r + t, d = Math.min(this.count, this.array.filter((u) => u.group === i).length);
    this.limit = o.limit * r, d < c ? this.push(Math.abs(c - d), void 0, e, i) : d > c && this.removeQuantity(d - c, i);
  }
  _initDensityFactor(e) {
    const t = this.container;
    if (!t.canvas.element || !e.enable)
      return 1;
    const i = t.canvas.element, s = t.retina.pixelRatio;
    return i.width * i.height / (e.factor * s ** 2 * e.area);
  }
  _pushParticle(e, t, i, s) {
    try {
      const o = new vi(this._engine, this.nextId, this.container, e, t, i);
      let r = !0;
      return s && (r = s(o)), r ? (this.array.push(o), this.zArray.push(o), this.nextId++, this._engine.dispatchEvent("particleAdded", {
        container: this.container,
        data: {
          particle: o
        }
      }), o) : void 0;
    } catch (o) {
      console.warn(`error adding particle: ${o}`);
      return;
    }
  }
}
class yi {
  constructor(e) {
    this.container = e;
  }
  init() {
    const e = this.container, t = e.actualOptions;
    this.pixelRatio = !t.detectRetina || K() ? 1 : window.devicePixelRatio;
    const i = this.container.actualOptions.motion;
    if (i && (i.disable || i.reduce.value)) {
      const r = ce("(prefers-reduced-motion: reduce)");
      if (r) {
        this._handleMotionChange(r);
        const a = () => {
          this._handleMotionChange(r), e.refresh().catch(() => {
          });
        };
        r.addEventListener !== void 0 ? r.addEventListener("change", a) : r.addListener !== void 0 && r.addListener(a);
      } else
        this.reduceFactor = 1;
    } else
      this.reduceFactor = 1;
    const s = this.pixelRatio;
    if (e.canvas.element) {
      const r = e.canvas.element;
      e.canvas.size.width = r.offsetWidth * s, e.canvas.size.height = r.offsetHeight * s;
    }
    const o = t.particles;
    this.attractDistance = y(o.move.attract.distance) * s, this.sizeAnimationSpeed = y(o.size.animation.speed) * s, this.maxSpeed = y(o.move.gravity.maxSpeed) * s;
  }
  initParticle(e) {
    const t = e.options, i = this.pixelRatio, s = t.move.distance, o = e.retina;
    o.attractDistance = y(t.move.attract.distance) * i, o.moveDrift = y(t.move.drift) * i, o.moveSpeed = y(t.move.speed) * i, o.sizeAnimationSpeed = y(t.size.animation.speed) * i;
    const r = o.maxDistance;
    r.horizontal = s.horizontal !== void 0 ? s.horizontal * i : void 0, r.vertical = s.vertical !== void 0 ? s.vertical * i : void 0, o.maxSpeed = y(t.move.gravity.maxSpeed) * i;
  }
  _handleMotionChange(e) {
    const t = this.container.actualOptions;
    if (e.matches) {
      const i = t.motion;
      this.reduceFactor = i.disable ? 0 : i.reduce.value ? 1 / i.reduce.factor : 1;
    } else
      this.reduceFactor = 1;
  }
}
function b(n) {
  return n && !n.destroyed;
}
function G(n, e, ...t) {
  const i = new fi(n, e);
  return Le(i, ...t), i;
}
const _i = "default", Ce = {
  generate: (n) => {
    const e = n.velocity.copy();
    return e.angle += e.length * Math.PI / 180, e;
  },
  init: () => {
  },
  update: () => {
  }
};
class bi {
  constructor(e, t, i) {
    this.id = t, this._engine = e, this.fpsLimit = 120, this.smooth = !1, this.duration = 0, this.lifeTime = 0, this._firstStart = !0, this.started = !1, this.destroyed = !1, this._paused = !0, this.lastFrameTime = 0, this.zLayers = 100, this.pageHidden = !1, this._sourceOptions = i, this._initialSourceOptions = i, this.retina = new yi(this), this.canvas = new kt(this), this.particles = new gi(this._engine, this), this.frameManager = new St(this), this.pathGenerators = /* @__PURE__ */ new Map(), this.interactivity = {
      mouse: {
        clicking: !1,
        inside: !1
      }
    }, this.plugins = /* @__PURE__ */ new Map(), this.drawers = /* @__PURE__ */ new Map(), this._options = G(this._engine, this), this.actualOptions = G(this._engine, this), this._eventListeners = new Ct(this), typeof IntersectionObserver < "u" && IntersectionObserver && (this._intersectionObserver = new IntersectionObserver((s) => this._intersectionManager(s))), this._engine.dispatchEvent("containerBuilt", { container: this });
  }
  get options() {
    return this._options;
  }
  get sourceOptions() {
    return this._sourceOptions;
  }
  addClickHandler(e) {
    if (!b(this))
      return;
    const t = this.interactivity.element;
    if (!t)
      return;
    const i = (u, h, p) => {
      if (!b(this))
        return;
      const f = this.retina.pixelRatio, m = {
        x: h.x * f,
        y: h.y * f
      }, v = this.particles.quadTree.queryCircle(m, p * f);
      e(u, v);
    }, s = (u) => {
      if (!b(this))
        return;
      const h = u, p = {
        x: h.offsetX || h.clientX,
        y: h.offsetY || h.clientY
      };
      i(u, p, 1);
    }, o = () => {
      !b(this) || (c = !0, d = !1);
    }, r = () => {
      !b(this) || (d = !0);
    }, a = (u) => {
      var h, p, f;
      if (!!b(this)) {
        if (c && !d) {
          const m = u;
          let v = m.touches[m.touches.length - 1];
          if (!v && (v = m.changedTouches[m.changedTouches.length - 1], !v))
            return;
          const g = (h = this.canvas.element) === null || h === void 0 ? void 0 : h.getBoundingClientRect(), k = {
            x: v.clientX - ((p = g == null ? void 0 : g.left) !== null && p !== void 0 ? p : 0),
            y: v.clientY - ((f = g == null ? void 0 : g.top) !== null && f !== void 0 ? f : 0)
          };
          i(u, k, Math.max(v.radiusX, v.radiusY));
        }
        c = !1, d = !1;
      }
    }, l = () => {
      !b(this) || (c = !1, d = !1);
    };
    let c = !1, d = !1;
    t.addEventListener("click", s), t.addEventListener("touchstart", o), t.addEventListener("touchmove", r), t.addEventListener("touchend", a), t.addEventListener("touchcancel", l);
  }
  addPath(e, t, i = !1) {
    return !b(this) || !i && this.pathGenerators.has(e) ? !1 : (this.pathGenerators.set(e, t != null ? t : Ce), !0);
  }
  destroy() {
    if (!b(this))
      return;
    this.stop(), this.particles.destroy(), this.canvas.destroy();
    for (const [, i] of this.drawers)
      i.destroy && i.destroy(this);
    for (const i of this.drawers.keys())
      this.drawers.delete(i);
    this._engine.plugins.destroy(this), this.destroyed = !0;
    const e = this._engine.dom(), t = e.findIndex((i) => i === this);
    t >= 0 && e.splice(t, 1), this._engine.dispatchEvent("containerDestroyed", { container: this });
  }
  draw(e) {
    if (!b(this))
      return;
    let t = e;
    this._drawAnimationFrame = tt()(async (i) => {
      t && (this.lastFrameTime = void 0, t = !1), await this.frameManager.nextFrame(i);
    });
  }
  exportConfiguration() {
    return JSON.stringify(this.actualOptions, (e, t) => {
      if (!(e === "_engine" || e === "_container"))
        return t;
    }, 2);
  }
  exportImage(e, t, i) {
    var s;
    return (s = this.canvas.element) === null || s === void 0 ? void 0 : s.toBlob(e, t != null ? t : "image/png", i);
  }
  exportImg(e) {
    this.exportImage(e);
  }
  getAnimationStatus() {
    return !this._paused && !this.pageHidden && b(this);
  }
  handleClickMode(e) {
    if (!!b(this)) {
      this.particles.handleClickMode(e);
      for (const [, t] of this.plugins)
        t.handleClickMode && t.handleClickMode(e);
    }
  }
  async init() {
    if (!b(this))
      return;
    const e = this._engine.plugins.getSupportedShapes();
    for (const i of e) {
      const s = this._engine.plugins.getShapeDrawer(i);
      s && this.drawers.set(i, s);
    }
    this._options = G(this._engine, this, this._initialSourceOptions, this.sourceOptions), this.actualOptions = G(this._engine, this, this._options), this.retina.init(), this.canvas.init(), this.updateActualOptions(), this.canvas.initBackground(), this.canvas.resize(), this.zLayers = this.actualOptions.zLayers, this.duration = y(this.actualOptions.duration) * 1e3, this.lifeTime = 0, this.fpsLimit = this.actualOptions.fpsLimit > 0 ? this.actualOptions.fpsLimit : 120, this.smooth = this.actualOptions.smooth;
    const t = this._engine.plugins.getAvailablePlugins(this);
    for (const [i, s] of t)
      this.plugins.set(i, s);
    for (const [, i] of this.drawers)
      i.init && await i.init(this);
    for (const [, i] of this.plugins)
      i.init ? i.init(this.actualOptions) : i.initAsync !== void 0 && await i.initAsync(this.actualOptions);
    this._engine.dispatchEvent("containerInit", { container: this }), this.particles.init(), this.particles.setDensity();
    for (const [, i] of this.plugins)
      i.particlesSetup !== void 0 && i.particlesSetup();
    this._engine.dispatchEvent("particlesSetup", { container: this });
  }
  async loadTheme(e) {
    !b(this) || (this._currentTheme = e, await this.refresh());
  }
  pause() {
    if (!!b(this) && (this._drawAnimationFrame !== void 0 && (it()(this._drawAnimationFrame), delete this._drawAnimationFrame), !this._paused)) {
      for (const [, e] of this.plugins)
        e.pause && e.pause();
      this.pageHidden || (this._paused = !0), this._engine.dispatchEvent("containerPaused", { container: this });
    }
  }
  play(e) {
    if (!b(this))
      return;
    const t = this._paused || e;
    if (this._firstStart && !this.actualOptions.autoPlay) {
      this._firstStart = !1;
      return;
    }
    if (this._paused && (this._paused = !1), t)
      for (const [, i] of this.plugins)
        i.play && i.play();
    this._engine.dispatchEvent("containerPlay", { container: this }), this.draw(t || !1);
  }
  async refresh() {
    if (!!b(this))
      return this.stop(), this.start();
  }
  async reset() {
    if (!!b(this))
      return this._options = G(this._engine, this), this.refresh();
  }
  setNoise(e, t, i) {
    !b(this) || this.setPath(e, t, i);
  }
  setPath(e, t, i) {
    if (!e || !b(this))
      return;
    const s = Object.assign({}, Ce);
    if (typeof e == "function")
      s.generate = e, t && (s.init = t), i && (s.update = i);
    else {
      const o = s;
      s.generate = e.generate || o.generate, s.init = e.init || o.init, s.update = e.update || o.update;
    }
    this.addPath(_i, s, !0);
  }
  async start() {
    if (!(!b(this) || this.started)) {
      await this.init(), this.started = !0, this._eventListeners.addListeners(), this.interactivity.element instanceof HTMLElement && this._intersectionObserver && this._intersectionObserver.observe(this.interactivity.element);
      for (const [, e] of this.plugins)
        e.startAsync !== void 0 ? await e.startAsync() : e.start !== void 0 && e.start();
      this._engine.dispatchEvent("containerStarted", { container: this }), this.play();
    }
  }
  stop() {
    var e;
    if (!(!b(this) || !this.started)) {
      this._firstStart = !0, this.started = !1, this._eventListeners.removeListeners(), this.pause(), this.particles.clear(), this.canvas.clear(), this.interactivity.element instanceof HTMLElement && this._intersectionObserver && this._intersectionObserver.unobserve(this.interactivity.element);
      for (const [, t] of this.plugins)
        (e = t.stop) === null || e === void 0 || e.call(t);
      for (const t of this.plugins.keys())
        this.plugins.delete(t);
      this._sourceOptions = this._options, this._engine.dispatchEvent("containerStopped", { container: this });
    }
  }
  updateActualOptions() {
    this.actualOptions.responsive = [];
    const e = this.actualOptions.setResponsive(this.canvas.size.width, this.retina.pixelRatio, this._options);
    return this.actualOptions.setTheme(this._currentTheme), this.responsiveMaxWidth === e ? !1 : (this.responsiveMaxWidth = e, !0);
  }
  _intersectionManager(e) {
    if (!(!b(this) || !this.actualOptions.pauseOnOutsideViewport))
      for (const t of e)
        t.target === this.interactivity.element && (t.isIntersecting ? this.play : this.pause)();
  }
}
function wi(n) {
  console.error(`tsParticles - Error ${n} while retrieving config file`);
}
async function xi(n, e) {
  const t = N(n, e);
  if (!t)
    return;
  const i = await fetch(t);
  if (i.ok)
    return i.json();
  wi(i.status);
}
class zi {
  constructor(e) {
    this._engine = e;
  }
  load(e, t, i) {
    const s = { index: i, remote: !1 };
    return typeof e == "string" ? s.tagId = e : s.options = e, typeof t == "number" ? s.index = t : s.options = t != null ? t : s.options, this.loadOptions(s);
  }
  async loadJSON(e, t, i) {
    let s, o;
    return typeof t == "number" || t === void 0 ? s = e : (o = e, s = t), this.loadRemoteOptions({ tagId: o, url: s, index: i, remote: !0 });
  }
  async loadOptions(e) {
    var t, i, s;
    const o = (t = e.tagId) !== null && t !== void 0 ? t : `tsparticles${Math.floor(D() * 1e4)}`, { index: r, url: a, remote: l } = e, c = l ? await xi(a, r) : e.options;
    let d = (i = e.element) !== null && i !== void 0 ? i : document.getElementById(o);
    d || (d = document.createElement("div"), d.id = o, (s = document.querySelector("body")) === null || s === void 0 || s.append(d));
    const u = N(c, r), h = this._engine.dom(), p = h.findIndex((v) => v.id === o);
    if (p >= 0) {
      const v = this._engine.domItem(p);
      v && !v.destroyed && (v.destroy(), h.splice(p, 1));
    }
    let f;
    if (d.tagName.toLowerCase() === "canvas")
      f = d, f.dataset[X] = "false";
    else {
      const v = d.getElementsByTagName("canvas");
      v.length ? (f = v[0], f.dataset[X] = "false") : (f = document.createElement("canvas"), f.dataset[X] = "true", d.appendChild(f));
    }
    f.style.width || (f.style.width = "100%"), f.style.height || (f.style.height = "100%");
    const m = new bi(this._engine, o, u);
    return p >= 0 ? h.splice(p, 0, m) : h.push(m), m.canvas.loadCanvas(f), await m.start(), m;
  }
  async loadRemoteOptions(e) {
    return this.loadOptions(e);
  }
  async set(e, t, i, s) {
    const o = { index: s, remote: !1 };
    return typeof e == "string" ? o.tagId = e : o.element = e, t instanceof HTMLElement ? o.element = t : o.options = t, typeof i == "number" ? o.index = i : o.options = i != null ? i : o.options, this.loadOptions(o);
  }
  async setJSON(e, t, i, s) {
    let o, r, a, l;
    return e instanceof HTMLElement ? (l = e, o = t, a = i) : (r = e, l = t, o = i, a = s), this.loadRemoteOptions({ tagId: r, url: o, index: a, element: l, remote: !0 });
  }
}
function oe(n, e, t, i = !1) {
  let s = e.get(n);
  return (!s || i) && (s = [...t.values()].map((o) => o(n)), e.set(n, s)), s;
}
class Mi {
  constructor(e) {
    this._engine = e, this.plugins = [], this.interactorsInitializers = /* @__PURE__ */ new Map(), this.moversInitializers = /* @__PURE__ */ new Map(), this.updatersInitializers = /* @__PURE__ */ new Map(), this.interactors = /* @__PURE__ */ new Map(), this.movers = /* @__PURE__ */ new Map(), this.updaters = /* @__PURE__ */ new Map(), this.presets = /* @__PURE__ */ new Map(), this.drawers = /* @__PURE__ */ new Map(), this.pathGenerators = /* @__PURE__ */ new Map();
  }
  addInteractor(e, t) {
    this.interactorsInitializers.set(e, t);
  }
  addParticleMover(e, t) {
    this.moversInitializers.set(e, t);
  }
  addParticleUpdater(e, t) {
    this.updatersInitializers.set(e, t);
  }
  addPathGenerator(e, t) {
    this.getPathGenerator(e) || this.pathGenerators.set(e, t);
  }
  addPlugin(e) {
    this.getPlugin(e.id) || this.plugins.push(e);
  }
  addPreset(e, t, i = !1) {
    (i || !this.getPreset(e)) && this.presets.set(e, t);
  }
  addShapeDrawer(e, t) {
    this.getShapeDrawer(e) || this.drawers.set(e, t);
  }
  destroy(e) {
    this.updaters.delete(e), this.movers.delete(e), this.interactors.delete(e);
  }
  getAvailablePlugins(e) {
    const t = /* @__PURE__ */ new Map();
    for (const i of this.plugins)
      !i.needsPlugin(e.actualOptions) || t.set(i.id, i.getPlugin(e));
    return t;
  }
  getInteractors(e, t = !1) {
    return oe(e, this.interactors, this.interactorsInitializers, t);
  }
  getMovers(e, t = !1) {
    return oe(e, this.movers, this.moversInitializers, t);
  }
  getPathGenerator(e) {
    return this.pathGenerators.get(e);
  }
  getPlugin(e) {
    return this.plugins.find((t) => t.id === e);
  }
  getPreset(e) {
    return this.presets.get(e);
  }
  getShapeDrawer(e) {
    return this.drawers.get(e);
  }
  getSupportedShapes() {
    return this.drawers.keys();
  }
  getUpdaters(e, t = !1) {
    return oe(e, this.updaters, this.updatersInitializers, t);
  }
  loadOptions(e, t) {
    for (const i of this.plugins)
      i.loadOptions(e, t);
  }
  loadParticlesOptions(e, t, ...i) {
    const s = this.updaters.get(e);
    if (!!s)
      for (const o of s)
        o.loadOptions && o.loadOptions(t, ...i);
  }
}
class Pi {
  constructor() {
    this._domArray = [], this._eventDispatcher = new Ne(), this._initialized = !1, this._loader = new zi(this), this.plugins = new Mi(this);
  }
  addEventListener(e, t) {
    this._eventDispatcher.addEventListener(e, t);
  }
  async addInteractor(e, t) {
    this.plugins.addInteractor(e, t), await this.refresh();
  }
  async addMover(e, t) {
    this.plugins.addParticleMover(e, t), await this.refresh();
  }
  async addParticleUpdater(e, t) {
    this.plugins.addParticleUpdater(e, t), await this.refresh();
  }
  async addPathGenerator(e, t) {
    this.plugins.addPathGenerator(e, t), await this.refresh();
  }
  async addPlugin(e) {
    this.plugins.addPlugin(e), await this.refresh();
  }
  async addPreset(e, t, i = !1) {
    this.plugins.addPreset(e, t, i), await this.refresh();
  }
  async addShape(e, t, i, s, o) {
    let r;
    typeof t == "function" ? r = {
      afterEffect: s,
      destroy: o,
      draw: t,
      init: i
    } : r = t, this.plugins.addShapeDrawer(e, r), await this.refresh();
  }
  dispatchEvent(e, t) {
    this._eventDispatcher.dispatchEvent(e, t);
  }
  dom() {
    return this._domArray;
  }
  domItem(e) {
    const t = this.dom(), i = t[e];
    if (i && !i.destroyed)
      return i;
    t.splice(e, 1);
  }
  init() {
    this._initialized || (this._initialized = !0);
  }
  async load(e, t) {
    return this._loader.load(e, t);
  }
  async loadFromArray(e, t, i) {
    return this._loader.load(e, t, i);
  }
  async loadJSON(e, t, i) {
    return this._loader.loadJSON(e, t, i);
  }
  async refresh() {
    for (const e of this.dom())
      await e.refresh();
  }
  removeEventListener(e, t) {
    this._eventDispatcher.removeEventListener(e, t);
  }
  async set(e, t, i) {
    return this._loader.set(e, t, i);
  }
  async setJSON(e, t, i, s) {
    return this._loader.setJSON(e, t, i, s);
  }
  setOnClickHandler(e) {
    const t = this.dom();
    if (!t.length)
      throw new Error("Can only set click handlers after calling tsParticles.load() or tsParticles.loadJSON()");
    for (const i of t)
      i.addClickHandler(e);
  }
}
class ki {
  constructor() {
    this.key = "hsl", this.stringPrefix = "hsl";
  }
  handleColor(e) {
    var t;
    const i = e.value, s = (t = i.hsl) !== null && t !== void 0 ? t : e.value;
    if (s.h !== void 0 && s.l !== void 0)
      return re(s);
  }
  handleRangeColor(e) {
    var t;
    const i = e.value, s = (t = i.hsl) !== null && t !== void 0 ? t : e.value;
    if (s.h !== void 0 && s.l !== void 0)
      return re({
        h: y(s.h),
        l: y(s.l),
        s: y(s.s)
      });
  }
  parseString(e) {
    if (!e.startsWith("hsl"))
      return;
    const t = /hsla?\(\s*(\d+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([\d.%]+)\s*)?\)/i, i = t.exec(e);
    return i ? lt({
      a: i.length > 4 ? Se(i[5]) : 1,
      h: parseInt(i[1], 10),
      l: parseInt(i[3], 10),
      s: parseInt(i[2], 10)
    }) : void 0;
  }
}
class Ci {
  constructor() {
    this.key = "rgb", this.stringPrefix = "rgb";
  }
  handleColor(e) {
    var t;
    const i = e.value, s = (t = i.rgb) !== null && t !== void 0 ? t : e.value;
    if (s.r !== void 0)
      return s;
  }
  handleRangeColor(e) {
    var t;
    const i = e.value, s = (t = i.rgb) !== null && t !== void 0 ? t : e.value;
    if (s.r !== void 0)
      return {
        r: y(s.r),
        g: y(s.g),
        b: y(s.b)
      };
  }
  parseString(e) {
    if (!e.startsWith(this.stringPrefix))
      return;
    const t = /rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([\d.%]+)\s*)?\)/i, i = t.exec(e);
    return i ? {
      a: i.length > 4 ? Se(i[5]) : 1,
      b: parseInt(i[3], 10),
      g: parseInt(i[2], 10),
      r: parseInt(i[1], 10)
    } : void 0;
  }
}
const Oi = new Ci(), Si = new ki();
Re(Oi);
Re(Si);
const $ = new Pi();
$.init();
let H;
const Ri = Ue({
  name: "Particles",
  props: {
    id: {
      type: String,
      required: !0
    },
    options: {
      type: Object
    },
    url: {
      type: String
    },
    particlesLoaded: {
      type: Function
    },
    particlesInit: {
      type: Function
    }
  },
  mounted() {
    qe(async () => {
      var t;
      if (!this.id)
        throw new Error("Prop 'id' is required!");
      $.init(), this.particlesInit && await this.particlesInit($);
      const n = (i) => {
        H = i, this.particlesLoaded && H && this.particlesLoaded(H);
      }, e = await (this.url ? $.loadJSON(this.id, this.url) : $.load(this.id, (t = this.options) != null ? t : {}));
      n(e);
    });
  },
  unmounted() {
    H && (H.destroy(), H = void 0);
  }
}), Ii = (n, e) => {
  const t = n.__vccOpts || n;
  for (const [i, s] of e)
    t[i] = s;
  return t;
}, Ti = ["id"];
function Ei(n, e, t, i, s, o) {
  return Ge(), $e("div", { id: n.id }, null, 8, Ti);
}
const Di = /* @__PURE__ */ Ii(Ri, [["render", Ei]]), Li = (n, e) => {
  n.component("Particles", Di);
};
export {
  Di as ParticlesComponent,
  Li as default
};
