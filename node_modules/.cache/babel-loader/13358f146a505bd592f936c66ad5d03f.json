{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\nimport \"core-js/modules/es.error.cause.js\";\n\n/*!\n  * vue-router v4.0.13\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, onUnmounted, onDeactivated, onActivated, computed, unref, watchEffect, defineComponent, reactive, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\n\nconst PolySymbol = name => // vr = vue router\nhasSymbol ? Symbol(process.env.NODE_ENV !== 'production' ? '[vue-router]: ' + name : name) : (process.env.NODE_ENV !== 'production' ? '[vue-router]: ' : '_vr_') + name; // rvlm = Router View Location Matched\n\n/**\n * RouteRecord being rendered by the closest ancestor Router View. Used for\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\n * Location Matched\n *\n * @internal\n */\n\n\nconst matchedRouteKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router view location matched' : 'rvlm');\n/**\n * Allows overriding the router view depth to control which component in\n * `matched` is rendered. rvd stands for Router View Depth\n *\n * @internal\n */\n\nconst viewDepthKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router view depth' : 'rvd');\n/**\n * Allows overriding the router instance returned by `useRouter` in tests. r\n * stands for router\n *\n * @internal\n */\n\nconst routerKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router' : 'r');\n/**\n * Allows overriding the current route returned by `useRoute` in tests. rl\n * stands for route location\n *\n * @internal\n */\n\nconst routeLocationKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'route location' : 'rl');\n/**\n * Allows overriding the current route used by router-view. Internally this is\n * used when the `route` prop is passed.\n *\n * @internal\n */\n\nconst routerViewLocationKey = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'router view location' : 'rvl');\nconst isBrowser = typeof window !== 'undefined';\n\nfunction isESModule(obj) {\n  return obj.__esModule || hasSymbol && obj[Symbol.toStringTag] === 'Module';\n}\n\nconst assign = Object.assign;\n\nfunction applyToParams(fn, params) {\n  const newParams = {};\n\n  for (const key in params) {\n    const value = params[key];\n    newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\n  }\n\n  return newParams;\n}\n\nconst noop = () => {};\n\nfunction warn(msg) {\n  // avoid using ...args as it breaks in older Edge builds\n  const args = Array.from(arguments).slice(1);\n  console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\n\nconst removeTrailingSlash = path => path.replace(TRAILING_SLASH_RE, '');\n/**\n * Transforms an URI into a normalized history location\n *\n * @param parseQuery\n * @param location - URI to normalize\n * @param currentLocation - current absolute location. Allows resolving relative\n * paths. Must start with `/`. Defaults to `/`\n * @returns a normalized history location\n */\n\n\nfunction parseURL(parseQuery, location, currentLocation = '/') {\n  let path,\n      query = {},\n      searchString = '',\n      hash = ''; // Could use URL and URLSearchParams but IE 11 doesn't support it\n\n  const searchPos = location.indexOf('?');\n  const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\n\n  if (searchPos > -1) {\n    path = location.slice(0, searchPos);\n    searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\n    query = parseQuery(searchString);\n  }\n\n  if (hashPos > -1) {\n    path = path || location.slice(0, hashPos); // keep the # character\n\n    hash = location.slice(hashPos, location.length);\n  } // no search and no query\n\n\n  path = resolveRelativePath(path != null ? path : location, currentLocation); // empty path means a relative query or hash `?foo=f`, `#thing`\n\n  return {\n    fullPath: path + (searchString && '?') + searchString + hash,\n    path,\n    query,\n    hash\n  };\n}\n/**\n * Stringifies a URL object\n *\n * @param stringifyQuery\n * @param location\n */\n\n\nfunction stringifyURL(stringifyQuery, location) {\n  const query = location.query ? stringifyQuery(location.query) : '';\n  return location.path + (query && '?') + query + (location.hash || '');\n}\n/**\n * Strips off the base from the beginning of a location.pathname in a non\n * case-sensitive way.\n *\n * @param pathname - location.pathname\n * @param base - base to strip off\n */\n\n\nfunction stripBase(pathname, base) {\n  // no base or base is not found at the beginning\n  if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase())) return pathname;\n  return pathname.slice(base.length) || '/';\n}\n/**\n * Checks if two RouteLocation are equal. This means that both locations are\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\n * parameters and `hash` are the same\n *\n * @param a - first {@link RouteLocation}\n * @param b - second {@link RouteLocation}\n */\n\n\nfunction isSameRouteLocation(stringifyQuery, a, b) {\n  const aLastIndex = a.matched.length - 1;\n  const bLastIndex = b.matched.length - 1;\n  return aLastIndex > -1 && aLastIndex === bLastIndex && isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) && isSameRouteLocationParams(a.params, b.params) && stringifyQuery(a.query) === stringifyQuery(b.query) && a.hash === b.hash;\n}\n/**\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\n * considered equal to the `RouteRecord` they are aliasing.\n *\n * @param a - first {@link RouteRecord}\n * @param b - second {@link RouteRecord}\n */\n\n\nfunction isSameRouteRecord(a, b) {\n  // since the original record has an undefined value for aliasOf\n  // but all aliases point to the original record, this will always compare\n  // the original record\n  return (a.aliasOf || a) === (b.aliasOf || b);\n}\n\nfunction isSameRouteLocationParams(a, b) {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n\n  for (const key in a) {\n    if (!isSameRouteLocationParamsValue(a[key], b[key])) return false;\n  }\n\n  return true;\n}\n\nfunction isSameRouteLocationParamsValue(a, b) {\n  return Array.isArray(a) ? isEquivalentArray(a, b) : Array.isArray(b) ? isEquivalentArray(b, a) : a === b;\n}\n/**\n * Check if two arrays are the same or if an array with one single entry is the\n * same as another primitive value. Used to check query and parameters\n *\n * @param a - array of values\n * @param b - array of values or a single value\n */\n\n\nfunction isEquivalentArray(a, b) {\n  return Array.isArray(b) ? a.length === b.length && a.every((value, i) => value === b[i]) : a.length === 1 && a[0] === b;\n}\n/**\n * Resolves a relative path that starts with `.`.\n *\n * @param to - path location we are resolving\n * @param from - currentLocation.path, should start with `/`\n */\n\n\nfunction resolveRelativePath(to, from) {\n  if (to.startsWith('/')) return to;\n\n  if (process.env.NODE_ENV !== 'production' && !from.startsWith('/')) {\n    warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\n    return to;\n  }\n\n  if (!to) return from;\n  const fromSegments = from.split('/');\n  const toSegments = to.split('/');\n  let position = fromSegments.length - 1;\n  let toPosition;\n  let segment;\n\n  for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n    segment = toSegments[toPosition]; // can't go below zero\n\n    if (position === 1 || segment === '.') continue;\n    if (segment === '..') position--; // found something that is not relative path\n    else break;\n  }\n\n  return fromSegments.slice(0, position).join('/') + '/' + toSegments.slice(toPosition - (toPosition === toSegments.length ? 1 : 0)).join('/');\n}\n\nvar NavigationType;\n\n(function (NavigationType) {\n  NavigationType[\"pop\"] = \"pop\";\n  NavigationType[\"push\"] = \"push\";\n})(NavigationType || (NavigationType = {}));\n\nvar NavigationDirection;\n\n(function (NavigationDirection) {\n  NavigationDirection[\"back\"] = \"back\";\n  NavigationDirection[\"forward\"] = \"forward\";\n  NavigationDirection[\"unknown\"] = \"\";\n})(NavigationDirection || (NavigationDirection = {}));\n/**\n * Starting location for Histories\n */\n\n\nconst START = ''; // Generic utils\n\n/**\n * Normalizes a base by removing any trailing slash and reading the base tag if\n * present.\n *\n * @param base - base to normalize\n */\n\nfunction normalizeBase(base) {\n  if (!base) {\n    if (isBrowser) {\n      // respect <base> tag\n      const baseEl = document.querySelector('base');\n      base = baseEl && baseEl.getAttribute('href') || '/'; // strip full URL origin\n\n      base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\n    } else {\n      base = '/';\n    }\n  } // ensure leading slash when it was removed by the regex above avoid leading\n  // slash with hash because the file could be read from the disk like file://\n  // and the leading slash would cause problems\n\n\n  if (base[0] !== '/' && base[0] !== '#') base = '/' + base; // remove the trailing slash so all other method can just do `base + fullPath`\n  // to build an href\n\n  return removeTrailingSlash(base);\n} // remove any character before the hash\n\n\nconst BEFORE_HASH_RE = /^[^#]+#/;\n\nfunction createHref(base, location) {\n  return base.replace(BEFORE_HASH_RE, '#') + location;\n}\n\nfunction getElementPosition(el, offset) {\n  const docRect = document.documentElement.getBoundingClientRect();\n  const elRect = el.getBoundingClientRect();\n  return {\n    behavior: offset.behavior,\n    left: elRect.left - docRect.left - (offset.left || 0),\n    top: elRect.top - docRect.top - (offset.top || 0)\n  };\n}\n\nconst computeScrollPosition = () => ({\n  left: window.pageXOffset,\n  top: window.pageYOffset\n});\n\nfunction scrollToPosition(position) {\n  let scrollToOptions;\n\n  if ('el' in position) {\n    const positionEl = position.el;\n    const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\n    /**\n     * `id`s can accept pretty much any characters, including CSS combinators\n     * like `>` or `~`. It's still possible to retrieve elements using\n     * `document.getElementById('~')` but it needs to be escaped when using\n     * `document.querySelector('#\\\\~')` for it to be valid. The only\n     * requirements for `id`s are them to be unique on the page and to not be\n     * empty (`id=\"\"`). Because of that, when passing an id selector, it should\n     * be properly escaped for it to work with `querySelector`. We could check\n     * for the id selector to be simple (no CSS combinators `+ >~`) but that\n     * would make things inconsistent since they are valid characters for an\n     * `id` but would need to be escaped when using `querySelector`, breaking\n     * their usage and ending up in no selector returned. Selectors need to be\n     * escaped:\n     *\n     * - `#1-thing` becomes `#\\31 -thing`\n     * - `#with~symbols` becomes `#with\\\\~symbols`\n     *\n     * - More information about  the topic can be found at\n     *   https://mathiasbynens.be/notes/html5-id-class.\n     * - Practical example: https://mathiasbynens.be/demo/html5-id\n     */\n\n    if (process.env.NODE_ENV !== 'production' && typeof position.el === 'string') {\n      if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\n        try {\n          const foundEl = document.querySelector(position.el);\n\n          if (isIdSelector && foundEl) {\n            warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`); // return to avoid other warnings\n\n            return;\n          }\n        } catch (err) {\n          warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`); // return to avoid other warnings\n\n          return;\n        }\n      }\n    }\n\n    const el = typeof positionEl === 'string' ? isIdSelector ? document.getElementById(positionEl.slice(1)) : document.querySelector(positionEl) : positionEl;\n\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\n      return;\n    }\n\n    scrollToOptions = getElementPosition(el, position);\n  } else {\n    scrollToOptions = position;\n  }\n\n  if ('scrollBehavior' in document.documentElement.style) window.scrollTo(scrollToOptions);else {\n    window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\n  }\n}\n\nfunction getScrollKey(path, delta) {\n  const position = history.state ? history.state.position - delta : -1;\n  return position + path;\n}\n\nconst scrollPositions = new Map();\n\nfunction saveScrollPosition(key, scrollPosition) {\n  scrollPositions.set(key, scrollPosition);\n}\n\nfunction getSavedScrollPosition(key) {\n  const scroll = scrollPositions.get(key); // consume it so it's not used again\n\n  scrollPositions.delete(key);\n  return scroll;\n} // TODO: RFC about how to save scroll position\n\n/**\n * ScrollBehavior instance used by the router to compute and restore the scroll\n * position when navigating.\n */\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\n//   // returns a scroll position that can be saved in history\n//   compute(): ScrollPositionEntry\n//   // can take an extended ScrollPositionEntry\n//   scroll(position: ScrollPosition): void\n// }\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\n//   compute: computeScroll,\n//   scroll: scrollToPosition,\n// }\n\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\n/**\n * Creates a normalized history location from a window.location object\n * @param location -\n */\n\n\nfunction createCurrentLocation(base, location) {\n  const {\n    pathname,\n    search,\n    hash\n  } = location; // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end\n\n  const hashPos = base.indexOf('#');\n\n  if (hashPos > -1) {\n    let slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos); // prepend the starting slash to hash so the url starts with /#\n\n    if (pathFromHash[0] !== '/') pathFromHash = '/' + pathFromHash;\n    return stripBase(pathFromHash, '');\n  }\n\n  const path = stripBase(pathname, base);\n  return path + search + hash;\n}\n\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n  let listeners = [];\n  let teardowns = []; // TODO: should it be a stack? a Dict. Check if the popstate listener\n  // can trigger twice\n\n  let pauseState = null;\n\n  const popStateHandler = ({\n    state\n  }) => {\n    const to = createCurrentLocation(base, location);\n    const from = currentLocation.value;\n    const fromState = historyState.value;\n    let delta = 0;\n\n    if (state) {\n      currentLocation.value = to;\n      historyState.value = state; // ignore the popstate and reset the pauseState\n\n      if (pauseState && pauseState === from) {\n        pauseState = null;\n        return;\n      }\n\n      delta = fromState ? state.position - fromState.position : 0;\n    } else {\n      replace(to);\n    } // console.log({ deltaFromCurrent })\n    // Here we could also revert the navigation by calling history.go(-delta)\n    // this listener will have to be adapted to not trigger again and to wait for the url\n    // to be updated before triggering the listeners. Some kind of validation function would also\n    // need to be passed to the listeners so the navigation can be accepted\n    // call all listeners\n\n\n    listeners.forEach(listener => {\n      listener(currentLocation.value, from, {\n        delta,\n        type: NavigationType.pop,\n        direction: delta ? delta > 0 ? NavigationDirection.forward : NavigationDirection.back : NavigationDirection.unknown\n      });\n    });\n  };\n\n  function pauseListeners() {\n    pauseState = currentLocation.value;\n  }\n\n  function listen(callback) {\n    // setup the listener and prepare teardown callbacks\n    listeners.push(callback);\n\n    const teardown = () => {\n      const index = listeners.indexOf(callback);\n      if (index > -1) listeners.splice(index, 1);\n    };\n\n    teardowns.push(teardown);\n    return teardown;\n  }\n\n  function beforeUnloadListener() {\n    const {\n      history\n    } = window;\n    if (!history.state) return;\n    history.replaceState(assign({}, history.state, {\n      scroll: computeScrollPosition()\n    }), '');\n  }\n\n  function destroy() {\n    for (const teardown of teardowns) teardown();\n\n    teardowns = [];\n    window.removeEventListener('popstate', popStateHandler);\n    window.removeEventListener('beforeunload', beforeUnloadListener);\n  } // setup the listeners and prepare teardown callbacks\n\n\n  window.addEventListener('popstate', popStateHandler);\n  window.addEventListener('beforeunload', beforeUnloadListener);\n  return {\n    pauseListeners,\n    listen,\n    destroy\n  };\n}\n/**\n * Creates a state object\n */\n\n\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n  return {\n    back,\n    current,\n    forward,\n    replaced,\n    position: window.history.length,\n    scroll: computeScroll ? computeScrollPosition() : null\n  };\n}\n\nfunction useHistoryStateNavigation(base) {\n  const {\n    history,\n    location\n  } = window; // private variables\n\n  const currentLocation = {\n    value: createCurrentLocation(base, location)\n  };\n  const historyState = {\n    value: history.state\n  }; // build current history entry as this is a fresh navigation\n\n  if (!historyState.value) {\n    changeLocation(currentLocation.value, {\n      back: null,\n      current: currentLocation.value,\n      forward: null,\n      // the length is off by one, we need to decrease it\n      position: history.length - 1,\n      replaced: true,\n      // don't add a scroll as the user may have an anchor and we want\n      // scrollBehavior to be triggered without a saved position\n      scroll: null\n    }, true);\n  }\n\n  function changeLocation(to, state, replace) {\n    /**\n     * if a base tag is provided and we are on a normal domain, we have to\n     * respect the provided `base` attribute because pushState() will use it and\n     * potentially erase anything before the `#` like at\n     * https://github.com/vuejs/router/issues/685 where a base of\n     * `/folder/#` but a base of `/` would erase the `/folder/` section. If\n     * there is no host, the `<base>` tag makes no sense and if there isn't a\n     * base tag we can just use everything after the `#`.\n     */\n    const hashIndex = base.indexOf('#');\n    const url = hashIndex > -1 ? (location.host && document.querySelector('base') ? base : base.slice(hashIndex)) + to : createBaseLocation() + base + to;\n\n    try {\n      // BROWSER QUIRK\n      // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\n      history[replace ? 'replaceState' : 'pushState'](state, '', url);\n      historyState.value = state;\n    } catch (err) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('Error with push/replace State', err);\n      } else {\n        console.error(err);\n      } // Force the navigation, this also resets the call count\n\n\n      location[replace ? 'replace' : 'assign'](url);\n    }\n  }\n\n  function replace(to, data) {\n    const state = assign({}, history.state, buildState(historyState.value.back, // keep back and forward entries but override current position\n    to, historyState.value.forward, true), data, {\n      position: historyState.value.position\n    });\n    changeLocation(to, state, true);\n    currentLocation.value = to;\n  }\n\n  function push(to, data) {\n    // Add to current entry the information of where we are going\n    // as well as saving the current position\n    const currentState = assign({}, // use current history state to gracefully handle a wrong call to\n    // history.replaceState\n    // https://github.com/vuejs/router/issues/366\n    historyState.value, history.state, {\n      forward: to,\n      scroll: computeScrollPosition()\n    });\n\n    if (process.env.NODE_ENV !== 'production' && !history.state) {\n      warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` + `history.replaceState(history.state, '', url)\\n\\n` + `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\n    }\n\n    changeLocation(currentState.current, currentState, true);\n    const state = assign({}, buildState(currentLocation.value, to, null), {\n      position: currentState.position + 1\n    }, data);\n    changeLocation(to, state, false);\n    currentLocation.value = to;\n  }\n\n  return {\n    location: currentLocation,\n    state: historyState,\n    push,\n    replace\n  };\n}\n/**\n * Creates an HTML5 history. Most common history for single page applications.\n *\n * @param base -\n */\n\n\nfunction createWebHistory(base) {\n  base = normalizeBase(base);\n  const historyNavigation = useHistoryStateNavigation(base);\n  const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n\n  function go(delta, triggerListeners = true) {\n    if (!triggerListeners) historyListeners.pauseListeners();\n    history.go(delta);\n  }\n\n  const routerHistory = assign({\n    // it's overridden right after\n    location: '',\n    base,\n    go,\n    createHref: createHref.bind(null, base)\n  }, historyNavigation, historyListeners);\n  Object.defineProperty(routerHistory, 'location', {\n    enumerable: true,\n    get: () => historyNavigation.location.value\n  });\n  Object.defineProperty(routerHistory, 'state', {\n    enumerable: true,\n    get: () => historyNavigation.state.value\n  });\n  return routerHistory;\n}\n/**\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\n *\n * @param base - Base applied to all urls, defaults to '/'\n * @returns a history object that can be passed to the router constructor\n */\n\n\nfunction createMemoryHistory(base = '') {\n  let listeners = [];\n  let queue = [START];\n  let position = 0;\n  base = normalizeBase(base);\n\n  function setLocation(location) {\n    position++;\n\n    if (position === queue.length) {\n      // we are at the end, we can simply append a new entry\n      queue.push(location);\n    } else {\n      // we are in the middle, we remove everything from here in the queue\n      queue.splice(position);\n      queue.push(location);\n    }\n  }\n\n  function triggerListeners(to, from, {\n    direction,\n    delta\n  }) {\n    const info = {\n      direction,\n      delta,\n      type: NavigationType.pop\n    };\n\n    for (const callback of listeners) {\n      callback(to, from, info);\n    }\n  }\n\n  const routerHistory = {\n    // rewritten by Object.defineProperty\n    location: START,\n    // TODO: should be kept in queue\n    state: {},\n    base,\n    createHref: createHref.bind(null, base),\n\n    replace(to) {\n      // remove current entry and decrement position\n      queue.splice(position--, 1);\n      setLocation(to);\n    },\n\n    push(to, data) {\n      setLocation(to);\n    },\n\n    listen(callback) {\n      listeners.push(callback);\n      return () => {\n        const index = listeners.indexOf(callback);\n        if (index > -1) listeners.splice(index, 1);\n      };\n    },\n\n    destroy() {\n      listeners = [];\n      queue = [START];\n      position = 0;\n    },\n\n    go(delta, shouldTrigger = true) {\n      const from = this.location;\n      const direction = // we are considering delta === 0 going forward, but in abstract mode\n      // using 0 for the delta doesn't make sense like it does in html5 where\n      // it reloads the page\n      delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n      position = Math.max(0, Math.min(position + delta, queue.length - 1));\n\n      if (shouldTrigger) {\n        triggerListeners(this.location, from, {\n          direction,\n          delta\n        });\n      }\n    }\n\n  };\n  Object.defineProperty(routerHistory, 'location', {\n    enumerable: true,\n    get: () => queue[position]\n  });\n  return routerHistory;\n}\n/**\n * Creates a hash history. Useful for web applications with no host (e.g.\n * `file://`) or when configuring a server to handle any URL is not possible.\n *\n * @param base - optional base to provide. Defaults to `location.pathname +\n * location.search` If there is a `<base>` tag in the `head`, its value will be\n * ignored in favor of this parameter **but note it affects all the\n * history.pushState() calls**, meaning that if you use a `<base>` tag, it's\n * `href` value **has to match this parameter** (ignoring anything after the\n * `#`).\n *\n * @example\n * ```js\n * // at https://example.com/folder\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n * // you should avoid doing this because it changes the original url and breaks copying urls\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n *\n * // at file:///usr/etc/folder/index.html\n * // for locations with no `host`, the base is ignored\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n * ```\n */\n\n\nfunction createWebHashHistory(base) {\n  // Make sure this implementation is fine in terms of encoding, specially for IE11\n  // for `file://`, directly use the pathname and ignore the base\n  // location.pathname contains an initial `/` even at the root: `https://example.com`\n  base = location.host ? base || location.pathname + location.search : ''; // allow the user to provide a `#` in the middle: `/base/#/app`\n\n  if (!base.includes('#')) base += '#';\n\n  if (process.env.NODE_ENV !== 'production' && !base.endsWith('#/') && !base.endsWith('#')) {\n    warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\n  }\n\n  return createWebHistory(base);\n}\n\nfunction isRouteLocation(route) {\n  return typeof route === 'string' || route && typeof route === 'object';\n}\n\nfunction isRouteName(name) {\n  return typeof name === 'string' || typeof name === 'symbol';\n}\n/**\n * Initial route location where the router is. Can be used in navigation guards\n * to differentiate the initial navigation.\n *\n * @example\n * ```js\n * import { START_LOCATION } from 'vue-router'\n *\n * router.beforeEach((to, from) => {\n *   if (from === START_LOCATION) {\n *     // initial navigation\n *   }\n * })\n * ```\n */\n\n\nconst START_LOCATION_NORMALIZED = {\n  path: '/',\n  name: undefined,\n  params: {},\n  query: {},\n  hash: '',\n  fullPath: '/',\n  matched: [],\n  meta: {},\n  redirectedFrom: undefined\n};\nconst NavigationFailureSymbol = /*#__PURE__*/PolySymbol(process.env.NODE_ENV !== 'production' ? 'navigation failure' : 'nf');\n/**\n * Enumeration with all possible types for navigation failures. Can be passed to\n * {@link isNavigationFailure} to check for specific failures.\n */\n\nvar NavigationFailureType;\n\n(function (NavigationFailureType) {\n  /**\n   * An aborted navigation is a navigation that failed because a navigation\n   * guard returned `false` or called `next(false)`\n   */\n  NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\n  /**\n   * A cancelled navigation is a navigation that failed because a more recent\n   * navigation finished started (not necessarily finished).\n   */\n\n  NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\n  /**\n   * A duplicated navigation is a navigation that failed because it was\n   * initiated while already being at the exact same location.\n   */\n\n  NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\n})(NavigationFailureType || (NavigationFailureType = {})); // DEV only debug messages\n\n\nconst ErrorTypeMessages = {\n  [1\n  /* MATCHER_NOT_FOUND */\n  ]({\n    location,\n    currentLocation\n  }) {\n    return `No match for\\n ${JSON.stringify(location)}${currentLocation ? '\\nwhile being at\\n' + JSON.stringify(currentLocation) : ''}`;\n  },\n\n  [2\n  /* NAVIGATION_GUARD_REDIRECT */\n  ]({\n    from,\n    to\n  }) {\n    return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n  },\n\n  [4\n  /* NAVIGATION_ABORTED */\n  ]({\n    from,\n    to\n  }) {\n    return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n  },\n\n  [8\n  /* NAVIGATION_CANCELLED */\n  ]({\n    from,\n    to\n  }) {\n    return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n  },\n\n  [16\n  /* NAVIGATION_DUPLICATED */\n  ]({\n    from,\n    to\n  }) {\n    return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n  }\n\n};\n\nfunction createRouterError(type, params) {\n  // keep full error messages in cjs versions\n  if (process.env.NODE_ENV !== 'production' || !true) {\n    return assign(new Error(ErrorTypeMessages[type](params)), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  } else {\n    return assign(new Error(), {\n      type,\n      [NavigationFailureSymbol]: true\n    }, params);\n  }\n}\n\nfunction isNavigationFailure(error, type) {\n  return error instanceof Error && NavigationFailureSymbol in error && (type == null || !!(error.type & type));\n}\n\nconst propertiesToLog = ['params', 'query', 'hash'];\n\nfunction stringifyRoute(to) {\n  if (typeof to === 'string') return to;\n  if ('path' in to) return to.path;\n  const location = {};\n\n  for (const key of propertiesToLog) {\n    if (key in to) location[key] = to[key];\n  }\n\n  return JSON.stringify(location, null, 2);\n} // default pattern for a param: non greedy everything but /\n\n\nconst BASE_PARAM_PATTERN = '[^/]+?';\nconst BASE_PATH_PARSER_OPTIONS = {\n  sensitive: false,\n  strict: false,\n  start: true,\n  end: true\n}; // Special Regex characters that must be escaped in static tokens\n\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\n *\n * @param segments - array of segments returned by tokenizePath\n * @param extraOptions - optional options for the regexp\n * @returns a PathParser\n */\n\nfunction tokensToParser(segments, extraOptions) {\n  const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions); // the amount of scores is the same as the length of segments except for the root segment \"/\"\n\n  const score = []; // the regexp as a string\n\n  let pattern = options.start ? '^' : ''; // extracted keys\n\n  const keys = [];\n\n  for (const segment of segments) {\n    // the root segment needs special treatment\n    const segmentScores = segment.length ? [] : [90\n    /* Root */\n    ]; // allow trailing slash\n\n    if (options.strict && !segment.length) pattern += '/';\n\n    for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n      const token = segment[tokenIndex]; // resets the score if we are inside a sub segment /:a-other-:b\n\n      let subSegmentScore = 40\n      /* Segment */\n      + (options.sensitive ? 0.25\n      /* BonusCaseSensitive */\n      : 0);\n\n      if (token.type === 0\n      /* Static */\n      ) {\n        // prepend the slash if we are starting a new segment\n        if (!tokenIndex) pattern += '/';\n        pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\n        subSegmentScore += 40\n        /* Static */\n        ;\n      } else if (token.type === 1\n      /* Param */\n      ) {\n        const {\n          value,\n          repeatable,\n          optional,\n          regexp\n        } = token;\n        keys.push({\n          name: value,\n          repeatable,\n          optional\n        });\n        const re = regexp ? regexp : BASE_PARAM_PATTERN; // the user provided a custom regexp /:id(\\\\d+)\n\n        if (re !== BASE_PARAM_PATTERN) {\n          subSegmentScore += 10\n          /* BonusCustomRegExp */\n          ; // make sure the regexp is valid before using it\n\n          try {\n            new RegExp(`(${re})`);\n          } catch (err) {\n            throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` + err.message);\n          }\n        } // when we repeat we must take care of the repeating leading slash\n\n\n        let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`; // prepend the slash if we are starting a new segment\n\n        if (!tokenIndex) subPattern = // avoid an optional / if there are more segments e.g. /:p?-static\n        // or /:p?-:p2\n        optional && segment.length < 2 ? `(?:/${subPattern})` : '/' + subPattern;\n        if (optional) subPattern += '?';\n        pattern += subPattern;\n        subSegmentScore += 20\n        /* Dynamic */\n        ;\n        if (optional) subSegmentScore += -8\n        /* BonusOptional */\n        ;\n        if (repeatable) subSegmentScore += -20\n        /* BonusRepeatable */\n        ;\n        if (re === '.*') subSegmentScore += -50\n        /* BonusWildcard */\n        ;\n      }\n\n      segmentScores.push(subSegmentScore);\n    } // an empty array like /home/ -> [[{home}], []]\n    // if (!segment.length) pattern += '/'\n\n\n    score.push(segmentScores);\n  } // only apply the strict bonus to the last score\n\n\n  if (options.strict && options.end) {\n    const i = score.length - 1;\n    score[i][score[i].length - 1] += 0.7000000000000001\n    /* BonusStrict */\n    ;\n  } // TODO: dev only warn double trailing slash\n\n\n  if (!options.strict) pattern += '/?';\n  if (options.end) pattern += '$'; // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\n  else if (options.strict) pattern += '(?:/|$)';\n  const re = new RegExp(pattern, options.sensitive ? '' : 'i');\n\n  function parse(path) {\n    const match = path.match(re);\n    const params = {};\n    if (!match) return null;\n\n    for (let i = 1; i < match.length; i++) {\n      const value = match[i] || '';\n      const key = keys[i - 1];\n      params[key.name] = value && key.repeatable ? value.split('/') : value;\n    }\n\n    return params;\n  }\n\n  function stringify(params) {\n    let path = ''; // for optional parameters to allow to be empty\n\n    let avoidDuplicatedSlash = false;\n\n    for (const segment of segments) {\n      if (!avoidDuplicatedSlash || !path.endsWith('/')) path += '/';\n      avoidDuplicatedSlash = false;\n\n      for (const token of segment) {\n        if (token.type === 0\n        /* Static */\n        ) {\n          path += token.value;\n        } else if (token.type === 1\n        /* Param */\n        ) {\n          const {\n            value,\n            repeatable,\n            optional\n          } = token;\n          const param = value in params ? params[value] : '';\n          if (Array.isArray(param) && !repeatable) throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n          const text = Array.isArray(param) ? param.join('/') : param;\n\n          if (!text) {\n            if (optional) {\n              // if we have more than one optional param like /:a?-static we\n              // don't need to care about the optional param\n              if (segment.length < 2) {\n                // remove the last slash as we could be at the end\n                if (path.endsWith('/')) path = path.slice(0, -1); // do not append a slash on the next iteration\n                else avoidDuplicatedSlash = true;\n              }\n            } else throw new Error(`Missing required param \"${value}\"`);\n          }\n\n          path += text;\n        }\n      }\n    }\n\n    return path;\n  }\n\n  return {\n    re,\n    score,\n    keys,\n    parse,\n    stringify\n  };\n}\n/**\n * Compares an array of numbers as used in PathParser.score and returns a\n * number. This function can be used to `sort` an array\n *\n * @param a - first array of numbers\n * @param b - second array of numbers\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n * should be sorted first\n */\n\n\nfunction compareScoreArray(a, b) {\n  let i = 0;\n\n  while (i < a.length && i < b.length) {\n    const diff = b[i] - a[i]; // only keep going if diff === 0\n\n    if (diff) return diff;\n    i++;\n  } // if the last subsegment was Static, the shorter segments should be sorted first\n  // otherwise sort the longest segment first\n\n\n  if (a.length < b.length) {\n    return a.length === 1 && a[0] === 40\n    /* Static */\n    + 40\n    /* Segment */\n    ? -1 : 1;\n  } else if (a.length > b.length) {\n    return b.length === 1 && b[0] === 40\n    /* Static */\n    + 40\n    /* Segment */\n    ? 1 : -1;\n  }\n\n  return 0;\n}\n/**\n * Compare function that can be used with `sort` to sort an array of PathParser\n *\n * @param a - first PathParser\n * @param b - second PathParser\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n */\n\n\nfunction comparePathParserScore(a, b) {\n  let i = 0;\n  const aScore = a.score;\n  const bScore = b.score;\n\n  while (i < aScore.length && i < bScore.length) {\n    const comp = compareScoreArray(aScore[i], bScore[i]); // do not return if both are equal\n\n    if (comp) return comp;\n    i++;\n  } // if a and b share the same score entries but b has more, sort b first\n\n\n  return bScore.length - aScore.length; // this is the ternary version\n  // return aScore.length < bScore.length\n  //   ? 1\n  //   : aScore.length > bScore.length\n  //   ? -1\n  //   : 0\n}\n\nconst ROOT_TOKEN = {\n  type: 0\n  /* Static */\n  ,\n  value: ''\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/; // After some profiling, the cache seems to be unnecessary because tokenizePath\n// (the slowest part of adding a route) is very fast\n// const tokenCache = new Map<string, Token[][]>()\n\nfunction tokenizePath(path) {\n  if (!path) return [[]];\n  if (path === '/') return [[ROOT_TOKEN]];\n\n  if (!path.startsWith('/')) {\n    throw new Error(process.env.NODE_ENV !== 'production' ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".` : `Invalid path \"${path}\"`);\n  } // if (tokenCache.has(path)) return tokenCache.get(path)!\n\n\n  function crash(message) {\n    throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n  }\n\n  let state = 0\n  /* Static */\n  ;\n  let previousState = state;\n  const tokens = []; // the segment will always be valid because we get into the initial state\n  // with the leading /\n\n  let segment;\n\n  function finalizeSegment() {\n    if (segment) tokens.push(segment);\n    segment = [];\n  } // index on the path\n\n\n  let i = 0; // char at index\n\n  let char; // buffer of the value read\n\n  let buffer = ''; // custom regexp for a param\n\n  let customRe = '';\n\n  function consumeBuffer() {\n    if (!buffer) return;\n\n    if (state === 0\n    /* Static */\n    ) {\n      segment.push({\n        type: 0\n        /* Static */\n        ,\n        value: buffer\n      });\n    } else if (state === 1\n    /* Param */\n    || state === 2\n    /* ParamRegExp */\n    || state === 3\n    /* ParamRegExpEnd */\n    ) {\n      if (segment.length > 1 && (char === '*' || char === '+')) crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n      segment.push({\n        type: 1\n        /* Param */\n        ,\n        value: buffer,\n        regexp: customRe,\n        repeatable: char === '*' || char === '+',\n        optional: char === '*' || char === '?'\n      });\n    } else {\n      crash('Invalid state to consume buffer');\n    }\n\n    buffer = '';\n  }\n\n  function addCharToBuffer() {\n    buffer += char;\n  }\n\n  while (i < path.length) {\n    char = path[i++];\n\n    if (char === '\\\\' && state !== 2\n    /* ParamRegExp */\n    ) {\n      previousState = state;\n      state = 4\n      /* EscapeNext */\n      ;\n      continue;\n    }\n\n    switch (state) {\n      case 0\n      /* Static */\n      :\n        if (char === '/') {\n          if (buffer) {\n            consumeBuffer();\n          }\n\n          finalizeSegment();\n        } else if (char === ':') {\n          consumeBuffer();\n          state = 1\n          /* Param */\n          ;\n        } else {\n          addCharToBuffer();\n        }\n\n        break;\n\n      case 4\n      /* EscapeNext */\n      :\n        addCharToBuffer();\n        state = previousState;\n        break;\n\n      case 1\n      /* Param */\n      :\n        if (char === '(') {\n          state = 2\n          /* ParamRegExp */\n          ;\n        } else if (VALID_PARAM_RE.test(char)) {\n          addCharToBuffer();\n        } else {\n          consumeBuffer();\n          state = 0\n          /* Static */\n          ; // go back one character if we were not modifying\n\n          if (char !== '*' && char !== '?' && char !== '+') i--;\n        }\n\n        break;\n\n      case 2\n      /* ParamRegExp */\n      :\n        // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\n        // it already works by escaping the closing )\n        // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\n        // is this really something people need since you can also write\n        // /prefix_:p()_suffix\n        if (char === ')') {\n          // handle the escaped )\n          if (customRe[customRe.length - 1] == '\\\\') customRe = customRe.slice(0, -1) + char;else state = 3\n          /* ParamRegExpEnd */\n          ;\n        } else {\n          customRe += char;\n        }\n\n        break;\n\n      case 3\n      /* ParamRegExpEnd */\n      :\n        // same as finalizing a param\n        consumeBuffer();\n        state = 0\n        /* Static */\n        ; // go back one character if we were not modifying\n\n        if (char !== '*' && char !== '?' && char !== '+') i--;\n        customRe = '';\n        break;\n\n      default:\n        crash('Unknown state');\n        break;\n    }\n  }\n\n  if (state === 2\n  /* ParamRegExp */\n  ) crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n  consumeBuffer();\n  finalizeSegment(); // tokenCache.set(path, tokens)\n\n  return tokens;\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\n  const parser = tokensToParser(tokenizePath(record.path), options); // warn against params with the same name\n\n  if (process.env.NODE_ENV !== 'production') {\n    const existingKeys = new Set();\n\n    for (const key of parser.keys) {\n      if (existingKeys.has(key.name)) warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\n      existingKeys.add(key.name);\n    }\n  }\n\n  const matcher = assign(parser, {\n    record,\n    parent,\n    // these needs to be populated by the parent\n    children: [],\n    alias: []\n  });\n\n  if (parent) {\n    // both are aliases or both are not aliases\n    // we don't want to mix them because the order is used when\n    // passing originalRecord in Matcher.addRoute\n    if (!matcher.record.aliasOf === !parent.record.aliasOf) parent.children.push(matcher);\n  }\n\n  return matcher;\n}\n/**\n * Creates a Router Matcher.\n *\n * @internal\n * @param routes - array of initial routes\n * @param globalOptions - global route options\n */\n\n\nfunction createRouterMatcher(routes, globalOptions) {\n  // normalized ordered array of matchers\n  const matchers = [];\n  const matcherMap = new Map();\n  globalOptions = mergeOptions({\n    strict: false,\n    end: true,\n    sensitive: false\n  }, globalOptions);\n\n  function getRecordMatcher(name) {\n    return matcherMap.get(name);\n  }\n\n  function addRoute(record, parent, originalRecord) {\n    // used later on to remove by name\n    const isRootAdd = !originalRecord;\n    const mainNormalizedRecord = normalizeRouteRecord(record); // we might be the child of an alias\n\n    mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n    const options = mergeOptions(globalOptions, record); // generate an array of records to correctly handle aliases\n\n    const normalizedRecords = [mainNormalizedRecord];\n\n    if ('alias' in record) {\n      const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\n\n      for (const alias of aliases) {\n        normalizedRecords.push(assign({}, mainNormalizedRecord, {\n          // this allows us to hold a copy of the `components` option\n          // so that async components cache is hold on the original record\n          components: originalRecord ? originalRecord.record.components : mainNormalizedRecord.components,\n          path: alias,\n          // we might be the child of an alias\n          aliasOf: originalRecord ? originalRecord.record : mainNormalizedRecord // the aliases are always of the same kind as the original since they\n          // are defined on the same record\n\n        }));\n      }\n    }\n\n    let matcher;\n    let originalMatcher;\n\n    for (const normalizedRecord of normalizedRecords) {\n      const {\n        path\n      } = normalizedRecord; // Build up the path for nested routes if the child isn't an absolute\n      // route. Only add the / delimiter if the child path isn't empty and if the\n      // parent path doesn't have a trailing slash\n\n      if (parent && path[0] !== '/') {\n        const parentPath = parent.record.path;\n        const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\n        normalizedRecord.path = parent.record.path + (path && connectingSlash + path);\n      }\n\n      if (process.env.NODE_ENV !== 'production' && normalizedRecord.path === '*') {\n        throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' + 'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\n      } // create the object before hand so it can be passed to children\n\n\n      matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n      if (process.env.NODE_ENV !== 'production' && parent && path[0] === '/') checkMissingParamsInAbsolutePath(matcher, parent); // if we are an alias we must tell the original record that we exist\n      // so we can be removed\n\n      if (originalRecord) {\n        originalRecord.alias.push(matcher);\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkSameParams(originalRecord, matcher);\n        }\n      } else {\n        // otherwise, the first record is the original and others are aliases\n        originalMatcher = originalMatcher || matcher;\n        if (originalMatcher !== matcher) originalMatcher.alias.push(matcher); // remove the route if named and only for the top record (avoid in nested calls)\n        // this works because the original record is the first one\n\n        if (isRootAdd && record.name && !isAliasRecord(matcher)) removeRoute(record.name);\n      }\n\n      if ('children' in mainNormalizedRecord) {\n        const children = mainNormalizedRecord.children;\n\n        for (let i = 0; i < children.length; i++) {\n          addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n        }\n      } // if there was no original record, then the first one was not an alias and all\n      // other alias (if any) need to reference this record when adding children\n\n\n      originalRecord = originalRecord || matcher; // TODO: add normalized records for more flexibility\n      // if (parent && isAliasRecord(originalRecord)) {\n      //   parent.children.push(originalRecord)\n      // }\n\n      insertMatcher(matcher);\n    }\n\n    return originalMatcher ? () => {\n      // since other matchers are aliases, they should be removed by the original matcher\n      removeRoute(originalMatcher);\n    } : noop;\n  }\n\n  function removeRoute(matcherRef) {\n    if (isRouteName(matcherRef)) {\n      const matcher = matcherMap.get(matcherRef);\n\n      if (matcher) {\n        matcherMap.delete(matcherRef);\n        matchers.splice(matchers.indexOf(matcher), 1);\n        matcher.children.forEach(removeRoute);\n        matcher.alias.forEach(removeRoute);\n      }\n    } else {\n      const index = matchers.indexOf(matcherRef);\n\n      if (index > -1) {\n        matchers.splice(index, 1);\n        if (matcherRef.record.name) matcherMap.delete(matcherRef.record.name);\n        matcherRef.children.forEach(removeRoute);\n        matcherRef.alias.forEach(removeRoute);\n      }\n    }\n  }\n\n  function getRoutes() {\n    return matchers;\n  }\n\n  function insertMatcher(matcher) {\n    let i = 0;\n\n    while (i < matchers.length && comparePathParserScore(matcher, matchers[i]) >= 0 && ( // Adding children with empty path should still appear before the parent\n    // https://github.com/vuejs/router/issues/1124\n    matcher.record.path !== matchers[i].record.path || !isRecordChildOf(matcher, matchers[i]))) i++;\n\n    matchers.splice(i, 0, matcher); // only add the original record to the name map\n\n    if (matcher.record.name && !isAliasRecord(matcher)) matcherMap.set(matcher.record.name, matcher);\n  }\n\n  function resolve(location, currentLocation) {\n    let matcher;\n    let params = {};\n    let path;\n    let name;\n\n    if ('name' in location && location.name) {\n      matcher = matcherMap.get(location.name);\n      if (!matcher) throw createRouterError(1\n      /* MATCHER_NOT_FOUND */\n      , {\n        location\n      });\n      name = matcher.record.name;\n      params = assign( // paramsFromLocation is a new object\n      paramsFromLocation(currentLocation.params, // only keep params that exist in the resolved location\n      // TODO: only keep optional params coming from a parent record\n      matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params); // throws if cannot be stringified\n\n      path = matcher.stringify(params);\n    } else if ('path' in location) {\n      // no need to resolve the path with the matcher as it was provided\n      // this also allows the user to control the encoding\n      path = location.path;\n\n      if (process.env.NODE_ENV !== 'production' && !path.startsWith('/')) {\n        warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);\n      }\n\n      matcher = matchers.find(m => m.re.test(path)); // matcher should have a value after the loop\n\n      if (matcher) {\n        // TODO: dev warning of unused params if provided\n        // we know the matcher works because we tested the regexp\n        params = matcher.parse(path);\n        name = matcher.record.name;\n      } // location is a relative path\n\n    } else {\n      // match by name or path of current route\n      matcher = currentLocation.name ? matcherMap.get(currentLocation.name) : matchers.find(m => m.re.test(currentLocation.path));\n      if (!matcher) throw createRouterError(1\n      /* MATCHER_NOT_FOUND */\n      , {\n        location,\n        currentLocation\n      });\n      name = matcher.record.name; // since we are navigating to the same location, we don't need to pick the\n      // params like when `name` is provided\n\n      params = assign({}, currentLocation.params, location.params);\n      path = matcher.stringify(params);\n    }\n\n    const matched = [];\n    let parentMatcher = matcher;\n\n    while (parentMatcher) {\n      // reversed order so parents are at the beginning\n      matched.unshift(parentMatcher.record);\n      parentMatcher = parentMatcher.parent;\n    }\n\n    return {\n      name,\n      path,\n      params,\n      matched,\n      meta: mergeMetaFields(matched)\n    };\n  } // add initial routes\n\n\n  routes.forEach(route => addRoute(route));\n  return {\n    addRoute,\n    resolve,\n    removeRoute,\n    getRoutes,\n    getRecordMatcher\n  };\n}\n\nfunction paramsFromLocation(params, keys) {\n  const newParams = {};\n\n  for (const key of keys) {\n    if (key in params) newParams[key] = params[key];\n  }\n\n  return newParams;\n}\n/**\n * Normalizes a RouteRecordRaw. Creates a copy\n *\n * @param record\n * @returns the normalized version\n */\n\n\nfunction normalizeRouteRecord(record) {\n  return {\n    path: record.path,\n    redirect: record.redirect,\n    name: record.name,\n    meta: record.meta || {},\n    aliasOf: undefined,\n    beforeEnter: record.beforeEnter,\n    props: normalizeRecordProps(record),\n    children: record.children || [],\n    instances: {},\n    leaveGuards: new Set(),\n    updateGuards: new Set(),\n    enterCallbacks: {},\n    components: 'components' in record ? record.components || {} : {\n      default: record.component\n    }\n  };\n}\n/**\n * Normalize the optional `props` in a record to always be an object similar to\n * components. Also accept a boolean for components.\n * @param record\n */\n\n\nfunction normalizeRecordProps(record) {\n  const propsObject = {}; // props does not exist on redirect records but we can set false directly\n\n  const props = record.props || false;\n\n  if ('component' in record) {\n    propsObject.default = props;\n  } else {\n    // NOTE: we could also allow a function to be applied to every component.\n    // Would need user feedback for use cases\n    for (const name in record.components) propsObject[name] = typeof props === 'boolean' ? props : props[name];\n  }\n\n  return propsObject;\n}\n/**\n * Checks if a record or any of its parent is an alias\n * @param record\n */\n\n\nfunction isAliasRecord(record) {\n  while (record) {\n    if (record.record.aliasOf) return true;\n    record = record.parent;\n  }\n\n  return false;\n}\n/**\n * Merge meta fields of an array of records\n *\n * @param matched - array of matched records\n */\n\n\nfunction mergeMetaFields(matched) {\n  return matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\n\nfunction mergeOptions(defaults, partialOptions) {\n  const options = {};\n\n  for (const key in defaults) {\n    options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n  }\n\n  return options;\n}\n\nfunction isSameParam(a, b) {\n  return a.name === b.name && a.optional === b.optional && a.repeatable === b.repeatable;\n}\n/**\n * Check if a path and its alias have the same required params\n *\n * @param a - original record\n * @param b - alias record\n */\n\n\nfunction checkSameParams(a, b) {\n  for (const key of a.keys) {\n    if (!key.optional && !b.keys.find(isSameParam.bind(null, key))) return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\n  }\n\n  for (const key of b.keys) {\n    if (!key.optional && !a.keys.find(isSameParam.bind(null, key))) return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\n  }\n}\n\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n  for (const key of parent.keys) {\n    if (!record.keys.find(isSameParam.bind(null, key))) return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n  }\n}\n\nfunction isRecordChildOf(record, parent) {\n  return parent.children.some(child => child === record || isRecordChildOf(record, child));\n}\n/**\n * Encoding Rules ␣ = Space Path: ␣ \" < > # ? { } Query: ␣ \" < > # & = Hash: ␣ \"\n * < > `\n *\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\n * defines some extra characters to be encoded. Most browsers do not encode them\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\n * plus `-._~`. This extra safety should be applied to query by patching the\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\n * encoded everywhere because some browsers like FF encode it when directly\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\n */\n// const EXTRA_RESERVED_RE = /[!'()*]/g\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\n\n\nconst HASH_RE = /#/g; // %23\n\nconst AMPERSAND_RE = /&/g; // %26\n\nconst SLASH_RE = /\\//g; // %2F\n\nconst EQUAL_RE = /=/g; // %3D\n\nconst IM_RE = /\\?/g; // %3F\n\nconst PLUS_RE = /\\+/g; // %2B\n\n/**\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\n * seems to be less flexible than not doing so and I can't find out the legacy\n * systems requiring this for regular requests like text/html. In the standard,\n * the encoding of the plus character is only mentioned for\n * application/x-www-form-urlencoded\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\n * leave the plus character as is in queries. To be more flexible, we allow the\n * plus character on the query but it can also be manually encoded by the user.\n *\n * Resources:\n * - https://url.spec.whatwg.org/#urlencoded-parsing\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\n */\n\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\n\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\n\nconst ENC_CARET_RE = /%5E/g; // ^\n\nconst ENC_BACKTICK_RE = /%60/g; // `\n\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\n\nconst ENC_PIPE_RE = /%7C/g; // |\n\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\n\nconst ENC_SPACE_RE = /%20/g; // }\n\n/**\n * Encode characters that need to be encoded on the path, search and hash\n * sections of the URL.\n *\n * @internal\n * @param text - string to encode\n * @returns encoded string\n */\n\nfunction commonEncode(text) {\n  return encodeURI('' + text).replace(ENC_PIPE_RE, '|').replace(ENC_BRACKET_OPEN_RE, '[').replace(ENC_BRACKET_CLOSE_RE, ']');\n}\n/**\n * Encode characters that need to be encoded on the hash section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\n\n\nfunction encodeHash(text) {\n  return commonEncode(text).replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');\n}\n/**\n * Encode characters that need to be encoded query values on the query\n * section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\n\n\nfunction encodeQueryValue(text) {\n  return commonEncode(text) // Encode the space as +, encode the + to differentiate it from the space\n  .replace(PLUS_RE, '%2B').replace(ENC_SPACE_RE, '+').replace(HASH_RE, '%23').replace(AMPERSAND_RE, '%26').replace(ENC_BACKTICK_RE, '`').replace(ENC_CURLY_OPEN_RE, '{').replace(ENC_CURLY_CLOSE_RE, '}').replace(ENC_CARET_RE, '^');\n}\n/**\n * Like `encodeQueryValue` but also encodes the `=` character.\n *\n * @param text - string to encode\n */\n\n\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\n}\n/**\n * Encode characters that need to be encoded on the path section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\n\n\nfunction encodePath(text) {\n  return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\n}\n/**\n * Encode characters that need to be encoded on the path section of the URL as a\n * param. This function encodes everything {@link encodePath} does plus the\n * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\n * string instead.\n *\n * @param text - string to encode\n * @returns encoded string\n */\n\n\nfunction encodeParam(text) {\n  return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');\n}\n/**\n * Decode text using `decodeURIComponent`. Returns the original text if it\n * fails.\n *\n * @param text - string to decode\n * @returns decoded string\n */\n\n\nfunction decode(text) {\n  try {\n    return decodeURIComponent('' + text);\n  } catch (err) {\n    process.env.NODE_ENV !== 'production' && warn(`Error decoding \"${text}\". Using original value`);\n  }\n\n  return '' + text;\n}\n/**\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\n * version with the leading `?` and without Should work as URLSearchParams\n\n * @internal\n *\n * @param search - search string to parse\n * @returns a query object\n */\n\n\nfunction parseQuery(search) {\n  const query = {}; // avoid creating an object with an empty key and empty value\n  // because of split('&')\n\n  if (search === '' || search === '?') return query;\n  const hasLeadingIM = search[0] === '?';\n  const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\n\n  for (let i = 0; i < searchParams.length; ++i) {\n    // pre decode the + into space\n    const searchParam = searchParams[i].replace(PLUS_RE, ' '); // allow the = character\n\n    const eqPos = searchParam.indexOf('=');\n    const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n    const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n\n    if (key in query) {\n      // an extra variable for ts types\n      let currentValue = query[key];\n\n      if (!Array.isArray(currentValue)) {\n        currentValue = query[key] = [currentValue];\n      }\n\n      currentValue.push(value);\n    } else {\n      query[key] = value;\n    }\n  }\n\n  return query;\n}\n/**\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\n * doesn't prepend a `?`\n *\n * @internal\n *\n * @param query - query object to stringify\n * @returns string version of the query without the leading `?`\n */\n\n\nfunction stringifyQuery(query) {\n  let search = '';\n\n  for (let key in query) {\n    const value = query[key];\n    key = encodeQueryKey(key);\n\n    if (value == null) {\n      // only null adds the value\n      if (value !== undefined) {\n        search += (search.length ? '&' : '') + key;\n      }\n\n      continue;\n    } // keep null values\n\n\n    const values = Array.isArray(value) ? value.map(v => v && encodeQueryValue(v)) : [value && encodeQueryValue(value)];\n    values.forEach(value => {\n      // skip undefined values in arrays as if they were not present\n      // smaller code than using filter\n      if (value !== undefined) {\n        // only append & with non-empty search\n        search += (search.length ? '&' : '') + key;\n        if (value != null) search += '=' + value;\n      }\n    });\n  }\n\n  return search;\n}\n/**\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\n * numbers into strings, removing keys with an undefined value and replacing\n * undefined with null in arrays\n *\n * @param query - query object to normalize\n * @returns a normalized query object\n */\n\n\nfunction normalizeQuery(query) {\n  const normalizedQuery = {};\n\n  for (const key in query) {\n    const value = query[key];\n\n    if (value !== undefined) {\n      normalizedQuery[key] = Array.isArray(value) ? value.map(v => v == null ? null : '' + v) : value == null ? value : '' + value;\n    }\n  }\n\n  return normalizedQuery;\n}\n/**\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\n */\n\n\nfunction useCallbacks() {\n  let handlers = [];\n\n  function add(handler) {\n    handlers.push(handler);\n    return () => {\n      const i = handlers.indexOf(handler);\n      if (i > -1) handlers.splice(i, 1);\n    };\n  }\n\n  function reset() {\n    handlers = [];\n  }\n\n  return {\n    add,\n    list: () => handlers,\n    reset\n  };\n}\n\nfunction registerGuard(record, name, guard) {\n  const removeFromList = () => {\n    record[name].delete(guard);\n  };\n\n  onUnmounted(removeFromList);\n  onDeactivated(removeFromList);\n  onActivated(() => {\n    record[name].add(guard);\n  });\n  record[name].add(guard);\n}\n/**\n * Add a navigation guard that triggers whenever the component for the current\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\n * used in any component. The guard is removed when the component is unmounted.\n *\n * @param leaveGuard - {@link NavigationGuard}\n */\n\n\nfunction onBeforeRouteLeave(leaveGuard) {\n  if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n    warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');\n    return;\n  }\n\n  const activeRecord = inject(matchedRouteKey, // to avoid warning\n  {}).value;\n\n  if (!activeRecord) {\n    process.env.NODE_ENV !== 'production' && warn('No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\n    return;\n  }\n\n  registerGuard(activeRecord, 'leaveGuards', leaveGuard);\n}\n/**\n * Add a navigation guard that triggers whenever the current location is about\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\n * component. The guard is removed when the component is unmounted.\n *\n * @param updateGuard - {@link NavigationGuard}\n */\n\n\nfunction onBeforeRouteUpdate(updateGuard) {\n  if (process.env.NODE_ENV !== 'production' && !getCurrentInstance()) {\n    warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');\n    return;\n  }\n\n  const activeRecord = inject(matchedRouteKey, // to avoid warning\n  {}).value;\n\n  if (!activeRecord) {\n    process.env.NODE_ENV !== 'production' && warn('No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\n    return;\n  }\n\n  registerGuard(activeRecord, 'updateGuards', updateGuard);\n}\n\nfunction guardToPromiseFn(guard, to, from, record, name) {\n  // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\n  const enterCallbackArray = record && ( // name is defined if record is because of the function overload\n  record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n  return () => new Promise((resolve, reject) => {\n    const next = valid => {\n      if (valid === false) reject(createRouterError(4\n      /* NAVIGATION_ABORTED */\n      , {\n        from,\n        to\n      }));else if (valid instanceof Error) {\n        reject(valid);\n      } else if (isRouteLocation(valid)) {\n        reject(createRouterError(2\n        /* NAVIGATION_GUARD_REDIRECT */\n        , {\n          from: to,\n          to: valid\n        }));\n      } else {\n        if (enterCallbackArray && // since enterCallbackArray is truthy, both record and name also are\n        record.enterCallbacks[name] === enterCallbackArray && typeof valid === 'function') enterCallbackArray.push(valid);\n        resolve();\n      }\n    }; // wrapping with Promise.resolve allows it to work with both async and sync guards\n\n\n    const guardReturn = guard.call(record && record.instances[name], to, from, process.env.NODE_ENV !== 'production' ? canOnlyBeCalledOnce(next, to, from) : next);\n    let guardCall = Promise.resolve(guardReturn);\n    if (guard.length < 3) guardCall = guardCall.then(next);\n\n    if (process.env.NODE_ENV !== 'production' && guard.length > 2) {\n      const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\n\n      if (typeof guardReturn === 'object' && 'then' in guardReturn) {\n        guardCall = guardCall.then(resolvedValue => {\n          // @ts-expect-error: _called is added at canOnlyBeCalledOnce\n          if (!next._called) {\n            warn(message);\n            return Promise.reject(new Error('Invalid navigation guard'));\n          }\n\n          return resolvedValue;\n        }); // TODO: test me!\n      } else if (guardReturn !== undefined) {\n        // @ts-expect-error: _called is added at canOnlyBeCalledOnce\n        if (!next._called) {\n          warn(message);\n          reject(new Error('Invalid navigation guard'));\n          return;\n        }\n      }\n    }\n\n    guardCall.catch(err => reject(err));\n  });\n}\n\nfunction canOnlyBeCalledOnce(next, to, from) {\n  let called = 0;\n  return function () {\n    if (called++ === 1) warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`); // @ts-expect-error: we put it in the original one because it's easier to check\n\n    next._called = true;\n    if (called === 1) next.apply(null, arguments);\n  };\n}\n\nfunction extractComponentsGuards(matched, guardType, to, from) {\n  const guards = [];\n\n  for (const record of matched) {\n    for (const name in record.components) {\n      let rawComponent = record.components[name];\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!rawComponent || typeof rawComponent !== 'object' && typeof rawComponent !== 'function') {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is not` + ` a valid component. Received \"${String(rawComponent)}\".`); // throw to ensure we stop here but warn to ensure the message isn't\n          // missed by the user\n\n          throw new Error('Invalid route component');\n        } else if ('then' in rawComponent) {\n          // warn if user wrote import('/component.vue') instead of () =>\n          // import('./component.vue')\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a ` + `Promise instead of a function that returns a Promise. Did you ` + `write \"import('./MyPage.vue')\" instead of ` + `\"() => import('./MyPage.vue')\" ? This will break in ` + `production if not fixed.`);\n          const promise = rawComponent;\n\n          rawComponent = () => promise;\n        } else if (rawComponent.__asyncLoader && // warn only once per component\n        !rawComponent.__warnedDefineAsync) {\n          rawComponent.__warnedDefineAsync = true;\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is defined ` + `using \"defineAsyncComponent()\". ` + `Write \"() => import('./MyPage.vue')\" instead of ` + `\"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\n        }\n      } // skip update and leave guards if the route component is not mounted\n\n\n      if (guardType !== 'beforeRouteEnter' && !record.instances[name]) continue;\n\n      if (isRouteComponent(rawComponent)) {\n        // __vccOpts is added by vue-class-component and contain the regular options\n        const options = rawComponent.__vccOpts || rawComponent;\n        const guard = options[guardType];\n        guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\n      } else {\n        // start requesting the chunk already\n        let componentPromise = rawComponent();\n\n        if (process.env.NODE_ENV !== 'production' && !('catch' in componentPromise)) {\n          warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\n          componentPromise = Promise.resolve(componentPromise);\n        }\n\n        guards.push(() => componentPromise.then(resolved => {\n          if (!resolved) return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\n          const resolvedComponent = isESModule(resolved) ? resolved.default : resolved; // replace the function with the resolved component\n\n          record.components[name] = resolvedComponent; // __vccOpts is added by vue-class-component and contain the regular options\n\n          const options = resolvedComponent.__vccOpts || resolvedComponent;\n          const guard = options[guardType];\n          return guard && guardToPromiseFn(guard, to, from, record, name)();\n        }));\n      }\n    }\n  }\n\n  return guards;\n}\n/**\n * Allows differentiating lazy components from functional components and vue-class-component\n *\n * @param component\n */\n\n\nfunction isRouteComponent(component) {\n  return typeof component === 'object' || 'displayName' in component || 'props' in component || '__vccOpts' in component;\n} // TODO: we could allow currentRoute as a prop to expose `isActive` and\n// `isExactActive` behavior should go through an RFC\n\n\nfunction useLink(props) {\n  const router = inject(routerKey);\n  const currentRoute = inject(routeLocationKey);\n  const route = computed(() => router.resolve(unref(props.to)));\n  const activeRecordIndex = computed(() => {\n    const {\n      matched\n    } = route.value;\n    const {\n      length\n    } = matched;\n    const routeMatched = matched[length - 1];\n    const currentMatched = currentRoute.matched;\n    if (!routeMatched || !currentMatched.length) return -1;\n    const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n    if (index > -1) return index; // possible parent record\n\n    const parentRecordPath = getOriginalPath(matched[length - 2]);\n    return (// we are dealing with nested routes\n      length > 1 && // if the parent and matched route have the same path, this link is\n      // referring to the empty child. Or we currently are on a different\n      // child of the same parent\n      getOriginalPath(routeMatched) === parentRecordPath && // avoid comparing the child with its parent\n      currentMatched[currentMatched.length - 1].path !== parentRecordPath ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2])) : index\n    );\n  });\n  const isActive = computed(() => activeRecordIndex.value > -1 && includesParams(currentRoute.params, route.value.params));\n  const isExactActive = computed(() => activeRecordIndex.value > -1 && activeRecordIndex.value === currentRoute.matched.length - 1 && isSameRouteLocationParams(currentRoute.params, route.value.params));\n\n  function navigate(e = {}) {\n    if (guardEvent(e)) {\n      return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to) // avoid uncaught errors are they are logged anyway\n      ).catch(noop);\n    }\n\n    return Promise.resolve();\n  } // devtools only\n\n\n  if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n    const instance = getCurrentInstance();\n\n    if (instance) {\n      const linkContextDevtools = {\n        route: route.value,\n        isActive: isActive.value,\n        isExactActive: isExactActive.value\n      }; // @ts-expect-error: this is internal\n\n      instance.__vrl_devtools = instance.__vrl_devtools || []; // @ts-expect-error: this is internal\n\n      instance.__vrl_devtools.push(linkContextDevtools);\n\n      watchEffect(() => {\n        linkContextDevtools.route = route.value;\n        linkContextDevtools.isActive = isActive.value;\n        linkContextDevtools.isExactActive = isExactActive.value;\n      }, {\n        flush: 'post'\n      });\n    }\n  }\n\n  return {\n    route,\n    href: computed(() => route.value.href),\n    isActive,\n    isExactActive,\n    navigate\n  };\n}\n\nconst RouterLinkImpl = /*#__PURE__*/defineComponent({\n  name: 'RouterLink',\n  props: {\n    to: {\n      type: [String, Object],\n      required: true\n    },\n    replace: Boolean,\n    activeClass: String,\n    // inactiveClass: String,\n    exactActiveClass: String,\n    custom: Boolean,\n    ariaCurrentValue: {\n      type: String,\n      default: 'page'\n    }\n  },\n  useLink,\n\n  setup(props, {\n    slots\n  }) {\n    const link = reactive(useLink(props));\n    const {\n      options\n    } = inject(routerKey);\n    const elClass = computed(() => ({\n      [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\n      // [getLinkClass(\n      //   props.inactiveClass,\n      //   options.linkInactiveClass,\n      //   'router-link-inactive'\n      // )]: !link.isExactActive,\n      [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive\n    }));\n    return () => {\n      const children = slots.default && slots.default(link);\n      return props.custom ? children : h('a', {\n        'aria-current': link.isExactActive ? props.ariaCurrentValue : null,\n        href: link.href,\n        // this would override user added attrs but Vue will still add\n        // the listener so we end up triggering both\n        onClick: link.navigate,\n        class: elClass.value\n      }, children);\n    };\n  }\n\n}); // export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n\n/**\n * Component to render a link that triggers a navigation on click.\n */\n\nconst RouterLink = RouterLinkImpl;\n\nfunction guardEvent(e) {\n  // don't redirect with control keys\n  if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return; // don't redirect when preventDefault called\n\n  if (e.defaultPrevented) return; // don't redirect on right click\n\n  if (e.button !== undefined && e.button !== 0) return; // don't redirect if `target=\"_blank\"`\n  // @ts-expect-error getAttribute does exist\n\n  if (e.currentTarget && e.currentTarget.getAttribute) {\n    // @ts-expect-error getAttribute exists\n    const target = e.currentTarget.getAttribute('target');\n    if (/\\b_blank\\b/i.test(target)) return;\n  } // this may be a Weex event which doesn't have this method\n\n\n  if (e.preventDefault) e.preventDefault();\n  return true;\n}\n\nfunction includesParams(outer, inner) {\n  for (const key in inner) {\n    const innerValue = inner[key];\n    const outerValue = outer[key];\n\n    if (typeof innerValue === 'string') {\n      if (innerValue !== outerValue) return false;\n    } else {\n      if (!Array.isArray(outerValue) || outerValue.length !== innerValue.length || innerValue.some((value, i) => value !== outerValue[i])) return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Get the original path value of a record by following its aliasOf\n * @param record\n */\n\n\nfunction getOriginalPath(record) {\n  return record ? record.aliasOf ? record.aliasOf.path : record.path : '';\n}\n/**\n * Utility class to get the active class based on defaults.\n * @param propClass\n * @param globalClass\n * @param defaultClass\n */\n\n\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null ? propClass : globalClass != null ? globalClass : defaultClass;\n\nconst RouterViewImpl = /*#__PURE__*/defineComponent({\n  name: 'RouterView',\n  // #674 we manually inherit them\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String,\n      default: 'default'\n    },\n    route: Object\n  },\n\n  setup(props, {\n    attrs,\n    slots\n  }) {\n    process.env.NODE_ENV !== 'production' && warnDeprecatedUsage();\n    const injectedRoute = inject(routerViewLocationKey);\n    const routeToDisplay = computed(() => props.route || injectedRoute.value);\n    const depth = inject(viewDepthKey, 0);\n    const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);\n    provide(viewDepthKey, depth + 1);\n    provide(matchedRouteKey, matchedRouteRef);\n    provide(routerViewLocationKey, routeToDisplay);\n    const viewRef = ref(); // watch at the same time the component instance, the route record we are\n    // rendering, and the name\n\n    watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\n      // copy reused instances\n      if (to) {\n        // this will update the instance for new instances as well as reused\n        // instances when navigating to a new route\n        to.instances[name] = instance; // the component instance is reused for a different route or name so\n        // we copy any saved update or leave guards. With async setup, the\n        // mounting component will mount before the matchedRoute changes,\n        // making instance === oldInstance, so we check if guards have been\n        // added before. This works because we remove guards when\n        // unmounting/deactivating components\n\n        if (from && from !== to && instance && instance === oldInstance) {\n          if (!to.leaveGuards.size) {\n            to.leaveGuards = from.leaveGuards;\n          }\n\n          if (!to.updateGuards.size) {\n            to.updateGuards = from.updateGuards;\n          }\n        }\n      } // trigger beforeRouteEnter next callbacks\n\n\n      if (instance && to && ( // if there is no instance but to and from are the same this might be\n      // the first visit\n      !from || !isSameRouteRecord(to, from) || !oldInstance)) {\n        (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\n      }\n    }, {\n      flush: 'post'\n    });\n    return () => {\n      const route = routeToDisplay.value;\n      const matchedRoute = matchedRouteRef.value;\n      const ViewComponent = matchedRoute && matchedRoute.components[props.name]; // we need the value at the time we render because when we unmount, we\n      // navigated to a different location so the value is different\n\n      const currentName = props.name;\n\n      if (!ViewComponent) {\n        return normalizeSlot(slots.default, {\n          Component: ViewComponent,\n          route\n        });\n      } // props from route configuration\n\n\n      const routePropsOption = matchedRoute.props[props.name];\n      const routeProps = routePropsOption ? routePropsOption === true ? route.params : typeof routePropsOption === 'function' ? routePropsOption(route) : routePropsOption : null;\n\n      const onVnodeUnmounted = vnode => {\n        // remove the instance reference to prevent leak\n        if (vnode.component.isUnmounted) {\n          matchedRoute.instances[currentName] = null;\n        }\n      };\n\n      const component = h(ViewComponent, assign({}, routeProps, attrs, {\n        onVnodeUnmounted,\n        ref: viewRef\n      }));\n\n      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && isBrowser && component.ref) {\n        // TODO: can display if it's an alias, its props\n        const info = {\n          depth,\n          name: matchedRoute.name,\n          path: matchedRoute.path,\n          meta: matchedRoute.meta\n        };\n        const internalInstances = Array.isArray(component.ref) ? component.ref.map(r => r.i) : [component.ref.i];\n        internalInstances.forEach(instance => {\n          // @ts-expect-error\n          instance.__vrv_devtools = info;\n        });\n      }\n\n      return (// pass the vnode to the slot as a prop.\n        // h and <component :is=\"...\"> both accept vnodes\n        normalizeSlot(slots.default, {\n          Component: component,\n          route\n        }) || component\n      );\n    };\n  }\n\n});\n\nfunction normalizeSlot(slot, data) {\n  if (!slot) return null;\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? slotContent[0] : slotContent;\n} // export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n\n/**\n * Component to display the current route the user is at.\n */\n\n\nconst RouterView = RouterViewImpl; // warn against deprecated usage with <transition> & <keep-alive>\n// due to functional component being no longer eager in Vue 3\n\nfunction warnDeprecatedUsage() {\n  const instance = getCurrentInstance();\n  const parentName = instance.parent && instance.parent.type.name;\n\n  if (parentName && (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\n    const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\n    warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` + `Use slot props instead:\\n\\n` + `<router-view v-slot=\"{ Component }\">\\n` + `  <${comp}>\\n` + `    <component :is=\"Component\" />\\n` + `  </${comp}>\\n` + `</router-view>`);\n  }\n}\n\nfunction formatRouteLocation(routeLocation, tooltip) {\n  const copy = assign({}, routeLocation, {\n    // remove variables that can contain vue instances\n    matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf']))\n  });\n  return {\n    _custom: {\n      type: null,\n      readOnly: true,\n      display: routeLocation.fullPath,\n      tooltip,\n      value: copy\n    }\n  };\n}\n\nfunction formatDisplay(display) {\n  return {\n    _custom: {\n      display\n    }\n  };\n} // to support multiple router instances\n\n\nlet routerId = 0;\n\nfunction addDevtools(app, router, matcher) {\n  // Take over router.beforeEach and afterEach\n  // make sure we are not registering the devtool twice\n  if (router.__hasDevtools) return;\n  router.__hasDevtools = true; // increment to support multiple router instances\n\n  const id = routerId++;\n  setupDevtoolsPlugin({\n    id: 'org.vuejs.router' + (id ? '.' + id : ''),\n    label: 'Vue Router',\n    packageName: 'vue-router',\n    homepage: 'https://router.vuejs.org',\n    logo: 'https://router.vuejs.org/logo.png',\n    componentStateTypes: ['Routing'],\n    app\n  }, api => {\n    // display state added by the router\n    api.on.inspectComponent((payload, ctx) => {\n      if (payload.instanceData) {\n        payload.instanceData.state.push({\n          type: 'Routing',\n          key: '$route',\n          editable: false,\n          value: formatRouteLocation(router.currentRoute.value, 'Current Route')\n        });\n      }\n    }); // mark router-link as active and display tags on router views\n\n    api.on.visitComponentTree(({\n      treeNode: node,\n      componentInstance\n    }) => {\n      if (componentInstance.__vrv_devtools) {\n        const info = componentInstance.__vrv_devtools;\n        node.tags.push({\n          label: (info.name ? `${info.name.toString()}: ` : '') + info.path,\n          textColor: 0,\n          tooltip: 'This component is rendered by &lt;router-view&gt;',\n          backgroundColor: PINK_500\n        });\n      } // if multiple useLink are used\n\n\n      if (Array.isArray(componentInstance.__vrl_devtools)) {\n        componentInstance.__devtoolsApi = api;\n\n        componentInstance.__vrl_devtools.forEach(devtoolsData => {\n          let backgroundColor = ORANGE_400;\n          let tooltip = '';\n\n          if (devtoolsData.isExactActive) {\n            backgroundColor = LIME_500;\n            tooltip = 'This is exactly active';\n          } else if (devtoolsData.isActive) {\n            backgroundColor = BLUE_600;\n            tooltip = 'This link is active';\n          }\n\n          node.tags.push({\n            label: devtoolsData.route.path,\n            textColor: 0,\n            tooltip,\n            backgroundColor\n          });\n        });\n      }\n    });\n    watch(router.currentRoute, () => {\n      // refresh active state\n      refreshRoutesView();\n      api.notifyComponentUpdate();\n      api.sendInspectorTree(routerInspectorId);\n      api.sendInspectorState(routerInspectorId);\n    });\n    const navigationsLayerId = 'router:navigations:' + id;\n    api.addTimelineLayer({\n      id: navigationsLayerId,\n      label: `Router${id ? ' ' + id : ''} Navigations`,\n      color: 0x40a8c4\n    }); // const errorsLayerId = 'router:errors'\n    // api.addTimelineLayer({\n    //   id: errorsLayerId,\n    //   label: 'Router Errors',\n    //   color: 0xea5455,\n    // })\n\n    router.onError((error, to) => {\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: 'Error during Navigation',\n          subtitle: to.fullPath,\n          logType: 'error',\n          time: Date.now(),\n          data: {\n            error\n          },\n          groupId: to.meta.__navigationId\n        }\n      });\n    }); // attached to `meta` and used to group events\n\n    let navigationId = 0;\n    router.beforeEach((to, from) => {\n      const data = {\n        guard: formatDisplay('beforeEach'),\n        from: formatRouteLocation(from, 'Current Location during this navigation'),\n        to: formatRouteLocation(to, 'Target location')\n      }; // Used to group navigations together, hide from devtools\n\n      Object.defineProperty(to.meta, '__navigationId', {\n        value: navigationId++\n      });\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          time: Date.now(),\n          title: 'Start of navigation',\n          subtitle: to.fullPath,\n          data,\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    router.afterEach((to, from, failure) => {\n      const data = {\n        guard: formatDisplay('afterEach')\n      };\n\n      if (failure) {\n        data.failure = {\n          _custom: {\n            type: Error,\n            readOnly: true,\n            display: failure ? failure.message : '',\n            tooltip: 'Navigation Failure',\n            value: failure\n          }\n        };\n        data.status = formatDisplay('❌');\n      } else {\n        data.status = formatDisplay('✅');\n      } // we set here to have the right order\n\n\n      data.from = formatRouteLocation(from, 'Current Location during this navigation');\n      data.to = formatRouteLocation(to, 'Target location');\n      api.addTimelineEvent({\n        layerId: navigationsLayerId,\n        event: {\n          title: 'End of navigation',\n          subtitle: to.fullPath,\n          time: Date.now(),\n          data,\n          logType: failure ? 'warning' : 'default',\n          groupId: to.meta.__navigationId\n        }\n      });\n    });\n    /**\n     * Inspector of Existing routes\n     */\n\n    const routerInspectorId = 'router-inspector:' + id;\n    api.addInspector({\n      id: routerInspectorId,\n      label: 'Routes' + (id ? ' ' + id : ''),\n      icon: 'book',\n      treeFilterPlaceholder: 'Search routes'\n    });\n\n    function refreshRoutesView() {\n      // the routes view isn't active\n      if (!activeRoutesPayload) return;\n      const payload = activeRoutesPayload; // children routes will appear as nested\n\n      let routes = matcher.getRoutes().filter(route => !route.parent); // reset match state to false\n\n      routes.forEach(resetMatchStateOnRouteRecord); // apply a match state if there is a payload\n\n      if (payload.filter) {\n        routes = routes.filter(route => // save matches state based on the payload\n        isRouteMatching(route, payload.filter.toLowerCase()));\n      } // mark active routes\n\n\n      routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\n      payload.rootNodes = routes.map(formatRouteRecordForInspector);\n    }\n\n    let activeRoutesPayload;\n    api.on.getInspectorTree(payload => {\n      activeRoutesPayload = payload;\n\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        refreshRoutesView();\n      }\n    });\n    /**\n     * Display information about the currently selected route record\n     */\n\n    api.on.getInspectorState(payload => {\n      if (payload.app === app && payload.inspectorId === routerInspectorId) {\n        const routes = matcher.getRoutes();\n        const route = routes.find(route => route.record.__vd_id === payload.nodeId);\n\n        if (route) {\n          payload.state = {\n            options: formatRouteRecordMatcherForStateInspector(route)\n          };\n        }\n      }\n    });\n    api.sendInspectorTree(routerInspectorId);\n    api.sendInspectorState(routerInspectorId);\n  });\n}\n\nfunction modifierForKey(key) {\n  if (key.optional) {\n    return key.repeatable ? '*' : '?';\n  } else {\n    return key.repeatable ? '+' : '';\n  }\n}\n\nfunction formatRouteRecordMatcherForStateInspector(route) {\n  const {\n    record\n  } = route;\n  const fields = [{\n    editable: false,\n    key: 'path',\n    value: record.path\n  }];\n\n  if (record.name != null) {\n    fields.push({\n      editable: false,\n      key: 'name',\n      value: record.name\n    });\n  }\n\n  fields.push({\n    editable: false,\n    key: 'regexp',\n    value: route.re\n  });\n\n  if (route.keys.length) {\n    fields.push({\n      editable: false,\n      key: 'keys',\n      value: {\n        _custom: {\n          type: null,\n          readOnly: true,\n          display: route.keys.map(key => `${key.name}${modifierForKey(key)}`).join(' '),\n          tooltip: 'Param keys',\n          value: route.keys\n        }\n      }\n    });\n  }\n\n  if (record.redirect != null) {\n    fields.push({\n      editable: false,\n      key: 'redirect',\n      value: record.redirect\n    });\n  }\n\n  if (route.alias.length) {\n    fields.push({\n      editable: false,\n      key: 'aliases',\n      value: route.alias.map(alias => alias.record.path)\n    });\n  }\n\n  fields.push({\n    key: 'score',\n    editable: false,\n    value: {\n      _custom: {\n        type: null,\n        readOnly: true,\n        display: route.score.map(score => score.join(', ')).join(' | '),\n        tooltip: 'Score used to sort routes',\n        value: route.score\n      }\n    }\n  });\n  return fields;\n}\n/**\n * Extracted from tailwind palette\n */\n\n\nconst PINK_500 = 0xec4899;\nconst BLUE_600 = 0x2563eb;\nconst LIME_500 = 0x84cc16;\nconst CYAN_400 = 0x22d3ee;\nconst ORANGE_400 = 0xfb923c; // const GRAY_100 = 0xf4f4f5\n\nconst DARK = 0x666666;\n\nfunction formatRouteRecordForInspector(route) {\n  const tags = [];\n  const {\n    record\n  } = route;\n\n  if (record.name != null) {\n    tags.push({\n      label: String(record.name),\n      textColor: 0,\n      backgroundColor: CYAN_400\n    });\n  }\n\n  if (record.aliasOf) {\n    tags.push({\n      label: 'alias',\n      textColor: 0,\n      backgroundColor: ORANGE_400\n    });\n  }\n\n  if (route.__vd_match) {\n    tags.push({\n      label: 'matches',\n      textColor: 0,\n      backgroundColor: PINK_500\n    });\n  }\n\n  if (route.__vd_exactActive) {\n    tags.push({\n      label: 'exact',\n      textColor: 0,\n      backgroundColor: LIME_500\n    });\n  }\n\n  if (route.__vd_active) {\n    tags.push({\n      label: 'active',\n      textColor: 0,\n      backgroundColor: BLUE_600\n    });\n  }\n\n  if (record.redirect) {\n    tags.push({\n      label: 'redirect: ' + (typeof record.redirect === 'string' ? record.redirect : 'Object'),\n      textColor: 0xffffff,\n      backgroundColor: DARK\n    });\n  } // add an id to be able to select it. Using the `path` is not possible because\n  // empty path children would collide with their parents\n\n\n  let id = record.__vd_id;\n\n  if (id == null) {\n    id = String(routeRecordId++);\n    record.__vd_id = id;\n  }\n\n  return {\n    id,\n    label: record.path,\n    tags,\n    children: route.children.map(formatRouteRecordForInspector)\n  };\n} //  incremental id for route records and inspector state\n\n\nlet routeRecordId = 0;\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\n\nfunction markRouteRecordActive(route, currentRoute) {\n  // no route will be active if matched is empty\n  // reset the matching state\n  const isExactActive = currentRoute.matched.length && isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n  route.__vd_exactActive = route.__vd_active = isExactActive;\n\n  if (!isExactActive) {\n    route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\n  }\n\n  route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\n}\n\nfunction resetMatchStateOnRouteRecord(route) {\n  route.__vd_match = false;\n  route.children.forEach(resetMatchStateOnRouteRecord);\n}\n\nfunction isRouteMatching(route, filter) {\n  const found = String(route.re).match(EXTRACT_REGEXP_RE);\n  route.__vd_match = false;\n\n  if (!found || found.length < 3) {\n    return false;\n  } // use a regexp without $ at the end to match nested routes better\n\n\n  const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\n\n  if (nonEndingRE.test(filter)) {\n    // mark children as matches\n    route.children.forEach(child => isRouteMatching(child, filter)); // exception case: `/`\n\n    if (route.record.path !== '/' || filter === '/') {\n      route.__vd_match = route.re.test(filter);\n      return true;\n    } // hide the / route\n\n\n    return false;\n  }\n\n  const path = route.record.path.toLowerCase();\n  const decodedPath = decode(path); // also allow partial matching on the path\n\n  if (!filter.startsWith('/') && (decodedPath.includes(filter) || path.includes(filter))) return true;\n  if (decodedPath.startsWith(filter) || path.startsWith(filter)) return true;\n  if (route.record.name && String(route.record.name).includes(filter)) return true;\n  return route.children.some(child => isRouteMatching(child, filter));\n}\n\nfunction omit(obj, keys) {\n  const ret = {};\n\n  for (const key in obj) {\n    if (!keys.includes(key)) {\n      // @ts-expect-error\n      ret[key] = obj[key];\n    }\n  }\n\n  return ret;\n}\n/**\n * Creates a Router instance that can be used by a Vue app.\n *\n * @param options - {@link RouterOptions}\n */\n\n\nfunction createRouter(options) {\n  const matcher = createRouterMatcher(options.routes, options);\n  const parseQuery$1 = options.parseQuery || parseQuery;\n  const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n  const routerHistory = options.history;\n  if (process.env.NODE_ENV !== 'production' && !routerHistory) throw new Error('Provide the \"history\" option when calling \"createRouter()\":' + ' https://next.router.vuejs.org/api/#history.');\n  const beforeGuards = useCallbacks();\n  const beforeResolveGuards = useCallbacks();\n  const afterGuards = useCallbacks();\n  const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n  let pendingLocation = START_LOCATION_NORMALIZED; // leave the scrollRestoration if no scrollBehavior is provided\n\n  if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\n    history.scrollRestoration = 'manual';\n  }\n\n  const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\n  const encodeParams = applyToParams.bind(null, encodeParam);\n  const decodeParams = // @ts-expect-error: intentionally avoid the type check\n  applyToParams.bind(null, decode);\n\n  function addRoute(parentOrRoute, route) {\n    let parent;\n    let record;\n\n    if (isRouteName(parentOrRoute)) {\n      parent = matcher.getRecordMatcher(parentOrRoute);\n      record = route;\n    } else {\n      record = parentOrRoute;\n    }\n\n    return matcher.addRoute(record, parent);\n  }\n\n  function removeRoute(name) {\n    const recordMatcher = matcher.getRecordMatcher(name);\n\n    if (recordMatcher) {\n      matcher.removeRoute(recordMatcher);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn(`Cannot remove non-existent route \"${String(name)}\"`);\n    }\n  }\n\n  function getRoutes() {\n    return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\n  }\n\n  function hasRoute(name) {\n    return !!matcher.getRecordMatcher(name);\n  }\n\n  function resolve(rawLocation, currentLocation) {\n    // const objectLocation = routerLocationAsObject(rawLocation)\n    // we create a copy to modify it later\n    currentLocation = assign({}, currentLocation || currentRoute.value);\n\n    if (typeof rawLocation === 'string') {\n      const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n      const matchedRoute = matcher.resolve({\n        path: locationNormalized.path\n      }, currentLocation);\n      const href = routerHistory.createHref(locationNormalized.fullPath);\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (href.startsWith('//')) warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);else if (!matchedRoute.matched.length) {\n          warn(`No match found for location with path \"${rawLocation}\"`);\n        }\n      } // locationNormalized is always a new object\n\n\n      return assign(locationNormalized, matchedRoute, {\n        params: decodeParams(matchedRoute.params),\n        hash: decode(locationNormalized.hash),\n        redirectedFrom: undefined,\n        href\n      });\n    }\n\n    let matcherLocation; // path could be relative in object as well\n\n    if ('path' in rawLocation) {\n      if (process.env.NODE_ENV !== 'production' && 'params' in rawLocation && !('name' in rawLocation) && // @ts-expect-error: the type is never\n      Object.keys(rawLocation.params).length) {\n        warn(`Path \"${// @ts-expect-error: the type is never\n        rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\n      }\n\n      matcherLocation = assign({}, rawLocation, {\n        path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path\n      });\n    } else {\n      // remove any nullish param\n      const targetParams = assign({}, rawLocation.params);\n\n      for (const key in targetParams) {\n        if (targetParams[key] == null) {\n          delete targetParams[key];\n        }\n      } // pass encoded values to the matcher so it can produce encoded path and fullPath\n\n\n      matcherLocation = assign({}, rawLocation, {\n        params: encodeParams(rawLocation.params)\n      }); // current location params are decoded, we need to encode them in case the\n      // matcher merges the params\n\n      currentLocation.params = encodeParams(currentLocation.params);\n    }\n\n    const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n    const hash = rawLocation.hash || '';\n\n    if (process.env.NODE_ENV !== 'production' && hash && !hash.startsWith('#')) {\n      warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\n    } // decoding them) the matcher might have merged current location params so\n    // we need to run the decoding again\n\n\n    matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n    const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n      hash: encodeHash(hash),\n      path: matchedRoute.path\n    }));\n    const href = routerHistory.createHref(fullPath);\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (href.startsWith('//')) {\n        warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n      } else if (!matchedRoute.matched.length) {\n        warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\n      }\n    }\n\n    return assign({\n      fullPath,\n      // keep the hash encoded so fullPath is effectively path + encodedQuery +\n      // hash\n      hash,\n      query: // if the user is using a custom query lib like qs, we might have\n      // nested objects, so we keep the query as is, meaning it can contain\n      // numbers at `$route.query`, but at the point, the user will have to\n      // use their own type anyway.\n      // https://github.com/vuejs/router/issues/328#issuecomment-649481567\n      stringifyQuery$1 === stringifyQuery ? normalizeQuery(rawLocation.query) : rawLocation.query || {}\n    }, matchedRoute, {\n      redirectedFrom: undefined,\n      href\n    });\n  }\n\n  function locationAsObject(to) {\n    return typeof to === 'string' ? parseURL(parseQuery$1, to, currentRoute.value.path) : assign({}, to);\n  }\n\n  function checkCanceledNavigation(to, from) {\n    if (pendingLocation !== to) {\n      return createRouterError(8\n      /* NAVIGATION_CANCELLED */\n      , {\n        from,\n        to\n      });\n    }\n  }\n\n  function push(to) {\n    return pushWithRedirect(to);\n  }\n\n  function replace(to) {\n    return push(assign(locationAsObject(to), {\n      replace: true\n    }));\n  }\n\n  function handleRedirectRecord(to) {\n    const lastMatched = to.matched[to.matched.length - 1];\n\n    if (lastMatched && lastMatched.redirect) {\n      const {\n        redirect\n      } = lastMatched;\n      let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\n\n      if (typeof newTargetLocation === 'string') {\n        newTargetLocation = newTargetLocation.includes('?') || newTargetLocation.includes('#') ? newTargetLocation = locationAsObject(newTargetLocation) : // force empty params\n        {\n          path: newTargetLocation\n        }; // @ts-expect-error: force empty params when a string is passed to let\n        // the router parse them again\n\n        newTargetLocation.params = {};\n      }\n\n      if (process.env.NODE_ENV !== 'production' && !('path' in newTargetLocation) && !('name' in newTargetLocation)) {\n        warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\n        throw new Error('Invalid redirect');\n      }\n\n      return assign({\n        query: to.query,\n        hash: to.hash,\n        params: to.params\n      }, newTargetLocation);\n    }\n  }\n\n  function pushWithRedirect(to, redirectedFrom) {\n    const targetLocation = pendingLocation = resolve(to);\n    const from = currentRoute.value;\n    const data = to.state;\n    const force = to.force; // to could be a string where `replace` is a function\n\n    const replace = to.replace === true;\n    const shouldRedirect = handleRedirectRecord(targetLocation);\n    if (shouldRedirect) return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\n      state: data,\n      force,\n      replace\n    }), // keep original redirectedFrom if it exists\n    redirectedFrom || targetLocation); // if it was a redirect we already called `pushWithRedirect` above\n\n    const toLocation = targetLocation;\n    toLocation.redirectedFrom = redirectedFrom;\n    let failure;\n\n    if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n      failure = createRouterError(16\n      /* NAVIGATION_DUPLICATED */\n      , {\n        to: toLocation,\n        from\n      }); // trigger scroll to allow scrolling to the same anchor\n\n      handleScroll(from, from, // this is a push, the only way for it to be triggered from a\n      // history.listen is with a redirect, which makes it become a push\n      true, // This cannot be the first navigation because the initial location\n      // cannot be manually navigated to\n      false);\n    }\n\n    return (failure ? Promise.resolve(failure) : navigate(toLocation, from)).catch(error => isNavigationFailure(error) ? // navigation redirects still mark the router as ready\n    isNavigationFailure(error, 2\n    /* NAVIGATION_GUARD_REDIRECT */\n    ) ? error : markAsReady(error) // also returns the error\n    : // reject any unknown error\n    triggerError(error, toLocation, from)).then(failure => {\n      if (failure) {\n        if (isNavigationFailure(failure, 2\n        /* NAVIGATION_GUARD_REDIRECT */\n        )) {\n          if (process.env.NODE_ENV !== 'production' && // we are redirecting to the same location we were already at\n          isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) && // and we have done it a couple of times\n          redirectedFrom && // @ts-expect-error: added only in dev\n          (redirectedFrom._count = redirectedFrom._count ? // @ts-expect-error\n          redirectedFrom._count + 1 : 1) > 10) {\n            warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\n            return Promise.reject(new Error('Infinite redirect in navigation guard'));\n          }\n\n          return pushWithRedirect( // keep options\n          assign(locationAsObject(failure.to), {\n            state: data,\n            force,\n            replace\n          }), // preserve the original redirectedFrom if any\n          redirectedFrom || toLocation);\n        }\n      } else {\n        // if we fail we don't finalize the navigation\n        failure = finalizeNavigation(toLocation, from, true, replace, data);\n      }\n\n      triggerAfterEach(toLocation, from, failure);\n      return failure;\n    });\n  }\n  /**\n   * Helper to reject and skip all navigation guards if a new navigation happened\n   * @param to\n   * @param from\n   */\n\n\n  function checkCanceledNavigationAndReject(to, from) {\n    const error = checkCanceledNavigation(to, from);\n    return error ? Promise.reject(error) : Promise.resolve();\n  } // TODO: refactor the whole before guards by internally using router.beforeEach\n\n\n  function navigate(to, from) {\n    let guards;\n    const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from); // all components here have been resolved once because we are leaving\n\n    guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from); // leavingRecords is already reversed\n\n    for (const record of leavingRecords) {\n      record.leaveGuards.forEach(guard => {\n        guards.push(guardToPromiseFn(guard, to, from));\n      });\n    }\n\n    const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n    guards.push(canceledNavigationCheck); // run the queue of per route beforeRouteLeave guards\n\n    return runGuardQueue(guards).then(() => {\n      // check global guards beforeEach\n      guards = [];\n\n      for (const guard of beforeGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check in components beforeRouteUpdate\n      guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\n\n      for (const record of updatingRecords) {\n        record.updateGuards.forEach(guard => {\n          guards.push(guardToPromiseFn(guard, to, from));\n        });\n      }\n\n      guards.push(canceledNavigationCheck); // run the queue of per route beforeEnter guards\n\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check the route beforeEnter\n      guards = [];\n\n      for (const record of to.matched) {\n        // do not trigger beforeEnter on reused views\n        if (record.beforeEnter && !from.matched.includes(record)) {\n          if (Array.isArray(record.beforeEnter)) {\n            for (const beforeEnter of record.beforeEnter) guards.push(guardToPromiseFn(beforeEnter, to, from));\n          } else {\n            guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n          }\n        }\n      }\n\n      guards.push(canceledNavigationCheck); // run the queue of per route beforeEnter guards\n\n      return runGuardQueue(guards);\n    }).then(() => {\n      // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\n      // clear existing enterCallbacks, these are added by extractComponentsGuards\n      to.matched.forEach(record => record.enterCallbacks = {}); // check in-component beforeRouteEnter\n\n      guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\n      guards.push(canceledNavigationCheck); // run the queue of per route beforeEnter guards\n\n      return runGuardQueue(guards);\n    }).then(() => {\n      // check global guards beforeResolve\n      guards = [];\n\n      for (const guard of beforeResolveGuards.list()) {\n        guards.push(guardToPromiseFn(guard, to, from));\n      }\n\n      guards.push(canceledNavigationCheck);\n      return runGuardQueue(guards);\n    }) // catch any navigation canceled\n    .catch(err => isNavigationFailure(err, 8\n    /* NAVIGATION_CANCELLED */\n    ) ? err : Promise.reject(err));\n  }\n\n  function triggerAfterEach(to, from, failure) {\n    // navigation is confirmed, call afterGuards\n    // TODO: wrap with error handlers\n    for (const guard of afterGuards.list()) guard(to, from, failure);\n  }\n  /**\n   * - Cleans up any navigation guards\n   * - Changes the url if necessary\n   * - Calls the scrollBehavior\n   */\n\n\n  function finalizeNavigation(toLocation, from, isPush, replace, data) {\n    // a more recent navigation took place\n    const error = checkCanceledNavigation(toLocation, from);\n    if (error) return error; // only consider as push if it's not the first navigation\n\n    const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n    const state = !isBrowser ? {} : history.state; // change URL only if the user did a push/replace and if it's not the initial navigation because\n    // it's just reflecting the url\n\n    if (isPush) {\n      // on the initial navigation, we want to reuse the scroll position from\n      // history state if it exists\n      if (replace || isFirstNavigation) routerHistory.replace(toLocation.fullPath, assign({\n        scroll: isFirstNavigation && state && state.scroll\n      }, data));else routerHistory.push(toLocation.fullPath, data);\n    } // accept current navigation\n\n\n    currentRoute.value = toLocation;\n    handleScroll(toLocation, from, isPush, isFirstNavigation);\n    markAsReady();\n  }\n\n  let removeHistoryListener; // attach listener to history to trigger navigations\n\n  function setupListeners() {\n    removeHistoryListener = routerHistory.listen((to, _from, info) => {\n      // cannot be a redirect route because it was in history\n      const toLocation = resolve(to); // due to dynamic routing, and to hash history with manual navigation\n      // (manually changing the url or calling history.hash = '#/somewhere'),\n      // there could be a redirect record in history\n\n      const shouldRedirect = handleRedirectRecord(toLocation);\n\n      if (shouldRedirect) {\n        pushWithRedirect(assign(shouldRedirect, {\n          replace: true\n        }), toLocation).catch(noop);\n        return;\n      }\n\n      pendingLocation = toLocation;\n      const from = currentRoute.value; // TODO: should be moved to web history?\n\n      if (isBrowser) {\n        saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n      }\n\n      navigate(toLocation, from).catch(error => {\n        if (isNavigationFailure(error, 4\n        /* NAVIGATION_ABORTED */\n        | 8\n        /* NAVIGATION_CANCELLED */\n        )) {\n          return error;\n        }\n\n        if (isNavigationFailure(error, 2\n        /* NAVIGATION_GUARD_REDIRECT */\n        )) {\n          // Here we could call if (info.delta) routerHistory.go(-info.delta,\n          // false) but this is bug prone as we have no way to wait the\n          // navigation to be finished before calling pushWithRedirect. Using\n          // a setTimeout of 16ms seems to work but there is not guarantee for\n          // it to work on every browser. So Instead we do not restore the\n          // history entry and trigger a new navigation as requested by the\n          // navigation guard.\n          // the error is already handled by router.push we just want to avoid\n          // logging the error\n          pushWithRedirect(error.to, toLocation // avoid an uncaught rejection, let push call triggerError\n          ).then(failure => {\n            // manual change in hash history #916 ending up in the URL not\n            // changing but it was changed by the manual url change, so we\n            // need to manually change it ourselves\n            if (isNavigationFailure(failure, 4\n            /* NAVIGATION_ABORTED */\n            | 16\n            /* NAVIGATION_DUPLICATED */\n            ) && !info.delta && info.type === NavigationType.pop) {\n              routerHistory.go(-1, false);\n            }\n          }).catch(noop); // avoid the then branch\n\n          return Promise.reject();\n        } // do not restore history on unknown direction\n\n\n        if (info.delta) routerHistory.go(-info.delta, false); // unrecognized error, transfer to the global handler\n\n        return triggerError(error, toLocation, from);\n      }).then(failure => {\n        failure = failure || finalizeNavigation( // after navigation, all matched components are resolved\n        toLocation, from, false); // revert the navigation\n\n        if (failure) {\n          if (info.delta) {\n            routerHistory.go(-info.delta, false);\n          } else if (info.type === NavigationType.pop && isNavigationFailure(failure, 4\n          /* NAVIGATION_ABORTED */\n          | 16\n          /* NAVIGATION_DUPLICATED */\n          )) {\n            // manual change in hash history #916\n            // it's like a push but lacks the information of the direction\n            routerHistory.go(-1, false);\n          }\n        }\n\n        triggerAfterEach(toLocation, from, failure);\n      }).catch(noop);\n    });\n  } // Initialization and Errors\n\n\n  let readyHandlers = useCallbacks();\n  let errorHandlers = useCallbacks();\n  let ready;\n  /**\n   * Trigger errorHandlers added via onError and throws the error as well\n   *\n   * @param error - error to throw\n   * @param to - location we were navigating to when the error happened\n   * @param from - location we were navigating from when the error happened\n   * @returns the error as a rejected promise\n   */\n\n  function triggerError(error, to, from) {\n    markAsReady(error);\n    const list = errorHandlers.list();\n\n    if (list.length) {\n      list.forEach(handler => handler(error, to, from));\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        warn('uncaught error during route navigation:');\n      }\n\n      console.error(error);\n    }\n\n    return Promise.reject(error);\n  }\n\n  function isReady() {\n    if (ready && currentRoute.value !== START_LOCATION_NORMALIZED) return Promise.resolve();\n    return new Promise((resolve, reject) => {\n      readyHandlers.add([resolve, reject]);\n    });\n  }\n\n  function markAsReady(err) {\n    if (!ready) {\n      // still not ready if an error happened\n      ready = !err;\n      setupListeners();\n      readyHandlers.list().forEach(([resolve, reject]) => err ? reject(err) : resolve());\n      readyHandlers.reset();\n    }\n\n    return err;\n  } // Scroll behavior\n\n\n  function handleScroll(to, from, isPush, isFirstNavigation) {\n    const {\n      scrollBehavior\n    } = options;\n    if (!isBrowser || !scrollBehavior) return Promise.resolve();\n    const scrollPosition = !isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0)) || (isFirstNavigation || !isPush) && history.state && history.state.scroll || null;\n    return nextTick().then(() => scrollBehavior(to, from, scrollPosition)).then(position => position && scrollToPosition(position)).catch(err => triggerError(err, to, from));\n  }\n\n  const go = delta => routerHistory.go(delta);\n\n  let started;\n  const installedApps = new Set();\n  const router = {\n    currentRoute,\n    addRoute,\n    removeRoute,\n    hasRoute,\n    getRoutes,\n    resolve,\n    options,\n    push,\n    replace,\n    go,\n    back: () => go(-1),\n    forward: () => go(1),\n    beforeEach: beforeGuards.add,\n    beforeResolve: beforeResolveGuards.add,\n    afterEach: afterGuards.add,\n    onError: errorHandlers.add,\n    isReady,\n\n    install(app) {\n      const router = this;\n      app.component('RouterLink', RouterLink);\n      app.component('RouterView', RouterView);\n      app.config.globalProperties.$router = router;\n      Object.defineProperty(app.config.globalProperties, '$route', {\n        enumerable: true,\n        get: () => unref(currentRoute)\n      }); // this initial navigation is only necessary on client, on server it doesn't\n      // make sense because it will create an extra unnecessary navigation and could\n      // lead to problems\n\n      if (isBrowser && // used for the initial navigation client side to avoid pushing\n      // multiple times when the router is used in multiple apps\n      !started && currentRoute.value === START_LOCATION_NORMALIZED) {\n        // see above\n        started = true;\n        push(routerHistory.location).catch(err => {\n          if (process.env.NODE_ENV !== 'production') warn('Unexpected error when starting the router:', err);\n        });\n      }\n\n      const reactiveRoute = {};\n\n      for (const key in START_LOCATION_NORMALIZED) {\n        // @ts-expect-error: the key matches\n        reactiveRoute[key] = computed(() => currentRoute.value[key]);\n      }\n\n      app.provide(routerKey, router);\n      app.provide(routeLocationKey, reactive(reactiveRoute));\n      app.provide(routerViewLocationKey, currentRoute);\n      const unmountApp = app.unmount;\n      installedApps.add(app);\n\n      app.unmount = function () {\n        installedApps.delete(app); // the router is not attached to an app anymore\n\n        if (installedApps.size < 1) {\n          // invalidate the current navigation\n          pendingLocation = START_LOCATION_NORMALIZED;\n          removeHistoryListener && removeHistoryListener();\n          currentRoute.value = START_LOCATION_NORMALIZED;\n          started = false;\n          ready = false;\n        }\n\n        unmountApp();\n      };\n\n      if ((process.env.NODE_ENV !== 'production' || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n        addDevtools(app, router, matcher);\n      }\n    }\n\n  };\n  return router;\n}\n\nfunction runGuardQueue(guards) {\n  return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\n}\n\nfunction extractChangingRecords(to, from) {\n  const leavingRecords = [];\n  const updatingRecords = [];\n  const enteringRecords = [];\n  const len = Math.max(from.matched.length, to.matched.length);\n\n  for (let i = 0; i < len; i++) {\n    const recordFrom = from.matched[i];\n\n    if (recordFrom) {\n      if (to.matched.find(record => isSameRouteRecord(record, recordFrom))) updatingRecords.push(recordFrom);else leavingRecords.push(recordFrom);\n    }\n\n    const recordTo = to.matched[i];\n\n    if (recordTo) {\n      // the type doesn't matter because we are comparing per reference\n      if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\n        enteringRecords.push(recordTo);\n      }\n    }\n  }\n\n  return [leavingRecords, updatingRecords, enteringRecords];\n}\n/**\n * Returns the router instance. Equivalent to using `$router` inside\n * templates.\n */\n\n\nfunction useRouter() {\n  return inject(routerKey);\n}\n/**\n * Returns the current route location. Equivalent to using `$route` inside\n * templates.\n */\n\n\nfunction useRoute() {\n  return inject(routeLocationKey);\n}\n\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };","map":{"version":3,"names":["getCurrentInstance","inject","onUnmounted","onDeactivated","onActivated","computed","unref","watchEffect","defineComponent","reactive","h","provide","ref","watch","shallowRef","nextTick","setupDevtoolsPlugin","hasSymbol","Symbol","toStringTag","PolySymbol","name","process","env","NODE_ENV","matchedRouteKey","viewDepthKey","routerKey","routeLocationKey","routerViewLocationKey","isBrowser","window","isESModule","obj","__esModule","assign","Object","applyToParams","fn","params","newParams","key","value","Array","isArray","map","noop","warn","msg","args","from","arguments","slice","console","apply","concat","TRAILING_SLASH_RE","removeTrailingSlash","path","replace","parseURL","parseQuery","location","currentLocation","query","searchString","hash","searchPos","indexOf","hashPos","length","resolveRelativePath","fullPath","stringifyURL","stringifyQuery","stripBase","pathname","base","toLowerCase","startsWith","isSameRouteLocation","a","b","aLastIndex","matched","bLastIndex","isSameRouteRecord","isSameRouteLocationParams","aliasOf","keys","isSameRouteLocationParamsValue","isEquivalentArray","every","i","to","fromSegments","split","toSegments","position","toPosition","segment","join","NavigationType","NavigationDirection","START","normalizeBase","baseEl","document","querySelector","getAttribute","BEFORE_HASH_RE","createHref","getElementPosition","el","offset","docRect","documentElement","getBoundingClientRect","elRect","behavior","left","top","computeScrollPosition","pageXOffset","pageYOffset","scrollToPosition","scrollToOptions","positionEl","isIdSelector","getElementById","foundEl","err","style","scrollTo","getScrollKey","delta","history","state","scrollPositions","Map","saveScrollPosition","scrollPosition","set","getSavedScrollPosition","scroll","get","delete","createBaseLocation","protocol","host","createCurrentLocation","search","slicePos","includes","pathFromHash","useHistoryListeners","historyState","listeners","teardowns","pauseState","popStateHandler","fromState","forEach","listener","type","pop","direction","forward","back","unknown","pauseListeners","listen","callback","push","teardown","index","splice","beforeUnloadListener","replaceState","destroy","removeEventListener","addEventListener","buildState","current","replaced","computeScroll","useHistoryStateNavigation","changeLocation","hashIndex","url","error","data","currentState","createWebHistory","historyNavigation","historyListeners","go","triggerListeners","routerHistory","bind","defineProperty","enumerable","createMemoryHistory","queue","setLocation","info","shouldTrigger","Math","max","min","createWebHashHistory","endsWith","isRouteLocation","route","isRouteName","START_LOCATION_NORMALIZED","undefined","meta","redirectedFrom","NavigationFailureSymbol","NavigationFailureType","ErrorTypeMessages","JSON","stringify","stringifyRoute","createRouterError","Error","isNavigationFailure","propertiesToLog","BASE_PARAM_PATTERN","BASE_PATH_PARSER_OPTIONS","sensitive","strict","start","end","REGEX_CHARS_RE","tokensToParser","segments","extraOptions","options","score","pattern","segmentScores","tokenIndex","token","subSegmentScore","repeatable","optional","regexp","re","RegExp","message","subPattern","parse","match","avoidDuplicatedSlash","param","text","compareScoreArray","diff","comparePathParserScore","aScore","bScore","comp","ROOT_TOKEN","VALID_PARAM_RE","tokenizePath","crash","buffer","previousState","tokens","finalizeSegment","char","customRe","consumeBuffer","addCharToBuffer","test","createRouteRecordMatcher","record","parent","parser","existingKeys","Set","has","add","matcher","children","alias","createRouterMatcher","routes","globalOptions","matchers","matcherMap","mergeOptions","getRecordMatcher","addRoute","originalRecord","isRootAdd","mainNormalizedRecord","normalizeRouteRecord","normalizedRecords","aliases","components","originalMatcher","normalizedRecord","parentPath","connectingSlash","checkMissingParamsInAbsolutePath","checkSameParams","isAliasRecord","removeRoute","insertMatcher","matcherRef","getRoutes","isRecordChildOf","resolve","paramsFromLocation","filter","k","find","m","parentMatcher","unshift","mergeMetaFields","redirect","beforeEnter","props","normalizeRecordProps","instances","leaveGuards","updateGuards","enterCallbacks","default","component","propsObject","reduce","defaults","partialOptions","isSameParam","some","child","HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","IM_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","commonEncode","encodeURI","encodeHash","encodeQueryValue","encodeQueryKey","encodePath","encodeParam","decode","decodeURIComponent","hasLeadingIM","searchParams","searchParam","eqPos","currentValue","values","v","normalizeQuery","normalizedQuery","useCallbacks","handlers","handler","reset","list","registerGuard","guard","removeFromList","onBeforeRouteLeave","leaveGuard","activeRecord","onBeforeRouteUpdate","updateGuard","guardToPromiseFn","enterCallbackArray","Promise","reject","next","valid","guardReturn","call","canOnlyBeCalledOnce","guardCall","then","toString","resolvedValue","_called","catch","called","extractComponentsGuards","guardType","guards","rawComponent","String","promise","__asyncLoader","__warnedDefineAsync","isRouteComponent","__vccOpts","componentPromise","resolved","resolvedComponent","useLink","router","currentRoute","activeRecordIndex","routeMatched","currentMatched","findIndex","parentRecordPath","getOriginalPath","isActive","includesParams","isExactActive","navigate","e","guardEvent","__VUE_PROD_DEVTOOLS__","instance","linkContextDevtools","__vrl_devtools","flush","href","RouterLinkImpl","required","Boolean","activeClass","exactActiveClass","custom","ariaCurrentValue","setup","slots","link","elClass","getLinkClass","linkActiveClass","linkExactActiveClass","onClick","class","RouterLink","metaKey","altKey","ctrlKey","shiftKey","defaultPrevented","button","currentTarget","target","preventDefault","outer","inner","innerValue","outerValue","propClass","globalClass","defaultClass","RouterViewImpl","inheritAttrs","attrs","warnDeprecatedUsage","injectedRoute","routeToDisplay","depth","matchedRouteRef","viewRef","oldInstance","oldName","size","matchedRoute","ViewComponent","currentName","normalizeSlot","Component","routePropsOption","routeProps","onVnodeUnmounted","vnode","isUnmounted","internalInstances","r","__vrv_devtools","slot","slotContent","RouterView","parentName","formatRouteLocation","routeLocation","tooltip","copy","omit","_custom","readOnly","display","formatDisplay","routerId","addDevtools","app","__hasDevtools","id","label","packageName","homepage","logo","componentStateTypes","api","on","inspectComponent","payload","ctx","instanceData","editable","visitComponentTree","treeNode","node","componentInstance","tags","textColor","backgroundColor","PINK_500","__devtoolsApi","devtoolsData","ORANGE_400","LIME_500","BLUE_600","refreshRoutesView","notifyComponentUpdate","sendInspectorTree","routerInspectorId","sendInspectorState","navigationsLayerId","addTimelineLayer","color","onError","addTimelineEvent","layerId","event","title","subtitle","logType","time","Date","now","groupId","__navigationId","navigationId","beforeEach","afterEach","failure","status","addInspector","icon","treeFilterPlaceholder","activeRoutesPayload","resetMatchStateOnRouteRecord","isRouteMatching","markRouteRecordActive","rootNodes","formatRouteRecordForInspector","getInspectorTree","inspectorId","getInspectorState","__vd_id","nodeId","formatRouteRecordMatcherForStateInspector","modifierForKey","fields","CYAN_400","DARK","__vd_match","__vd_exactActive","__vd_active","routeRecordId","EXTRACT_REGEXP_RE","childRoute","found","nonEndingRE","decodedPath","ret","createRouter","parseQuery$1","stringifyQuery$1","beforeGuards","beforeResolveGuards","afterGuards","pendingLocation","scrollBehavior","scrollRestoration","normalizeParams","paramValue","encodeParams","decodeParams","parentOrRoute","recordMatcher","routeMatcher","hasRoute","rawLocation","locationNormalized","matcherLocation","targetParams","locationAsObject","checkCanceledNavigation","pushWithRedirect","handleRedirectRecord","lastMatched","newTargetLocation","targetLocation","force","shouldRedirect","toLocation","handleScroll","markAsReady","triggerError","_count","finalizeNavigation","triggerAfterEach","checkCanceledNavigationAndReject","leavingRecords","updatingRecords","enteringRecords","extractChangingRecords","reverse","canceledNavigationCheck","runGuardQueue","isPush","isFirstNavigation","removeHistoryListener","setupListeners","_from","readyHandlers","errorHandlers","ready","isReady","started","installedApps","beforeResolve","install","config","globalProperties","$router","reactiveRoute","unmountApp","unmount","len","recordFrom","recordTo","useRouter","useRoute","START_LOCATION"],"sources":["/Users/jh/Workspace/vue/vue-practice/node_modules/vue-router/dist/vue-router.esm-bundler.js"],"sourcesContent":["/*!\n  * vue-router v4.0.13\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, onUnmounted, onDeactivated, onActivated, computed, unref, watchEffect, defineComponent, reactive, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\nconst PolySymbol = (name) => \n// vr = vue router\nhasSymbol\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' + name : name)\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' : '_vr_') + name;\n// rvlm = Router View Location Matched\n/**\n * RouteRecord being rendered by the closest ancestor Router View. Used for\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\n * Location Matched\n *\n * @internal\n */\nconst matchedRouteKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location matched' : 'rvlm');\n/**\n * Allows overriding the router view depth to control which component in\n * `matched` is rendered. rvd stands for Router View Depth\n *\n * @internal\n */\nconst viewDepthKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view depth' : 'rvd');\n/**\n * Allows overriding the router instance returned by `useRouter` in tests. r\n * stands for router\n *\n * @internal\n */\nconst routerKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router' : 'r');\n/**\n * Allows overriding the current route returned by `useRoute` in tests. rl\n * stands for route location\n *\n * @internal\n */\nconst routeLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'route location' : 'rl');\n/**\n * Allows overriding the current route used by router-view. Internally this is\n * used when the `route` prop is passed.\n *\n * @internal\n */\nconst routerViewLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location' : 'rvl');\n\nconst isBrowser = typeof window !== 'undefined';\n\nfunction isESModule(obj) {\n    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');\n}\nconst assign = Object.assign;\nfunction applyToParams(fn, params) {\n    const newParams = {};\n    for (const key in params) {\n        const value = params[key];\n        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\n    }\n    return newParams;\n}\nconst noop = () => { };\n\nfunction warn(msg) {\n    // avoid using ...args as it breaks in older Edge builds\n    const args = Array.from(arguments).slice(1);\n    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');\n/**\n * Transforms an URI into a normalized history location\n *\n * @param parseQuery\n * @param location - URI to normalize\n * @param currentLocation - current absolute location. Allows resolving relative\n * paths. Must start with `/`. Defaults to `/`\n * @returns a normalized history location\n */\nfunction parseURL(parseQuery, location, currentLocation = '/') {\n    let path, query = {}, searchString = '', hash = '';\n    // Could use URL and URLSearchParams but IE 11 doesn't support it\n    const searchPos = location.indexOf('?');\n    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\n    if (searchPos > -1) {\n        path = location.slice(0, searchPos);\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\n        query = parseQuery(searchString);\n    }\n    if (hashPos > -1) {\n        path = path || location.slice(0, hashPos);\n        // keep the # character\n        hash = location.slice(hashPos, location.length);\n    }\n    // no search and no query\n    path = resolveRelativePath(path != null ? path : location, currentLocation);\n    // empty path means a relative query or hash `?foo=f`, `#thing`\n    return {\n        fullPath: path + (searchString && '?') + searchString + hash,\n        path,\n        query,\n        hash,\n    };\n}\n/**\n * Stringifies a URL object\n *\n * @param stringifyQuery\n * @param location\n */\nfunction stringifyURL(stringifyQuery, location) {\n    const query = location.query ? stringifyQuery(location.query) : '';\n    return location.path + (query && '?') + query + (location.hash || '');\n}\n/**\n * Strips off the base from the beginning of a location.pathname in a non\n * case-sensitive way.\n *\n * @param pathname - location.pathname\n * @param base - base to strip off\n */\nfunction stripBase(pathname, base) {\n    // no base or base is not found at the beginning\n    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))\n        return pathname;\n    return pathname.slice(base.length) || '/';\n}\n/**\n * Checks if two RouteLocation are equal. This means that both locations are\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\n * parameters and `hash` are the same\n *\n * @param a - first {@link RouteLocation}\n * @param b - second {@link RouteLocation}\n */\nfunction isSameRouteLocation(stringifyQuery, a, b) {\n    const aLastIndex = a.matched.length - 1;\n    const bLastIndex = b.matched.length - 1;\n    return (aLastIndex > -1 &&\n        aLastIndex === bLastIndex &&\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\n        isSameRouteLocationParams(a.params, b.params) &&\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\n        a.hash === b.hash);\n}\n/**\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\n * considered equal to the `RouteRecord` they are aliasing.\n *\n * @param a - first {@link RouteRecord}\n * @param b - second {@link RouteRecord}\n */\nfunction isSameRouteRecord(a, b) {\n    // since the original record has an undefined value for aliasOf\n    // but all aliases point to the original record, this will always compare\n    // the original record\n    return (a.aliasOf || a) === (b.aliasOf || b);\n}\nfunction isSameRouteLocationParams(a, b) {\n    if (Object.keys(a).length !== Object.keys(b).length)\n        return false;\n    for (const key in a) {\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\n            return false;\n    }\n    return true;\n}\nfunction isSameRouteLocationParamsValue(a, b) {\n    return Array.isArray(a)\n        ? isEquivalentArray(a, b)\n        : Array.isArray(b)\n            ? isEquivalentArray(b, a)\n            : a === b;\n}\n/**\n * Check if two arrays are the same or if an array with one single entry is the\n * same as another primitive value. Used to check query and parameters\n *\n * @param a - array of values\n * @param b - array of values or a single value\n */\nfunction isEquivalentArray(a, b) {\n    return Array.isArray(b)\n        ? a.length === b.length && a.every((value, i) => value === b[i])\n        : a.length === 1 && a[0] === b;\n}\n/**\n * Resolves a relative path that starts with `.`.\n *\n * @param to - path location we are resolving\n * @param from - currentLocation.path, should start with `/`\n */\nfunction resolveRelativePath(to, from) {\n    if (to.startsWith('/'))\n        return to;\n    if ((process.env.NODE_ENV !== 'production') && !from.startsWith('/')) {\n        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\n        return to;\n    }\n    if (!to)\n        return from;\n    const fromSegments = from.split('/');\n    const toSegments = to.split('/');\n    let position = fromSegments.length - 1;\n    let toPosition;\n    let segment;\n    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\n        segment = toSegments[toPosition];\n        // can't go below zero\n        if (position === 1 || segment === '.')\n            continue;\n        if (segment === '..')\n            position--;\n        // found something that is not relative path\n        else\n            break;\n    }\n    return (fromSegments.slice(0, position).join('/') +\n        '/' +\n        toSegments\n            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))\n            .join('/'));\n}\n\nvar NavigationType;\n(function (NavigationType) {\n    NavigationType[\"pop\"] = \"pop\";\n    NavigationType[\"push\"] = \"push\";\n})(NavigationType || (NavigationType = {}));\nvar NavigationDirection;\n(function (NavigationDirection) {\n    NavigationDirection[\"back\"] = \"back\";\n    NavigationDirection[\"forward\"] = \"forward\";\n    NavigationDirection[\"unknown\"] = \"\";\n})(NavigationDirection || (NavigationDirection = {}));\n/**\n * Starting location for Histories\n */\nconst START = '';\n// Generic utils\n/**\n * Normalizes a base by removing any trailing slash and reading the base tag if\n * present.\n *\n * @param base - base to normalize\n */\nfunction normalizeBase(base) {\n    if (!base) {\n        if (isBrowser) {\n            // respect <base> tag\n            const baseEl = document.querySelector('base');\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\n            // strip full URL origin\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\n        }\n        else {\n            base = '/';\n        }\n    }\n    // ensure leading slash when it was removed by the regex above avoid leading\n    // slash with hash because the file could be read from the disk like file://\n    // and the leading slash would cause problems\n    if (base[0] !== '/' && base[0] !== '#')\n        base = '/' + base;\n    // remove the trailing slash so all other method can just do `base + fullPath`\n    // to build an href\n    return removeTrailingSlash(base);\n}\n// remove any character before the hash\nconst BEFORE_HASH_RE = /^[^#]+#/;\nfunction createHref(base, location) {\n    return base.replace(BEFORE_HASH_RE, '#') + location;\n}\n\nfunction getElementPosition(el, offset) {\n    const docRect = document.documentElement.getBoundingClientRect();\n    const elRect = el.getBoundingClientRect();\n    return {\n        behavior: offset.behavior,\n        left: elRect.left - docRect.left - (offset.left || 0),\n        top: elRect.top - docRect.top - (offset.top || 0),\n    };\n}\nconst computeScrollPosition = () => ({\n    left: window.pageXOffset,\n    top: window.pageYOffset,\n});\nfunction scrollToPosition(position) {\n    let scrollToOptions;\n    if ('el' in position) {\n        const positionEl = position.el;\n        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\n        /**\n         * `id`s can accept pretty much any characters, including CSS combinators\n         * like `>` or `~`. It's still possible to retrieve elements using\n         * `document.getElementById('~')` but it needs to be escaped when using\n         * `document.querySelector('#\\\\~')` for it to be valid. The only\n         * requirements for `id`s are them to be unique on the page and to not be\n         * empty (`id=\"\"`). Because of that, when passing an id selector, it should\n         * be properly escaped for it to work with `querySelector`. We could check\n         * for the id selector to be simple (no CSS combinators `+ >~`) but that\n         * would make things inconsistent since they are valid characters for an\n         * `id` but would need to be escaped when using `querySelector`, breaking\n         * their usage and ending up in no selector returned. Selectors need to be\n         * escaped:\n         *\n         * - `#1-thing` becomes `#\\31 -thing`\n         * - `#with~symbols` becomes `#with\\\\~symbols`\n         *\n         * - More information about  the topic can be found at\n         *   https://mathiasbynens.be/notes/html5-id-class.\n         * - Practical example: https://mathiasbynens.be/demo/html5-id\n         */\n        if ((process.env.NODE_ENV !== 'production') && typeof position.el === 'string') {\n            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\n                try {\n                    const foundEl = document.querySelector(position.el);\n                    if (isIdSelector && foundEl) {\n                        warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\n                        // return to avoid other warnings\n                        return;\n                    }\n                }\n                catch (err) {\n                    warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\n                    // return to avoid other warnings\n                    return;\n                }\n            }\n        }\n        const el = typeof positionEl === 'string'\n            ? isIdSelector\n                ? document.getElementById(positionEl.slice(1))\n                : document.querySelector(positionEl)\n            : positionEl;\n        if (!el) {\n            (process.env.NODE_ENV !== 'production') &&\n                warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\n            return;\n        }\n        scrollToOptions = getElementPosition(el, position);\n    }\n    else {\n        scrollToOptions = position;\n    }\n    if ('scrollBehavior' in document.documentElement.style)\n        window.scrollTo(scrollToOptions);\n    else {\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\n    }\n}\nfunction getScrollKey(path, delta) {\n    const position = history.state ? history.state.position - delta : -1;\n    return position + path;\n}\nconst scrollPositions = new Map();\nfunction saveScrollPosition(key, scrollPosition) {\n    scrollPositions.set(key, scrollPosition);\n}\nfunction getSavedScrollPosition(key) {\n    const scroll = scrollPositions.get(key);\n    // consume it so it's not used again\n    scrollPositions.delete(key);\n    return scroll;\n}\n// TODO: RFC about how to save scroll position\n/**\n * ScrollBehavior instance used by the router to compute and restore the scroll\n * position when navigating.\n */\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\n//   // returns a scroll position that can be saved in history\n//   compute(): ScrollPositionEntry\n//   // can take an extended ScrollPositionEntry\n//   scroll(position: ScrollPosition): void\n// }\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\n//   compute: computeScroll,\n//   scroll: scrollToPosition,\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\n/**\n * Creates a normalized history location from a window.location object\n * @param location -\n */\nfunction createCurrentLocation(base, location) {\n    const { pathname, search, hash } = location;\n    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end\n    const hashPos = base.indexOf('#');\n    if (hashPos > -1) {\n        let slicePos = hash.includes(base.slice(hashPos))\n            ? base.slice(hashPos).length\n            : 1;\n        let pathFromHash = hash.slice(slicePos);\n        // prepend the starting slash to hash so the url starts with /#\n        if (pathFromHash[0] !== '/')\n            pathFromHash = '/' + pathFromHash;\n        return stripBase(pathFromHash, '');\n    }\n    const path = stripBase(pathname, base);\n    return path + search + hash;\n}\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\n    let listeners = [];\n    let teardowns = [];\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\n    // can trigger twice\n    let pauseState = null;\n    const popStateHandler = ({ state, }) => {\n        const to = createCurrentLocation(base, location);\n        const from = currentLocation.value;\n        const fromState = historyState.value;\n        let delta = 0;\n        if (state) {\n            currentLocation.value = to;\n            historyState.value = state;\n            // ignore the popstate and reset the pauseState\n            if (pauseState && pauseState === from) {\n                pauseState = null;\n                return;\n            }\n            delta = fromState ? state.position - fromState.position : 0;\n        }\n        else {\n            replace(to);\n        }\n        // console.log({ deltaFromCurrent })\n        // Here we could also revert the navigation by calling history.go(-delta)\n        // this listener will have to be adapted to not trigger again and to wait for the url\n        // to be updated before triggering the listeners. Some kind of validation function would also\n        // need to be passed to the listeners so the navigation can be accepted\n        // call all listeners\n        listeners.forEach(listener => {\n            listener(currentLocation.value, from, {\n                delta,\n                type: NavigationType.pop,\n                direction: delta\n                    ? delta > 0\n                        ? NavigationDirection.forward\n                        : NavigationDirection.back\n                    : NavigationDirection.unknown,\n            });\n        });\n    };\n    function pauseListeners() {\n        pauseState = currentLocation.value;\n    }\n    function listen(callback) {\n        // setup the listener and prepare teardown callbacks\n        listeners.push(callback);\n        const teardown = () => {\n            const index = listeners.indexOf(callback);\n            if (index > -1)\n                listeners.splice(index, 1);\n        };\n        teardowns.push(teardown);\n        return teardown;\n    }\n    function beforeUnloadListener() {\n        const { history } = window;\n        if (!history.state)\n            return;\n        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');\n    }\n    function destroy() {\n        for (const teardown of teardowns)\n            teardown();\n        teardowns = [];\n        window.removeEventListener('popstate', popStateHandler);\n        window.removeEventListener('beforeunload', beforeUnloadListener);\n    }\n    // setup the listeners and prepare teardown callbacks\n    window.addEventListener('popstate', popStateHandler);\n    window.addEventListener('beforeunload', beforeUnloadListener);\n    return {\n        pauseListeners,\n        listen,\n        destroy,\n    };\n}\n/**\n * Creates a state object\n */\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\n    return {\n        back,\n        current,\n        forward,\n        replaced,\n        position: window.history.length,\n        scroll: computeScroll ? computeScrollPosition() : null,\n    };\n}\nfunction useHistoryStateNavigation(base) {\n    const { history, location } = window;\n    // private variables\n    const currentLocation = {\n        value: createCurrentLocation(base, location),\n    };\n    const historyState = { value: history.state };\n    // build current history entry as this is a fresh navigation\n    if (!historyState.value) {\n        changeLocation(currentLocation.value, {\n            back: null,\n            current: currentLocation.value,\n            forward: null,\n            // the length is off by one, we need to decrease it\n            position: history.length - 1,\n            replaced: true,\n            // don't add a scroll as the user may have an anchor and we want\n            // scrollBehavior to be triggered without a saved position\n            scroll: null,\n        }, true);\n    }\n    function changeLocation(to, state, replace) {\n        /**\n         * if a base tag is provided and we are on a normal domain, we have to\n         * respect the provided `base` attribute because pushState() will use it and\n         * potentially erase anything before the `#` like at\n         * https://github.com/vuejs/router/issues/685 where a base of\n         * `/folder/#` but a base of `/` would erase the `/folder/` section. If\n         * there is no host, the `<base>` tag makes no sense and if there isn't a\n         * base tag we can just use everything after the `#`.\n         */\n        const hashIndex = base.indexOf('#');\n        const url = hashIndex > -1\n            ? (location.host && document.querySelector('base')\n                ? base\n                : base.slice(hashIndex)) + to\n            : createBaseLocation() + base + to;\n        try {\n            // BROWSER QUIRK\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\n            history[replace ? 'replaceState' : 'pushState'](state, '', url);\n            historyState.value = state;\n        }\n        catch (err) {\n            if ((process.env.NODE_ENV !== 'production')) {\n                warn('Error with push/replace State', err);\n            }\n            else {\n                console.error(err);\n            }\n            // Force the navigation, this also resets the call count\n            location[replace ? 'replace' : 'assign'](url);\n        }\n    }\n    function replace(to, data) {\n        const state = assign({}, history.state, buildState(historyState.value.back, \n        // keep back and forward entries but override current position\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\n        changeLocation(to, state, true);\n        currentLocation.value = to;\n    }\n    function push(to, data) {\n        // Add to current entry the information of where we are going\n        // as well as saving the current position\n        const currentState = assign({}, \n        // use current history state to gracefully handle a wrong call to\n        // history.replaceState\n        // https://github.com/vuejs/router/issues/366\n        historyState.value, history.state, {\n            forward: to,\n            scroll: computeScrollPosition(),\n        });\n        if ((process.env.NODE_ENV !== 'production') && !history.state) {\n            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` +\n                `history.replaceState(history.state, '', url)\\n\\n` +\n                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\n        }\n        changeLocation(currentState.current, currentState, true);\n        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\n        changeLocation(to, state, false);\n        currentLocation.value = to;\n    }\n    return {\n        location: currentLocation,\n        state: historyState,\n        push,\n        replace,\n    };\n}\n/**\n * Creates an HTML5 history. Most common history for single page applications.\n *\n * @param base -\n */\nfunction createWebHistory(base) {\n    base = normalizeBase(base);\n    const historyNavigation = useHistoryStateNavigation(base);\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\n    function go(delta, triggerListeners = true) {\n        if (!triggerListeners)\n            historyListeners.pauseListeners();\n        history.go(delta);\n    }\n    const routerHistory = assign({\n        // it's overridden right after\n        location: '',\n        base,\n        go,\n        createHref: createHref.bind(null, base),\n    }, historyNavigation, historyListeners);\n    Object.defineProperty(routerHistory, 'location', {\n        enumerable: true,\n        get: () => historyNavigation.location.value,\n    });\n    Object.defineProperty(routerHistory, 'state', {\n        enumerable: true,\n        get: () => historyNavigation.state.value,\n    });\n    return routerHistory;\n}\n\n/**\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\n *\n * @param base - Base applied to all urls, defaults to '/'\n * @returns a history object that can be passed to the router constructor\n */\nfunction createMemoryHistory(base = '') {\n    let listeners = [];\n    let queue = [START];\n    let position = 0;\n    base = normalizeBase(base);\n    function setLocation(location) {\n        position++;\n        if (position === queue.length) {\n            // we are at the end, we can simply append a new entry\n            queue.push(location);\n        }\n        else {\n            // we are in the middle, we remove everything from here in the queue\n            queue.splice(position);\n            queue.push(location);\n        }\n    }\n    function triggerListeners(to, from, { direction, delta }) {\n        const info = {\n            direction,\n            delta,\n            type: NavigationType.pop,\n        };\n        for (const callback of listeners) {\n            callback(to, from, info);\n        }\n    }\n    const routerHistory = {\n        // rewritten by Object.defineProperty\n        location: START,\n        // TODO: should be kept in queue\n        state: {},\n        base,\n        createHref: createHref.bind(null, base),\n        replace(to) {\n            // remove current entry and decrement position\n            queue.splice(position--, 1);\n            setLocation(to);\n        },\n        push(to, data) {\n            setLocation(to);\n        },\n        listen(callback) {\n            listeners.push(callback);\n            return () => {\n                const index = listeners.indexOf(callback);\n                if (index > -1)\n                    listeners.splice(index, 1);\n            };\n        },\n        destroy() {\n            listeners = [];\n            queue = [START];\n            position = 0;\n        },\n        go(delta, shouldTrigger = true) {\n            const from = this.location;\n            const direction = \n            // we are considering delta === 0 going forward, but in abstract mode\n            // using 0 for the delta doesn't make sense like it does in html5 where\n            // it reloads the page\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\n            if (shouldTrigger) {\n                triggerListeners(this.location, from, {\n                    direction,\n                    delta,\n                });\n            }\n        },\n    };\n    Object.defineProperty(routerHistory, 'location', {\n        enumerable: true,\n        get: () => queue[position],\n    });\n    return routerHistory;\n}\n\n/**\n * Creates a hash history. Useful for web applications with no host (e.g.\n * `file://`) or when configuring a server to handle any URL is not possible.\n *\n * @param base - optional base to provide. Defaults to `location.pathname +\n * location.search` If there is a `<base>` tag in the `head`, its value will be\n * ignored in favor of this parameter **but note it affects all the\n * history.pushState() calls**, meaning that if you use a `<base>` tag, it's\n * `href` value **has to match this parameter** (ignoring anything after the\n * `#`).\n *\n * @example\n * ```js\n * // at https://example.com/folder\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\n * // you should avoid doing this because it changes the original url and breaks copying urls\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\n *\n * // at file:///usr/etc/folder/index.html\n * // for locations with no `host`, the base is ignored\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\n * ```\n */\nfunction createWebHashHistory(base) {\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\n    // for `file://`, directly use the pathname and ignore the base\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\n    base = location.host ? base || location.pathname + location.search : '';\n    // allow the user to provide a `#` in the middle: `/base/#/app`\n    if (!base.includes('#'))\n        base += '#';\n    if ((process.env.NODE_ENV !== 'production') && !base.endsWith('#/') && !base.endsWith('#')) {\n        warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\n    }\n    return createWebHistory(base);\n}\n\nfunction isRouteLocation(route) {\n    return typeof route === 'string' || (route && typeof route === 'object');\n}\nfunction isRouteName(name) {\n    return typeof name === 'string' || typeof name === 'symbol';\n}\n\n/**\n * Initial route location where the router is. Can be used in navigation guards\n * to differentiate the initial navigation.\n *\n * @example\n * ```js\n * import { START_LOCATION } from 'vue-router'\n *\n * router.beforeEach((to, from) => {\n *   if (from === START_LOCATION) {\n *     // initial navigation\n *   }\n * })\n * ```\n */\nconst START_LOCATION_NORMALIZED = {\n    path: '/',\n    name: undefined,\n    params: {},\n    query: {},\n    hash: '',\n    fullPath: '/',\n    matched: [],\n    meta: {},\n    redirectedFrom: undefined,\n};\n\nconst NavigationFailureSymbol = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'navigation failure' : 'nf');\n/**\n * Enumeration with all possible types for navigation failures. Can be passed to\n * {@link isNavigationFailure} to check for specific failures.\n */\nvar NavigationFailureType;\n(function (NavigationFailureType) {\n    /**\n     * An aborted navigation is a navigation that failed because a navigation\n     * guard returned `false` or called `next(false)`\n     */\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\n    /**\n     * A cancelled navigation is a navigation that failed because a more recent\n     * navigation finished started (not necessarily finished).\n     */\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\n    /**\n     * A duplicated navigation is a navigation that failed because it was\n     * initiated while already being at the exact same location.\n     */\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\n})(NavigationFailureType || (NavigationFailureType = {}));\n// DEV only debug messages\nconst ErrorTypeMessages = {\n    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\n            ? '\\nwhile being at\\n' + JSON.stringify(currentLocation)\n            : ''}`;\n    },\n    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\n        return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\n    },\n    [4 /* NAVIGATION_ABORTED */]({ from, to }) {\n        return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\n    },\n    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {\n        return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\n    },\n    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {\n        return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\n    },\n};\nfunction createRouterError(type, params) {\n    // keep full error messages in cjs versions\n    if ((process.env.NODE_ENV !== 'production') || !true) {\n        return assign(new Error(ErrorTypeMessages[type](params)), {\n            type,\n            [NavigationFailureSymbol]: true,\n        }, params);\n    }\n    else {\n        return assign(new Error(), {\n            type,\n            [NavigationFailureSymbol]: true,\n        }, params);\n    }\n}\nfunction isNavigationFailure(error, type) {\n    return (error instanceof Error &&\n        NavigationFailureSymbol in error &&\n        (type == null || !!(error.type & type)));\n}\nconst propertiesToLog = ['params', 'query', 'hash'];\nfunction stringifyRoute(to) {\n    if (typeof to === 'string')\n        return to;\n    if ('path' in to)\n        return to.path;\n    const location = {};\n    for (const key of propertiesToLog) {\n        if (key in to)\n            location[key] = to[key];\n    }\n    return JSON.stringify(location, null, 2);\n}\n\n// default pattern for a param: non greedy everything but /\nconst BASE_PARAM_PATTERN = '[^/]+?';\nconst BASE_PATH_PARSER_OPTIONS = {\n    sensitive: false,\n    strict: false,\n    start: true,\n    end: true,\n};\n// Special Regex characters that must be escaped in static tokens\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\n/**\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\n *\n * @param segments - array of segments returned by tokenizePath\n * @param extraOptions - optional options for the regexp\n * @returns a PathParser\n */\nfunction tokensToParser(segments, extraOptions) {\n    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\n    // the amount of scores is the same as the length of segments except for the root segment \"/\"\n    const score = [];\n    // the regexp as a string\n    let pattern = options.start ? '^' : '';\n    // extracted keys\n    const keys = [];\n    for (const segment of segments) {\n        // the root segment needs special treatment\n        const segmentScores = segment.length ? [] : [90 /* Root */];\n        // allow trailing slash\n        if (options.strict && !segment.length)\n            pattern += '/';\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\n            const token = segment[tokenIndex];\n            // resets the score if we are inside a sub segment /:a-other-:b\n            let subSegmentScore = 40 /* Segment */ +\n                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\n            if (token.type === 0 /* Static */) {\n                // prepend the slash if we are starting a new segment\n                if (!tokenIndex)\n                    pattern += '/';\n                pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\n                subSegmentScore += 40 /* Static */;\n            }\n            else if (token.type === 1 /* Param */) {\n                const { value, repeatable, optional, regexp } = token;\n                keys.push({\n                    name: value,\n                    repeatable,\n                    optional,\n                });\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\n                // the user provided a custom regexp /:id(\\\\d+)\n                if (re !== BASE_PARAM_PATTERN) {\n                    subSegmentScore += 10 /* BonusCustomRegExp */;\n                    // make sure the regexp is valid before using it\n                    try {\n                        new RegExp(`(${re})`);\n                    }\n                    catch (err) {\n                        throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` +\n                            err.message);\n                    }\n                }\n                // when we repeat we must take care of the repeating leading slash\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\n                // prepend the slash if we are starting a new segment\n                if (!tokenIndex)\n                    subPattern =\n                        // avoid an optional / if there are more segments e.g. /:p?-static\n                        // or /:p?-:p2\n                        optional && segment.length < 2\n                            ? `(?:/${subPattern})`\n                            : '/' + subPattern;\n                if (optional)\n                    subPattern += '?';\n                pattern += subPattern;\n                subSegmentScore += 20 /* Dynamic */;\n                if (optional)\n                    subSegmentScore += -8 /* BonusOptional */;\n                if (repeatable)\n                    subSegmentScore += -20 /* BonusRepeatable */;\n                if (re === '.*')\n                    subSegmentScore += -50 /* BonusWildcard */;\n            }\n            segmentScores.push(subSegmentScore);\n        }\n        // an empty array like /home/ -> [[{home}], []]\n        // if (!segment.length) pattern += '/'\n        score.push(segmentScores);\n    }\n    // only apply the strict bonus to the last score\n    if (options.strict && options.end) {\n        const i = score.length - 1;\n        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\n    }\n    // TODO: dev only warn double trailing slash\n    if (!options.strict)\n        pattern += '/?';\n    if (options.end)\n        pattern += '$';\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\n    else if (options.strict)\n        pattern += '(?:/|$)';\n    const re = new RegExp(pattern, options.sensitive ? '' : 'i');\n    function parse(path) {\n        const match = path.match(re);\n        const params = {};\n        if (!match)\n            return null;\n        for (let i = 1; i < match.length; i++) {\n            const value = match[i] || '';\n            const key = keys[i - 1];\n            params[key.name] = value && key.repeatable ? value.split('/') : value;\n        }\n        return params;\n    }\n    function stringify(params) {\n        let path = '';\n        // for optional parameters to allow to be empty\n        let avoidDuplicatedSlash = false;\n        for (const segment of segments) {\n            if (!avoidDuplicatedSlash || !path.endsWith('/'))\n                path += '/';\n            avoidDuplicatedSlash = false;\n            for (const token of segment) {\n                if (token.type === 0 /* Static */) {\n                    path += token.value;\n                }\n                else if (token.type === 1 /* Param */) {\n                    const { value, repeatable, optional } = token;\n                    const param = value in params ? params[value] : '';\n                    if (Array.isArray(param) && !repeatable)\n                        throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\n                    const text = Array.isArray(param) ? param.join('/') : param;\n                    if (!text) {\n                        if (optional) {\n                            // if we have more than one optional param like /:a?-static we\n                            // don't need to care about the optional param\n                            if (segment.length < 2) {\n                                // remove the last slash as we could be at the end\n                                if (path.endsWith('/'))\n                                    path = path.slice(0, -1);\n                                // do not append a slash on the next iteration\n                                else\n                                    avoidDuplicatedSlash = true;\n                            }\n                        }\n                        else\n                            throw new Error(`Missing required param \"${value}\"`);\n                    }\n                    path += text;\n                }\n            }\n        }\n        return path;\n    }\n    return {\n        re,\n        score,\n        keys,\n        parse,\n        stringify,\n    };\n}\n/**\n * Compares an array of numbers as used in PathParser.score and returns a\n * number. This function can be used to `sort` an array\n *\n * @param a - first array of numbers\n * @param b - second array of numbers\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n * should be sorted first\n */\nfunction compareScoreArray(a, b) {\n    let i = 0;\n    while (i < a.length && i < b.length) {\n        const diff = b[i] - a[i];\n        // only keep going if diff === 0\n        if (diff)\n            return diff;\n        i++;\n    }\n    // if the last subsegment was Static, the shorter segments should be sorted first\n    // otherwise sort the longest segment first\n    if (a.length < b.length) {\n        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */\n            ? -1\n            : 1;\n    }\n    else if (a.length > b.length) {\n        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */\n            ? 1\n            : -1;\n    }\n    return 0;\n}\n/**\n * Compare function that can be used with `sort` to sort an array of PathParser\n *\n * @param a - first PathParser\n * @param b - second PathParser\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\n */\nfunction comparePathParserScore(a, b) {\n    let i = 0;\n    const aScore = a.score;\n    const bScore = b.score;\n    while (i < aScore.length && i < bScore.length) {\n        const comp = compareScoreArray(aScore[i], bScore[i]);\n        // do not return if both are equal\n        if (comp)\n            return comp;\n        i++;\n    }\n    // if a and b share the same score entries but b has more, sort b first\n    return bScore.length - aScore.length;\n    // this is the ternary version\n    // return aScore.length < bScore.length\n    //   ? 1\n    //   : aScore.length > bScore.length\n    //   ? -1\n    //   : 0\n}\n\nconst ROOT_TOKEN = {\n    type: 0 /* Static */,\n    value: '',\n};\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\n// After some profiling, the cache seems to be unnecessary because tokenizePath\n// (the slowest part of adding a route) is very fast\n// const tokenCache = new Map<string, Token[][]>()\nfunction tokenizePath(path) {\n    if (!path)\n        return [[]];\n    if (path === '/')\n        return [[ROOT_TOKEN]];\n    if (!path.startsWith('/')) {\n        throw new Error((process.env.NODE_ENV !== 'production')\n            ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".`\n            : `Invalid path \"${path}\"`);\n    }\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\n    function crash(message) {\n        throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\n    }\n    let state = 0 /* Static */;\n    let previousState = state;\n    const tokens = [];\n    // the segment will always be valid because we get into the initial state\n    // with the leading /\n    let segment;\n    function finalizeSegment() {\n        if (segment)\n            tokens.push(segment);\n        segment = [];\n    }\n    // index on the path\n    let i = 0;\n    // char at index\n    let char;\n    // buffer of the value read\n    let buffer = '';\n    // custom regexp for a param\n    let customRe = '';\n    function consumeBuffer() {\n        if (!buffer)\n            return;\n        if (state === 0 /* Static */) {\n            segment.push({\n                type: 0 /* Static */,\n                value: buffer,\n            });\n        }\n        else if (state === 1 /* Param */ ||\n            state === 2 /* ParamRegExp */ ||\n            state === 3 /* ParamRegExpEnd */) {\n            if (segment.length > 1 && (char === '*' || char === '+'))\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\n            segment.push({\n                type: 1 /* Param */,\n                value: buffer,\n                regexp: customRe,\n                repeatable: char === '*' || char === '+',\n                optional: char === '*' || char === '?',\n            });\n        }\n        else {\n            crash('Invalid state to consume buffer');\n        }\n        buffer = '';\n    }\n    function addCharToBuffer() {\n        buffer += char;\n    }\n    while (i < path.length) {\n        char = path[i++];\n        if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\n            previousState = state;\n            state = 4 /* EscapeNext */;\n            continue;\n        }\n        switch (state) {\n            case 0 /* Static */:\n                if (char === '/') {\n                    if (buffer) {\n                        consumeBuffer();\n                    }\n                    finalizeSegment();\n                }\n                else if (char === ':') {\n                    consumeBuffer();\n                    state = 1 /* Param */;\n                }\n                else {\n                    addCharToBuffer();\n                }\n                break;\n            case 4 /* EscapeNext */:\n                addCharToBuffer();\n                state = previousState;\n                break;\n            case 1 /* Param */:\n                if (char === '(') {\n                    state = 2 /* ParamRegExp */;\n                }\n                else if (VALID_PARAM_RE.test(char)) {\n                    addCharToBuffer();\n                }\n                else {\n                    consumeBuffer();\n                    state = 0 /* Static */;\n                    // go back one character if we were not modifying\n                    if (char !== '*' && char !== '?' && char !== '+')\n                        i--;\n                }\n                break;\n            case 2 /* ParamRegExp */:\n                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\n                // it already works by escaping the closing )\n                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\n                // is this really something people need since you can also write\n                // /prefix_:p()_suffix\n                if (char === ')') {\n                    // handle the escaped )\n                    if (customRe[customRe.length - 1] == '\\\\')\n                        customRe = customRe.slice(0, -1) + char;\n                    else\n                        state = 3 /* ParamRegExpEnd */;\n                }\n                else {\n                    customRe += char;\n                }\n                break;\n            case 3 /* ParamRegExpEnd */:\n                // same as finalizing a param\n                consumeBuffer();\n                state = 0 /* Static */;\n                // go back one character if we were not modifying\n                if (char !== '*' && char !== '?' && char !== '+')\n                    i--;\n                customRe = '';\n                break;\n            default:\n                crash('Unknown state');\n                break;\n        }\n    }\n    if (state === 2 /* ParamRegExp */)\n        crash(`Unfinished custom RegExp for param \"${buffer}\"`);\n    consumeBuffer();\n    finalizeSegment();\n    // tokenCache.set(path, tokens)\n    return tokens;\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\n    const parser = tokensToParser(tokenizePath(record.path), options);\n    // warn against params with the same name\n    if ((process.env.NODE_ENV !== 'production')) {\n        const existingKeys = new Set();\n        for (const key of parser.keys) {\n            if (existingKeys.has(key.name))\n                warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\n            existingKeys.add(key.name);\n        }\n    }\n    const matcher = assign(parser, {\n        record,\n        parent,\n        // these needs to be populated by the parent\n        children: [],\n        alias: [],\n    });\n    if (parent) {\n        // both are aliases or both are not aliases\n        // we don't want to mix them because the order is used when\n        // passing originalRecord in Matcher.addRoute\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\n            parent.children.push(matcher);\n    }\n    return matcher;\n}\n\n/**\n * Creates a Router Matcher.\n *\n * @internal\n * @param routes - array of initial routes\n * @param globalOptions - global route options\n */\nfunction createRouterMatcher(routes, globalOptions) {\n    // normalized ordered array of matchers\n    const matchers = [];\n    const matcherMap = new Map();\n    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\n    function getRecordMatcher(name) {\n        return matcherMap.get(name);\n    }\n    function addRoute(record, parent, originalRecord) {\n        // used later on to remove by name\n        const isRootAdd = !originalRecord;\n        const mainNormalizedRecord = normalizeRouteRecord(record);\n        // we might be the child of an alias\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\n        const options = mergeOptions(globalOptions, record);\n        // generate an array of records to correctly handle aliases\n        const normalizedRecords = [\n            mainNormalizedRecord,\n        ];\n        if ('alias' in record) {\n            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\n            for (const alias of aliases) {\n                normalizedRecords.push(assign({}, mainNormalizedRecord, {\n                    // this allows us to hold a copy of the `components` option\n                    // so that async components cache is hold on the original record\n                    components: originalRecord\n                        ? originalRecord.record.components\n                        : mainNormalizedRecord.components,\n                    path: alias,\n                    // we might be the child of an alias\n                    aliasOf: originalRecord\n                        ? originalRecord.record\n                        : mainNormalizedRecord,\n                    // the aliases are always of the same kind as the original since they\n                    // are defined on the same record\n                }));\n            }\n        }\n        let matcher;\n        let originalMatcher;\n        for (const normalizedRecord of normalizedRecords) {\n            const { path } = normalizedRecord;\n            // Build up the path for nested routes if the child isn't an absolute\n            // route. Only add the / delimiter if the child path isn't empty and if the\n            // parent path doesn't have a trailing slash\n            if (parent && path[0] !== '/') {\n                const parentPath = parent.record.path;\n                const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\n                normalizedRecord.path =\n                    parent.record.path + (path && connectingSlash + path);\n            }\n            if ((process.env.NODE_ENV !== 'production') && normalizedRecord.path === '*') {\n                throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' +\n                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\n            }\n            // create the object before hand so it can be passed to children\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\n            if ((process.env.NODE_ENV !== 'production') && parent && path[0] === '/')\n                checkMissingParamsInAbsolutePath(matcher, parent);\n            // if we are an alias we must tell the original record that we exist\n            // so we can be removed\n            if (originalRecord) {\n                originalRecord.alias.push(matcher);\n                if ((process.env.NODE_ENV !== 'production')) {\n                    checkSameParams(originalRecord, matcher);\n                }\n            }\n            else {\n                // otherwise, the first record is the original and others are aliases\n                originalMatcher = originalMatcher || matcher;\n                if (originalMatcher !== matcher)\n                    originalMatcher.alias.push(matcher);\n                // remove the route if named and only for the top record (avoid in nested calls)\n                // this works because the original record is the first one\n                if (isRootAdd && record.name && !isAliasRecord(matcher))\n                    removeRoute(record.name);\n            }\n            if ('children' in mainNormalizedRecord) {\n                const children = mainNormalizedRecord.children;\n                for (let i = 0; i < children.length; i++) {\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\n                }\n            }\n            // if there was no original record, then the first one was not an alias and all\n            // other alias (if any) need to reference this record when adding children\n            originalRecord = originalRecord || matcher;\n            // TODO: add normalized records for more flexibility\n            // if (parent && isAliasRecord(originalRecord)) {\n            //   parent.children.push(originalRecord)\n            // }\n            insertMatcher(matcher);\n        }\n        return originalMatcher\n            ? () => {\n                // since other matchers are aliases, they should be removed by the original matcher\n                removeRoute(originalMatcher);\n            }\n            : noop;\n    }\n    function removeRoute(matcherRef) {\n        if (isRouteName(matcherRef)) {\n            const matcher = matcherMap.get(matcherRef);\n            if (matcher) {\n                matcherMap.delete(matcherRef);\n                matchers.splice(matchers.indexOf(matcher), 1);\n                matcher.children.forEach(removeRoute);\n                matcher.alias.forEach(removeRoute);\n            }\n        }\n        else {\n            const index = matchers.indexOf(matcherRef);\n            if (index > -1) {\n                matchers.splice(index, 1);\n                if (matcherRef.record.name)\n                    matcherMap.delete(matcherRef.record.name);\n                matcherRef.children.forEach(removeRoute);\n                matcherRef.alias.forEach(removeRoute);\n            }\n        }\n    }\n    function getRoutes() {\n        return matchers;\n    }\n    function insertMatcher(matcher) {\n        let i = 0;\n        while (i < matchers.length &&\n            comparePathParserScore(matcher, matchers[i]) >= 0 &&\n            // Adding children with empty path should still appear before the parent\n            // https://github.com/vuejs/router/issues/1124\n            (matcher.record.path !== matchers[i].record.path ||\n                !isRecordChildOf(matcher, matchers[i])))\n            i++;\n        matchers.splice(i, 0, matcher);\n        // only add the original record to the name map\n        if (matcher.record.name && !isAliasRecord(matcher))\n            matcherMap.set(matcher.record.name, matcher);\n    }\n    function resolve(location, currentLocation) {\n        let matcher;\n        let params = {};\n        let path;\n        let name;\n        if ('name' in location && location.name) {\n            matcher = matcherMap.get(location.name);\n            if (!matcher)\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\n                    location,\n                });\n            name = matcher.record.name;\n            params = assign(\n            // paramsFromLocation is a new object\n            paramsFromLocation(currentLocation.params, \n            // only keep params that exist in the resolved location\n            // TODO: only keep optional params coming from a parent record\n            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);\n            // throws if cannot be stringified\n            path = matcher.stringify(params);\n        }\n        else if ('path' in location) {\n            // no need to resolve the path with the matcher as it was provided\n            // this also allows the user to control the encoding\n            path = location.path;\n            if ((process.env.NODE_ENV !== 'production') && !path.startsWith('/')) {\n                warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);\n            }\n            matcher = matchers.find(m => m.re.test(path));\n            // matcher should have a value after the loop\n            if (matcher) {\n                // TODO: dev warning of unused params if provided\n                // we know the matcher works because we tested the regexp\n                params = matcher.parse(path);\n                name = matcher.record.name;\n            }\n            // location is a relative path\n        }\n        else {\n            // match by name or path of current route\n            matcher = currentLocation.name\n                ? matcherMap.get(currentLocation.name)\n                : matchers.find(m => m.re.test(currentLocation.path));\n            if (!matcher)\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\n                    location,\n                    currentLocation,\n                });\n            name = matcher.record.name;\n            // since we are navigating to the same location, we don't need to pick the\n            // params like when `name` is provided\n            params = assign({}, currentLocation.params, location.params);\n            path = matcher.stringify(params);\n        }\n        const matched = [];\n        let parentMatcher = matcher;\n        while (parentMatcher) {\n            // reversed order so parents are at the beginning\n            matched.unshift(parentMatcher.record);\n            parentMatcher = parentMatcher.parent;\n        }\n        return {\n            name,\n            path,\n            params,\n            matched,\n            meta: mergeMetaFields(matched),\n        };\n    }\n    // add initial routes\n    routes.forEach(route => addRoute(route));\n    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\n}\nfunction paramsFromLocation(params, keys) {\n    const newParams = {};\n    for (const key of keys) {\n        if (key in params)\n            newParams[key] = params[key];\n    }\n    return newParams;\n}\n/**\n * Normalizes a RouteRecordRaw. Creates a copy\n *\n * @param record\n * @returns the normalized version\n */\nfunction normalizeRouteRecord(record) {\n    return {\n        path: record.path,\n        redirect: record.redirect,\n        name: record.name,\n        meta: record.meta || {},\n        aliasOf: undefined,\n        beforeEnter: record.beforeEnter,\n        props: normalizeRecordProps(record),\n        children: record.children || [],\n        instances: {},\n        leaveGuards: new Set(),\n        updateGuards: new Set(),\n        enterCallbacks: {},\n        components: 'components' in record\n            ? record.components || {}\n            : { default: record.component },\n    };\n}\n/**\n * Normalize the optional `props` in a record to always be an object similar to\n * components. Also accept a boolean for components.\n * @param record\n */\nfunction normalizeRecordProps(record) {\n    const propsObject = {};\n    // props does not exist on redirect records but we can set false directly\n    const props = record.props || false;\n    if ('component' in record) {\n        propsObject.default = props;\n    }\n    else {\n        // NOTE: we could also allow a function to be applied to every component.\n        // Would need user feedback for use cases\n        for (const name in record.components)\n            propsObject[name] = typeof props === 'boolean' ? props : props[name];\n    }\n    return propsObject;\n}\n/**\n * Checks if a record or any of its parent is an alias\n * @param record\n */\nfunction isAliasRecord(record) {\n    while (record) {\n        if (record.record.aliasOf)\n            return true;\n        record = record.parent;\n    }\n    return false;\n}\n/**\n * Merge meta fields of an array of records\n *\n * @param matched - array of matched records\n */\nfunction mergeMetaFields(matched) {\n    return matched.reduce((meta, record) => assign(meta, record.meta), {});\n}\nfunction mergeOptions(defaults, partialOptions) {\n    const options = {};\n    for (const key in defaults) {\n        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\n    }\n    return options;\n}\nfunction isSameParam(a, b) {\n    return (a.name === b.name &&\n        a.optional === b.optional &&\n        a.repeatable === b.repeatable);\n}\n/**\n * Check if a path and its alias have the same required params\n *\n * @param a - original record\n * @param b - alias record\n */\nfunction checkSameParams(a, b) {\n    for (const key of a.keys) {\n        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\n    }\n    for (const key of b.keys) {\n        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\n    }\n}\nfunction checkMissingParamsInAbsolutePath(record, parent) {\n    for (const key of parent.keys) {\n        if (!record.keys.find(isSameParam.bind(null, key)))\n            return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\n    }\n}\nfunction isRecordChildOf(record, parent) {\n    return parent.children.some(child => child === record || isRecordChildOf(record, child));\n}\n\n/**\n * Encoding Rules ␣ = Space Path: ␣ \" < > # ? { } Query: ␣ \" < > # & = Hash: ␣ \"\n * < > `\n *\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\n * defines some extra characters to be encoded. Most browsers do not encode them\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\n * plus `-._~`. This extra safety should be applied to query by patching the\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\n * encoded everywhere because some browsers like FF encode it when directly\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\n */\n// const EXTRA_RESERVED_RE = /[!'()*]/g\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\nconst HASH_RE = /#/g; // %23\nconst AMPERSAND_RE = /&/g; // %26\nconst SLASH_RE = /\\//g; // %2F\nconst EQUAL_RE = /=/g; // %3D\nconst IM_RE = /\\?/g; // %3F\nconst PLUS_RE = /\\+/g; // %2B\n/**\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\n * seems to be less flexible than not doing so and I can't find out the legacy\n * systems requiring this for regular requests like text/html. In the standard,\n * the encoding of the plus character is only mentioned for\n * application/x-www-form-urlencoded\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\n * leave the plus character as is in queries. To be more flexible, we allow the\n * plus character on the query but it can also be manually encoded by the user.\n *\n * Resources:\n * - https://url.spec.whatwg.org/#urlencoded-parsing\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\n */\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\nconst ENC_CARET_RE = /%5E/g; // ^\nconst ENC_BACKTICK_RE = /%60/g; // `\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\nconst ENC_PIPE_RE = /%7C/g; // |\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\nconst ENC_SPACE_RE = /%20/g; // }\n/**\n * Encode characters that need to be encoded on the path, search and hash\n * sections of the URL.\n *\n * @internal\n * @param text - string to encode\n * @returns encoded string\n */\nfunction commonEncode(text) {\n    return encodeURI('' + text)\n        .replace(ENC_PIPE_RE, '|')\n        .replace(ENC_BRACKET_OPEN_RE, '[')\n        .replace(ENC_BRACKET_CLOSE_RE, ']');\n}\n/**\n * Encode characters that need to be encoded on the hash section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodeHash(text) {\n    return commonEncode(text)\n        .replace(ENC_CURLY_OPEN_RE, '{')\n        .replace(ENC_CURLY_CLOSE_RE, '}')\n        .replace(ENC_CARET_RE, '^');\n}\n/**\n * Encode characters that need to be encoded query values on the query\n * section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodeQueryValue(text) {\n    return (commonEncode(text)\n        // Encode the space as +, encode the + to differentiate it from the space\n        .replace(PLUS_RE, '%2B')\n        .replace(ENC_SPACE_RE, '+')\n        .replace(HASH_RE, '%23')\n        .replace(AMPERSAND_RE, '%26')\n        .replace(ENC_BACKTICK_RE, '`')\n        .replace(ENC_CURLY_OPEN_RE, '{')\n        .replace(ENC_CURLY_CLOSE_RE, '}')\n        .replace(ENC_CARET_RE, '^'));\n}\n/**\n * Like `encodeQueryValue` but also encodes the `=` character.\n *\n * @param text - string to encode\n */\nfunction encodeQueryKey(text) {\n    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\n}\n/**\n * Encode characters that need to be encoded on the path section of the URL.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodePath(text) {\n    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\n}\n/**\n * Encode characters that need to be encoded on the path section of the URL as a\n * param. This function encodes everything {@link encodePath} does plus the\n * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\n * string instead.\n *\n * @param text - string to encode\n * @returns encoded string\n */\nfunction encodeParam(text) {\n    return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');\n}\n/**\n * Decode text using `decodeURIComponent`. Returns the original text if it\n * fails.\n *\n * @param text - string to decode\n * @returns decoded string\n */\nfunction decode(text) {\n    try {\n        return decodeURIComponent('' + text);\n    }\n    catch (err) {\n        (process.env.NODE_ENV !== 'production') && warn(`Error decoding \"${text}\". Using original value`);\n    }\n    return '' + text;\n}\n\n/**\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\n * version with the leading `?` and without Should work as URLSearchParams\n\n * @internal\n *\n * @param search - search string to parse\n * @returns a query object\n */\nfunction parseQuery(search) {\n    const query = {};\n    // avoid creating an object with an empty key and empty value\n    // because of split('&')\n    if (search === '' || search === '?')\n        return query;\n    const hasLeadingIM = search[0] === '?';\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\n    for (let i = 0; i < searchParams.length; ++i) {\n        // pre decode the + into space\n        const searchParam = searchParams[i].replace(PLUS_RE, ' ');\n        // allow the = character\n        const eqPos = searchParam.indexOf('=');\n        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\n        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\n        if (key in query) {\n            // an extra variable for ts types\n            let currentValue = query[key];\n            if (!Array.isArray(currentValue)) {\n                currentValue = query[key] = [currentValue];\n            }\n            currentValue.push(value);\n        }\n        else {\n            query[key] = value;\n        }\n    }\n    return query;\n}\n/**\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\n * doesn't prepend a `?`\n *\n * @internal\n *\n * @param query - query object to stringify\n * @returns string version of the query without the leading `?`\n */\nfunction stringifyQuery(query) {\n    let search = '';\n    for (let key in query) {\n        const value = query[key];\n        key = encodeQueryKey(key);\n        if (value == null) {\n            // only null adds the value\n            if (value !== undefined) {\n                search += (search.length ? '&' : '') + key;\n            }\n            continue;\n        }\n        // keep null values\n        const values = Array.isArray(value)\n            ? value.map(v => v && encodeQueryValue(v))\n            : [value && encodeQueryValue(value)];\n        values.forEach(value => {\n            // skip undefined values in arrays as if they were not present\n            // smaller code than using filter\n            if (value !== undefined) {\n                // only append & with non-empty search\n                search += (search.length ? '&' : '') + key;\n                if (value != null)\n                    search += '=' + value;\n            }\n        });\n    }\n    return search;\n}\n/**\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\n * numbers into strings, removing keys with an undefined value and replacing\n * undefined with null in arrays\n *\n * @param query - query object to normalize\n * @returns a normalized query object\n */\nfunction normalizeQuery(query) {\n    const normalizedQuery = {};\n    for (const key in query) {\n        const value = query[key];\n        if (value !== undefined) {\n            normalizedQuery[key] = Array.isArray(value)\n                ? value.map(v => (v == null ? null : '' + v))\n                : value == null\n                    ? value\n                    : '' + value;\n        }\n    }\n    return normalizedQuery;\n}\n\n/**\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\n */\nfunction useCallbacks() {\n    let handlers = [];\n    function add(handler) {\n        handlers.push(handler);\n        return () => {\n            const i = handlers.indexOf(handler);\n            if (i > -1)\n                handlers.splice(i, 1);\n        };\n    }\n    function reset() {\n        handlers = [];\n    }\n    return {\n        add,\n        list: () => handlers,\n        reset,\n    };\n}\n\nfunction registerGuard(record, name, guard) {\n    const removeFromList = () => {\n        record[name].delete(guard);\n    };\n    onUnmounted(removeFromList);\n    onDeactivated(removeFromList);\n    onActivated(() => {\n        record[name].add(guard);\n    });\n    record[name].add(guard);\n}\n/**\n * Add a navigation guard that triggers whenever the component for the current\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\n * used in any component. The guard is removed when the component is unmounted.\n *\n * @param leaveGuard - {@link NavigationGuard}\n */\nfunction onBeforeRouteLeave(leaveGuard) {\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\n        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');\n        return;\n    }\n    const activeRecord = inject(matchedRouteKey, \n    // to avoid warning\n    {}).value;\n    if (!activeRecord) {\n        (process.env.NODE_ENV !== 'production') &&\n            warn('No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\n        return;\n    }\n    registerGuard(activeRecord, 'leaveGuards', leaveGuard);\n}\n/**\n * Add a navigation guard that triggers whenever the current location is about\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\n * component. The guard is removed when the component is unmounted.\n *\n * @param updateGuard - {@link NavigationGuard}\n */\nfunction onBeforeRouteUpdate(updateGuard) {\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\n        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');\n        return;\n    }\n    const activeRecord = inject(matchedRouteKey, \n    // to avoid warning\n    {}).value;\n    if (!activeRecord) {\n        (process.env.NODE_ENV !== 'production') &&\n            warn('No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\n        return;\n    }\n    registerGuard(activeRecord, 'updateGuards', updateGuard);\n}\nfunction guardToPromiseFn(guard, to, from, record, name) {\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\n    const enterCallbackArray = record &&\n        // name is defined if record is because of the function overload\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\n    return () => new Promise((resolve, reject) => {\n        const next = (valid) => {\n            if (valid === false)\n                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\n                    from,\n                    to,\n                }));\n            else if (valid instanceof Error) {\n                reject(valid);\n            }\n            else if (isRouteLocation(valid)) {\n                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\n                    from: to,\n                    to: valid,\n                }));\n            }\n            else {\n                if (enterCallbackArray &&\n                    // since enterCallbackArray is truthy, both record and name also are\n                    record.enterCallbacks[name] === enterCallbackArray &&\n                    typeof valid === 'function')\n                    enterCallbackArray.push(valid);\n                resolve();\n            }\n        };\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\n        const guardReturn = guard.call(record && record.instances[name], to, from, (process.env.NODE_ENV !== 'production') ? canOnlyBeCalledOnce(next, to, from) : next);\n        let guardCall = Promise.resolve(guardReturn);\n        if (guard.length < 3)\n            guardCall = guardCall.then(next);\n        if ((process.env.NODE_ENV !== 'production') && guard.length > 2) {\n            const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\n            if (typeof guardReturn === 'object' && 'then' in guardReturn) {\n                guardCall = guardCall.then(resolvedValue => {\n                    // @ts-expect-error: _called is added at canOnlyBeCalledOnce\n                    if (!next._called) {\n                        warn(message);\n                        return Promise.reject(new Error('Invalid navigation guard'));\n                    }\n                    return resolvedValue;\n                });\n                // TODO: test me!\n            }\n            else if (guardReturn !== undefined) {\n                // @ts-expect-error: _called is added at canOnlyBeCalledOnce\n                if (!next._called) {\n                    warn(message);\n                    reject(new Error('Invalid navigation guard'));\n                    return;\n                }\n            }\n        }\n        guardCall.catch(err => reject(err));\n    });\n}\nfunction canOnlyBeCalledOnce(next, to, from) {\n    let called = 0;\n    return function () {\n        if (called++ === 1)\n            warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\n        // @ts-expect-error: we put it in the original one because it's easier to check\n        next._called = true;\n        if (called === 1)\n            next.apply(null, arguments);\n    };\n}\nfunction extractComponentsGuards(matched, guardType, to, from) {\n    const guards = [];\n    for (const record of matched) {\n        for (const name in record.components) {\n            let rawComponent = record.components[name];\n            if ((process.env.NODE_ENV !== 'production')) {\n                if (!rawComponent ||\n                    (typeof rawComponent !== 'object' &&\n                        typeof rawComponent !== 'function')) {\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is not` +\n                        ` a valid component. Received \"${String(rawComponent)}\".`);\n                    // throw to ensure we stop here but warn to ensure the message isn't\n                    // missed by the user\n                    throw new Error('Invalid route component');\n                }\n                else if ('then' in rawComponent) {\n                    // warn if user wrote import('/component.vue') instead of () =>\n                    // import('./component.vue')\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a ` +\n                        `Promise instead of a function that returns a Promise. Did you ` +\n                        `write \"import('./MyPage.vue')\" instead of ` +\n                        `\"() => import('./MyPage.vue')\" ? This will break in ` +\n                        `production if not fixed.`);\n                    const promise = rawComponent;\n                    rawComponent = () => promise;\n                }\n                else if (rawComponent.__asyncLoader &&\n                    // warn only once per component\n                    !rawComponent.__warnedDefineAsync) {\n                    rawComponent.__warnedDefineAsync = true;\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is defined ` +\n                        `using \"defineAsyncComponent()\". ` +\n                        `Write \"() => import('./MyPage.vue')\" instead of ` +\n                        `\"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\n                }\n            }\n            // skip update and leave guards if the route component is not mounted\n            if (guardType !== 'beforeRouteEnter' && !record.instances[name])\n                continue;\n            if (isRouteComponent(rawComponent)) {\n                // __vccOpts is added by vue-class-component and contain the regular options\n                const options = rawComponent.__vccOpts || rawComponent;\n                const guard = options[guardType];\n                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\n            }\n            else {\n                // start requesting the chunk already\n                let componentPromise = rawComponent();\n                if ((process.env.NODE_ENV !== 'production') && !('catch' in componentPromise)) {\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\n                    componentPromise = Promise.resolve(componentPromise);\n                }\n                guards.push(() => componentPromise.then(resolved => {\n                    if (!resolved)\n                        return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\n                    const resolvedComponent = isESModule(resolved)\n                        ? resolved.default\n                        : resolved;\n                    // replace the function with the resolved component\n                    record.components[name] = resolvedComponent;\n                    // __vccOpts is added by vue-class-component and contain the regular options\n                    const options = resolvedComponent.__vccOpts || resolvedComponent;\n                    const guard = options[guardType];\n                    return guard && guardToPromiseFn(guard, to, from, record, name)();\n                }));\n            }\n        }\n    }\n    return guards;\n}\n/**\n * Allows differentiating lazy components from functional components and vue-class-component\n *\n * @param component\n */\nfunction isRouteComponent(component) {\n    return (typeof component === 'object' ||\n        'displayName' in component ||\n        'props' in component ||\n        '__vccOpts' in component);\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\n// `isExactActive` behavior should go through an RFC\nfunction useLink(props) {\n    const router = inject(routerKey);\n    const currentRoute = inject(routeLocationKey);\n    const route = computed(() => router.resolve(unref(props.to)));\n    const activeRecordIndex = computed(() => {\n        const { matched } = route.value;\n        const { length } = matched;\n        const routeMatched = matched[length - 1];\n        const currentMatched = currentRoute.matched;\n        if (!routeMatched || !currentMatched.length)\n            return -1;\n        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\n        if (index > -1)\n            return index;\n        // possible parent record\n        const parentRecordPath = getOriginalPath(matched[length - 2]);\n        return (\n        // we are dealing with nested routes\n        length > 1 &&\n            // if the parent and matched route have the same path, this link is\n            // referring to the empty child. Or we currently are on a different\n            // child of the same parent\n            getOriginalPath(routeMatched) === parentRecordPath &&\n            // avoid comparing the child with its parent\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\n            : index);\n    });\n    const isActive = computed(() => activeRecordIndex.value > -1 &&\n        includesParams(currentRoute.params, route.value.params));\n    const isExactActive = computed(() => activeRecordIndex.value > -1 &&\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\n    function navigate(e = {}) {\n        if (guardEvent(e)) {\n            return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to)\n            // avoid uncaught errors are they are logged anyway\n            ).catch(noop);\n        }\n        return Promise.resolve();\n    }\n    // devtools only\n    if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n        const instance = getCurrentInstance();\n        if (instance) {\n            const linkContextDevtools = {\n                route: route.value,\n                isActive: isActive.value,\n                isExactActive: isExactActive.value,\n            };\n            // @ts-expect-error: this is internal\n            instance.__vrl_devtools = instance.__vrl_devtools || [];\n            // @ts-expect-error: this is internal\n            instance.__vrl_devtools.push(linkContextDevtools);\n            watchEffect(() => {\n                linkContextDevtools.route = route.value;\n                linkContextDevtools.isActive = isActive.value;\n                linkContextDevtools.isExactActive = isExactActive.value;\n            }, { flush: 'post' });\n        }\n    }\n    return {\n        route,\n        href: computed(() => route.value.href),\n        isActive,\n        isExactActive,\n        navigate,\n    };\n}\nconst RouterLinkImpl = /*#__PURE__*/ defineComponent({\n    name: 'RouterLink',\n    props: {\n        to: {\n            type: [String, Object],\n            required: true,\n        },\n        replace: Boolean,\n        activeClass: String,\n        // inactiveClass: String,\n        exactActiveClass: String,\n        custom: Boolean,\n        ariaCurrentValue: {\n            type: String,\n            default: 'page',\n        },\n    },\n    useLink,\n    setup(props, { slots }) {\n        const link = reactive(useLink(props));\n        const { options } = inject(routerKey);\n        const elClass = computed(() => ({\n            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\n            // [getLinkClass(\n            //   props.inactiveClass,\n            //   options.linkInactiveClass,\n            //   'router-link-inactive'\n            // )]: !link.isExactActive,\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,\n        }));\n        return () => {\n            const children = slots.default && slots.default(link);\n            return props.custom\n                ? children\n                : h('a', {\n                    'aria-current': link.isExactActive\n                        ? props.ariaCurrentValue\n                        : null,\n                    href: link.href,\n                    // this would override user added attrs but Vue will still add\n                    // the listener so we end up triggering both\n                    onClick: link.navigate,\n                    class: elClass.value,\n                }, children);\n        };\n    },\n});\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to render a link that triggers a navigation on click.\n */\nconst RouterLink = RouterLinkImpl;\nfunction guardEvent(e) {\n    // don't redirect with control keys\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\n        return;\n    // don't redirect when preventDefault called\n    if (e.defaultPrevented)\n        return;\n    // don't redirect on right click\n    if (e.button !== undefined && e.button !== 0)\n        return;\n    // don't redirect if `target=\"_blank\"`\n    // @ts-expect-error getAttribute does exist\n    if (e.currentTarget && e.currentTarget.getAttribute) {\n        // @ts-expect-error getAttribute exists\n        const target = e.currentTarget.getAttribute('target');\n        if (/\\b_blank\\b/i.test(target))\n            return;\n    }\n    // this may be a Weex event which doesn't have this method\n    if (e.preventDefault)\n        e.preventDefault();\n    return true;\n}\nfunction includesParams(outer, inner) {\n    for (const key in inner) {\n        const innerValue = inner[key];\n        const outerValue = outer[key];\n        if (typeof innerValue === 'string') {\n            if (innerValue !== outerValue)\n                return false;\n        }\n        else {\n            if (!Array.isArray(outerValue) ||\n                outerValue.length !== innerValue.length ||\n                innerValue.some((value, i) => value !== outerValue[i]))\n                return false;\n        }\n    }\n    return true;\n}\n/**\n * Get the original path value of a record by following its aliasOf\n * @param record\n */\nfunction getOriginalPath(record) {\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';\n}\n/**\n * Utility class to get the active class based on defaults.\n * @param propClass\n * @param globalClass\n * @param defaultClass\n */\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\n    ? propClass\n    : globalClass != null\n        ? globalClass\n        : defaultClass;\n\nconst RouterViewImpl = /*#__PURE__*/ defineComponent({\n    name: 'RouterView',\n    // #674 we manually inherit them\n    inheritAttrs: false,\n    props: {\n        name: {\n            type: String,\n            default: 'default',\n        },\n        route: Object,\n    },\n    setup(props, { attrs, slots }) {\n        (process.env.NODE_ENV !== 'production') && warnDeprecatedUsage();\n        const injectedRoute = inject(routerViewLocationKey);\n        const routeToDisplay = computed(() => props.route || injectedRoute.value);\n        const depth = inject(viewDepthKey, 0);\n        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);\n        provide(viewDepthKey, depth + 1);\n        provide(matchedRouteKey, matchedRouteRef);\n        provide(routerViewLocationKey, routeToDisplay);\n        const viewRef = ref();\n        // watch at the same time the component instance, the route record we are\n        // rendering, and the name\n        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\n            // copy reused instances\n            if (to) {\n                // this will update the instance for new instances as well as reused\n                // instances when navigating to a new route\n                to.instances[name] = instance;\n                // the component instance is reused for a different route or name so\n                // we copy any saved update or leave guards. With async setup, the\n                // mounting component will mount before the matchedRoute changes,\n                // making instance === oldInstance, so we check if guards have been\n                // added before. This works because we remove guards when\n                // unmounting/deactivating components\n                if (from && from !== to && instance && instance === oldInstance) {\n                    if (!to.leaveGuards.size) {\n                        to.leaveGuards = from.leaveGuards;\n                    }\n                    if (!to.updateGuards.size) {\n                        to.updateGuards = from.updateGuards;\n                    }\n                }\n            }\n            // trigger beforeRouteEnter next callbacks\n            if (instance &&\n                to &&\n                // if there is no instance but to and from are the same this might be\n                // the first visit\n                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\n                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\n            }\n        }, { flush: 'post' });\n        return () => {\n            const route = routeToDisplay.value;\n            const matchedRoute = matchedRouteRef.value;\n            const ViewComponent = matchedRoute && matchedRoute.components[props.name];\n            // we need the value at the time we render because when we unmount, we\n            // navigated to a different location so the value is different\n            const currentName = props.name;\n            if (!ViewComponent) {\n                return normalizeSlot(slots.default, { Component: ViewComponent, route });\n            }\n            // props from route configuration\n            const routePropsOption = matchedRoute.props[props.name];\n            const routeProps = routePropsOption\n                ? routePropsOption === true\n                    ? route.params\n                    : typeof routePropsOption === 'function'\n                        ? routePropsOption(route)\n                        : routePropsOption\n                : null;\n            const onVnodeUnmounted = vnode => {\n                // remove the instance reference to prevent leak\n                if (vnode.component.isUnmounted) {\n                    matchedRoute.instances[currentName] = null;\n                }\n            };\n            const component = h(ViewComponent, assign({}, routeProps, attrs, {\n                onVnodeUnmounted,\n                ref: viewRef,\n            }));\n            if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) &&\n                isBrowser &&\n                component.ref) {\n                // TODO: can display if it's an alias, its props\n                const info = {\n                    depth,\n                    name: matchedRoute.name,\n                    path: matchedRoute.path,\n                    meta: matchedRoute.meta,\n                };\n                const internalInstances = Array.isArray(component.ref)\n                    ? component.ref.map(r => r.i)\n                    : [component.ref.i];\n                internalInstances.forEach(instance => {\n                    // @ts-expect-error\n                    instance.__vrv_devtools = info;\n                });\n            }\n            return (\n            // pass the vnode to the slot as a prop.\n            // h and <component :is=\"...\"> both accept vnodes\n            normalizeSlot(slots.default, { Component: component, route }) ||\n                component);\n        };\n    },\n});\nfunction normalizeSlot(slot, data) {\n    if (!slot)\n        return null;\n    const slotContent = slot(data);\n    return slotContent.length === 1 ? slotContent[0] : slotContent;\n}\n// export the public type for h/tsx inference\n// also to avoid inline import() in generated d.ts files\n/**\n * Component to display the current route the user is at.\n */\nconst RouterView = RouterViewImpl;\n// warn against deprecated usage with <transition> & <keep-alive>\n// due to functional component being no longer eager in Vue 3\nfunction warnDeprecatedUsage() {\n    const instance = getCurrentInstance();\n    const parentName = instance.parent && instance.parent.type.name;\n    if (parentName &&\n        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\n        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\n        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` +\n            `Use slot props instead:\\n\\n` +\n            `<router-view v-slot=\"{ Component }\">\\n` +\n            `  <${comp}>\\n` +\n            `    <component :is=\"Component\" />\\n` +\n            `  </${comp}>\\n` +\n            `</router-view>`);\n    }\n}\n\nfunction formatRouteLocation(routeLocation, tooltip) {\n    const copy = assign({}, routeLocation, {\n        // remove variables that can contain vue instances\n        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),\n    });\n    return {\n        _custom: {\n            type: null,\n            readOnly: true,\n            display: routeLocation.fullPath,\n            tooltip,\n            value: copy,\n        },\n    };\n}\nfunction formatDisplay(display) {\n    return {\n        _custom: {\n            display,\n        },\n    };\n}\n// to support multiple router instances\nlet routerId = 0;\nfunction addDevtools(app, router, matcher) {\n    // Take over router.beforeEach and afterEach\n    // make sure we are not registering the devtool twice\n    if (router.__hasDevtools)\n        return;\n    router.__hasDevtools = true;\n    // increment to support multiple router instances\n    const id = routerId++;\n    setupDevtoolsPlugin({\n        id: 'org.vuejs.router' + (id ? '.' + id : ''),\n        label: 'Vue Router',\n        packageName: 'vue-router',\n        homepage: 'https://router.vuejs.org',\n        logo: 'https://router.vuejs.org/logo.png',\n        componentStateTypes: ['Routing'],\n        app,\n    }, api => {\n        // display state added by the router\n        api.on.inspectComponent((payload, ctx) => {\n            if (payload.instanceData) {\n                payload.instanceData.state.push({\n                    type: 'Routing',\n                    key: '$route',\n                    editable: false,\n                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),\n                });\n            }\n        });\n        // mark router-link as active and display tags on router views\n        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {\n            if (componentInstance.__vrv_devtools) {\n                const info = componentInstance.__vrv_devtools;\n                node.tags.push({\n                    label: (info.name ? `${info.name.toString()}: ` : '') + info.path,\n                    textColor: 0,\n                    tooltip: 'This component is rendered by &lt;router-view&gt;',\n                    backgroundColor: PINK_500,\n                });\n            }\n            // if multiple useLink are used\n            if (Array.isArray(componentInstance.__vrl_devtools)) {\n                componentInstance.__devtoolsApi = api;\n                componentInstance.__vrl_devtools.forEach(devtoolsData => {\n                    let backgroundColor = ORANGE_400;\n                    let tooltip = '';\n                    if (devtoolsData.isExactActive) {\n                        backgroundColor = LIME_500;\n                        tooltip = 'This is exactly active';\n                    }\n                    else if (devtoolsData.isActive) {\n                        backgroundColor = BLUE_600;\n                        tooltip = 'This link is active';\n                    }\n                    node.tags.push({\n                        label: devtoolsData.route.path,\n                        textColor: 0,\n                        tooltip,\n                        backgroundColor,\n                    });\n                });\n            }\n        });\n        watch(router.currentRoute, () => {\n            // refresh active state\n            refreshRoutesView();\n            api.notifyComponentUpdate();\n            api.sendInspectorTree(routerInspectorId);\n            api.sendInspectorState(routerInspectorId);\n        });\n        const navigationsLayerId = 'router:navigations:' + id;\n        api.addTimelineLayer({\n            id: navigationsLayerId,\n            label: `Router${id ? ' ' + id : ''} Navigations`,\n            color: 0x40a8c4,\n        });\n        // const errorsLayerId = 'router:errors'\n        // api.addTimelineLayer({\n        //   id: errorsLayerId,\n        //   label: 'Router Errors',\n        //   color: 0xea5455,\n        // })\n        router.onError((error, to) => {\n            api.addTimelineEvent({\n                layerId: navigationsLayerId,\n                event: {\n                    title: 'Error during Navigation',\n                    subtitle: to.fullPath,\n                    logType: 'error',\n                    time: Date.now(),\n                    data: { error },\n                    groupId: to.meta.__navigationId,\n                },\n            });\n        });\n        // attached to `meta` and used to group events\n        let navigationId = 0;\n        router.beforeEach((to, from) => {\n            const data = {\n                guard: formatDisplay('beforeEach'),\n                from: formatRouteLocation(from, 'Current Location during this navigation'),\n                to: formatRouteLocation(to, 'Target location'),\n            };\n            // Used to group navigations together, hide from devtools\n            Object.defineProperty(to.meta, '__navigationId', {\n                value: navigationId++,\n            });\n            api.addTimelineEvent({\n                layerId: navigationsLayerId,\n                event: {\n                    time: Date.now(),\n                    title: 'Start of navigation',\n                    subtitle: to.fullPath,\n                    data,\n                    groupId: to.meta.__navigationId,\n                },\n            });\n        });\n        router.afterEach((to, from, failure) => {\n            const data = {\n                guard: formatDisplay('afterEach'),\n            };\n            if (failure) {\n                data.failure = {\n                    _custom: {\n                        type: Error,\n                        readOnly: true,\n                        display: failure ? failure.message : '',\n                        tooltip: 'Navigation Failure',\n                        value: failure,\n                    },\n                };\n                data.status = formatDisplay('❌');\n            }\n            else {\n                data.status = formatDisplay('✅');\n            }\n            // we set here to have the right order\n            data.from = formatRouteLocation(from, 'Current Location during this navigation');\n            data.to = formatRouteLocation(to, 'Target location');\n            api.addTimelineEvent({\n                layerId: navigationsLayerId,\n                event: {\n                    title: 'End of navigation',\n                    subtitle: to.fullPath,\n                    time: Date.now(),\n                    data,\n                    logType: failure ? 'warning' : 'default',\n                    groupId: to.meta.__navigationId,\n                },\n            });\n        });\n        /**\n         * Inspector of Existing routes\n         */\n        const routerInspectorId = 'router-inspector:' + id;\n        api.addInspector({\n            id: routerInspectorId,\n            label: 'Routes' + (id ? ' ' + id : ''),\n            icon: 'book',\n            treeFilterPlaceholder: 'Search routes',\n        });\n        function refreshRoutesView() {\n            // the routes view isn't active\n            if (!activeRoutesPayload)\n                return;\n            const payload = activeRoutesPayload;\n            // children routes will appear as nested\n            let routes = matcher.getRoutes().filter(route => !route.parent);\n            // reset match state to false\n            routes.forEach(resetMatchStateOnRouteRecord);\n            // apply a match state if there is a payload\n            if (payload.filter) {\n                routes = routes.filter(route => \n                // save matches state based on the payload\n                isRouteMatching(route, payload.filter.toLowerCase()));\n            }\n            // mark active routes\n            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\n            payload.rootNodes = routes.map(formatRouteRecordForInspector);\n        }\n        let activeRoutesPayload;\n        api.on.getInspectorTree(payload => {\n            activeRoutesPayload = payload;\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\n                refreshRoutesView();\n            }\n        });\n        /**\n         * Display information about the currently selected route record\n         */\n        api.on.getInspectorState(payload => {\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\n                const routes = matcher.getRoutes();\n                const route = routes.find(route => route.record.__vd_id === payload.nodeId);\n                if (route) {\n                    payload.state = {\n                        options: formatRouteRecordMatcherForStateInspector(route),\n                    };\n                }\n            }\n        });\n        api.sendInspectorTree(routerInspectorId);\n        api.sendInspectorState(routerInspectorId);\n    });\n}\nfunction modifierForKey(key) {\n    if (key.optional) {\n        return key.repeatable ? '*' : '?';\n    }\n    else {\n        return key.repeatable ? '+' : '';\n    }\n}\nfunction formatRouteRecordMatcherForStateInspector(route) {\n    const { record } = route;\n    const fields = [\n        { editable: false, key: 'path', value: record.path },\n    ];\n    if (record.name != null) {\n        fields.push({\n            editable: false,\n            key: 'name',\n            value: record.name,\n        });\n    }\n    fields.push({ editable: false, key: 'regexp', value: route.re });\n    if (route.keys.length) {\n        fields.push({\n            editable: false,\n            key: 'keys',\n            value: {\n                _custom: {\n                    type: null,\n                    readOnly: true,\n                    display: route.keys\n                        .map(key => `${key.name}${modifierForKey(key)}`)\n                        .join(' '),\n                    tooltip: 'Param keys',\n                    value: route.keys,\n                },\n            },\n        });\n    }\n    if (record.redirect != null) {\n        fields.push({\n            editable: false,\n            key: 'redirect',\n            value: record.redirect,\n        });\n    }\n    if (route.alias.length) {\n        fields.push({\n            editable: false,\n            key: 'aliases',\n            value: route.alias.map(alias => alias.record.path),\n        });\n    }\n    fields.push({\n        key: 'score',\n        editable: false,\n        value: {\n            _custom: {\n                type: null,\n                readOnly: true,\n                display: route.score.map(score => score.join(', ')).join(' | '),\n                tooltip: 'Score used to sort routes',\n                value: route.score,\n            },\n        },\n    });\n    return fields;\n}\n/**\n * Extracted from tailwind palette\n */\nconst PINK_500 = 0xec4899;\nconst BLUE_600 = 0x2563eb;\nconst LIME_500 = 0x84cc16;\nconst CYAN_400 = 0x22d3ee;\nconst ORANGE_400 = 0xfb923c;\n// const GRAY_100 = 0xf4f4f5\nconst DARK = 0x666666;\nfunction formatRouteRecordForInspector(route) {\n    const tags = [];\n    const { record } = route;\n    if (record.name != null) {\n        tags.push({\n            label: String(record.name),\n            textColor: 0,\n            backgroundColor: CYAN_400,\n        });\n    }\n    if (record.aliasOf) {\n        tags.push({\n            label: 'alias',\n            textColor: 0,\n            backgroundColor: ORANGE_400,\n        });\n    }\n    if (route.__vd_match) {\n        tags.push({\n            label: 'matches',\n            textColor: 0,\n            backgroundColor: PINK_500,\n        });\n    }\n    if (route.__vd_exactActive) {\n        tags.push({\n            label: 'exact',\n            textColor: 0,\n            backgroundColor: LIME_500,\n        });\n    }\n    if (route.__vd_active) {\n        tags.push({\n            label: 'active',\n            textColor: 0,\n            backgroundColor: BLUE_600,\n        });\n    }\n    if (record.redirect) {\n        tags.push({\n            label: 'redirect: ' +\n                (typeof record.redirect === 'string' ? record.redirect : 'Object'),\n            textColor: 0xffffff,\n            backgroundColor: DARK,\n        });\n    }\n    // add an id to be able to select it. Using the `path` is not possible because\n    // empty path children would collide with their parents\n    let id = record.__vd_id;\n    if (id == null) {\n        id = String(routeRecordId++);\n        record.__vd_id = id;\n    }\n    return {\n        id,\n        label: record.path,\n        tags,\n        children: route.children.map(formatRouteRecordForInspector),\n    };\n}\n//  incremental id for route records and inspector state\nlet routeRecordId = 0;\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\nfunction markRouteRecordActive(route, currentRoute) {\n    // no route will be active if matched is empty\n    // reset the matching state\n    const isExactActive = currentRoute.matched.length &&\n        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\n    route.__vd_exactActive = route.__vd_active = isExactActive;\n    if (!isExactActive) {\n        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\n    }\n    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\n}\nfunction resetMatchStateOnRouteRecord(route) {\n    route.__vd_match = false;\n    route.children.forEach(resetMatchStateOnRouteRecord);\n}\nfunction isRouteMatching(route, filter) {\n    const found = String(route.re).match(EXTRACT_REGEXP_RE);\n    route.__vd_match = false;\n    if (!found || found.length < 3) {\n        return false;\n    }\n    // use a regexp without $ at the end to match nested routes better\n    const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\n    if (nonEndingRE.test(filter)) {\n        // mark children as matches\n        route.children.forEach(child => isRouteMatching(child, filter));\n        // exception case: `/`\n        if (route.record.path !== '/' || filter === '/') {\n            route.__vd_match = route.re.test(filter);\n            return true;\n        }\n        // hide the / route\n        return false;\n    }\n    const path = route.record.path.toLowerCase();\n    const decodedPath = decode(path);\n    // also allow partial matching on the path\n    if (!filter.startsWith('/') &&\n        (decodedPath.includes(filter) || path.includes(filter)))\n        return true;\n    if (decodedPath.startsWith(filter) || path.startsWith(filter))\n        return true;\n    if (route.record.name && String(route.record.name).includes(filter))\n        return true;\n    return route.children.some(child => isRouteMatching(child, filter));\n}\nfunction omit(obj, keys) {\n    const ret = {};\n    for (const key in obj) {\n        if (!keys.includes(key)) {\n            // @ts-expect-error\n            ret[key] = obj[key];\n        }\n    }\n    return ret;\n}\n\n/**\n * Creates a Router instance that can be used by a Vue app.\n *\n * @param options - {@link RouterOptions}\n */\nfunction createRouter(options) {\n    const matcher = createRouterMatcher(options.routes, options);\n    const parseQuery$1 = options.parseQuery || parseQuery;\n    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\n    const routerHistory = options.history;\n    if ((process.env.NODE_ENV !== 'production') && !routerHistory)\n        throw new Error('Provide the \"history\" option when calling \"createRouter()\":' +\n            ' https://next.router.vuejs.org/api/#history.');\n    const beforeGuards = useCallbacks();\n    const beforeResolveGuards = useCallbacks();\n    const afterGuards = useCallbacks();\n    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\n    let pendingLocation = START_LOCATION_NORMALIZED;\n    // leave the scrollRestoration if no scrollBehavior is provided\n    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\n        history.scrollRestoration = 'manual';\n    }\n    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\n    const encodeParams = applyToParams.bind(null, encodeParam);\n    const decodeParams = \n    // @ts-expect-error: intentionally avoid the type check\n    applyToParams.bind(null, decode);\n    function addRoute(parentOrRoute, route) {\n        let parent;\n        let record;\n        if (isRouteName(parentOrRoute)) {\n            parent = matcher.getRecordMatcher(parentOrRoute);\n            record = route;\n        }\n        else {\n            record = parentOrRoute;\n        }\n        return matcher.addRoute(record, parent);\n    }\n    function removeRoute(name) {\n        const recordMatcher = matcher.getRecordMatcher(name);\n        if (recordMatcher) {\n            matcher.removeRoute(recordMatcher);\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Cannot remove non-existent route \"${String(name)}\"`);\n        }\n    }\n    function getRoutes() {\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\n    }\n    function hasRoute(name) {\n        return !!matcher.getRecordMatcher(name);\n    }\n    function resolve(rawLocation, currentLocation) {\n        // const objectLocation = routerLocationAsObject(rawLocation)\n        // we create a copy to modify it later\n        currentLocation = assign({}, currentLocation || currentRoute.value);\n        if (typeof rawLocation === 'string') {\n            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\n            const matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\n            const href = routerHistory.createHref(locationNormalized.fullPath);\n            if ((process.env.NODE_ENV !== 'production')) {\n                if (href.startsWith('//'))\n                    warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n                else if (!matchedRoute.matched.length) {\n                    warn(`No match found for location with path \"${rawLocation}\"`);\n                }\n            }\n            // locationNormalized is always a new object\n            return assign(locationNormalized, matchedRoute, {\n                params: decodeParams(matchedRoute.params),\n                hash: decode(locationNormalized.hash),\n                redirectedFrom: undefined,\n                href,\n            });\n        }\n        let matcherLocation;\n        // path could be relative in object as well\n        if ('path' in rawLocation) {\n            if ((process.env.NODE_ENV !== 'production') &&\n                'params' in rawLocation &&\n                !('name' in rawLocation) &&\n                // @ts-expect-error: the type is never\n                Object.keys(rawLocation.params).length) {\n                warn(`Path \"${\n                // @ts-expect-error: the type is never\n                rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\n            }\n            matcherLocation = assign({}, rawLocation, {\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\n            });\n        }\n        else {\n            // remove any nullish param\n            const targetParams = assign({}, rawLocation.params);\n            for (const key in targetParams) {\n                if (targetParams[key] == null) {\n                    delete targetParams[key];\n                }\n            }\n            // pass encoded values to the matcher so it can produce encoded path and fullPath\n            matcherLocation = assign({}, rawLocation, {\n                params: encodeParams(rawLocation.params),\n            });\n            // current location params are decoded, we need to encode them in case the\n            // matcher merges the params\n            currentLocation.params = encodeParams(currentLocation.params);\n        }\n        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\n        const hash = rawLocation.hash || '';\n        if ((process.env.NODE_ENV !== 'production') && hash && !hash.startsWith('#')) {\n            warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\n        }\n        // decoding them) the matcher might have merged current location params so\n        // we need to run the decoding again\n        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\n        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\n            hash: encodeHash(hash),\n            path: matchedRoute.path,\n        }));\n        const href = routerHistory.createHref(fullPath);\n        if ((process.env.NODE_ENV !== 'production')) {\n            if (href.startsWith('//')) {\n                warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\n            }\n            else if (!matchedRoute.matched.length) {\n                warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\n            }\n        }\n        return assign({\n            fullPath,\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\n            // hash\n            hash,\n            query: \n            // if the user is using a custom query lib like qs, we might have\n            // nested objects, so we keep the query as is, meaning it can contain\n            // numbers at `$route.query`, but at the point, the user will have to\n            // use their own type anyway.\n            // https://github.com/vuejs/router/issues/328#issuecomment-649481567\n            stringifyQuery$1 === stringifyQuery\n                ? normalizeQuery(rawLocation.query)\n                : (rawLocation.query || {}),\n        }, matchedRoute, {\n            redirectedFrom: undefined,\n            href,\n        });\n    }\n    function locationAsObject(to) {\n        return typeof to === 'string'\n            ? parseURL(parseQuery$1, to, currentRoute.value.path)\n            : assign({}, to);\n    }\n    function checkCanceledNavigation(to, from) {\n        if (pendingLocation !== to) {\n            return createRouterError(8 /* NAVIGATION_CANCELLED */, {\n                from,\n                to,\n            });\n        }\n    }\n    function push(to) {\n        return pushWithRedirect(to);\n    }\n    function replace(to) {\n        return push(assign(locationAsObject(to), { replace: true }));\n    }\n    function handleRedirectRecord(to) {\n        const lastMatched = to.matched[to.matched.length - 1];\n        if (lastMatched && lastMatched.redirect) {\n            const { redirect } = lastMatched;\n            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\n            if (typeof newTargetLocation === 'string') {\n                newTargetLocation =\n                    newTargetLocation.includes('?') || newTargetLocation.includes('#')\n                        ? (newTargetLocation = locationAsObject(newTargetLocation))\n                        : // force empty params\n                            { path: newTargetLocation };\n                // @ts-expect-error: force empty params when a string is passed to let\n                // the router parse them again\n                newTargetLocation.params = {};\n            }\n            if ((process.env.NODE_ENV !== 'production') &&\n                !('path' in newTargetLocation) &&\n                !('name' in newTargetLocation)) {\n                warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\n                throw new Error('Invalid redirect');\n            }\n            return assign({\n                query: to.query,\n                hash: to.hash,\n                params: to.params,\n            }, newTargetLocation);\n        }\n    }\n    function pushWithRedirect(to, redirectedFrom) {\n        const targetLocation = (pendingLocation = resolve(to));\n        const from = currentRoute.value;\n        const data = to.state;\n        const force = to.force;\n        // to could be a string where `replace` is a function\n        const replace = to.replace === true;\n        const shouldRedirect = handleRedirectRecord(targetLocation);\n        if (shouldRedirect)\n            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\n                state: data,\n                force,\n                replace,\n            }), \n            // keep original redirectedFrom if it exists\n            redirectedFrom || targetLocation);\n        // if it was a redirect we already called `pushWithRedirect` above\n        const toLocation = targetLocation;\n        toLocation.redirectedFrom = redirectedFrom;\n        let failure;\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\n            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });\n            // trigger scroll to allow scrolling to the same anchor\n            handleScroll(from, from, \n            // this is a push, the only way for it to be triggered from a\n            // history.listen is with a redirect, which makes it become a push\n            true, \n            // This cannot be the first navigation because the initial location\n            // cannot be manually navigated to\n            false);\n        }\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\n            .catch((error) => isNavigationFailure(error)\n            ? // navigation redirects still mark the router as ready\n                isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)\n                    ? error\n                    : markAsReady(error) // also returns the error\n            : // reject any unknown error\n                triggerError(error, toLocation, from))\n            .then((failure) => {\n            if (failure) {\n                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\n                    if ((process.env.NODE_ENV !== 'production') &&\n                        // we are redirecting to the same location we were already at\n                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&\n                        // and we have done it a couple of times\n                        redirectedFrom &&\n                        // @ts-expect-error: added only in dev\n                        (redirectedFrom._count = redirectedFrom._count\n                            ? // @ts-expect-error\n                                redirectedFrom._count + 1\n                            : 1) > 10) {\n                        warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\n                        return Promise.reject(new Error('Infinite redirect in navigation guard'));\n                    }\n                    return pushWithRedirect(\n                    // keep options\n                    assign(locationAsObject(failure.to), {\n                        state: data,\n                        force,\n                        replace,\n                    }), \n                    // preserve the original redirectedFrom if any\n                    redirectedFrom || toLocation);\n                }\n            }\n            else {\n                // if we fail we don't finalize the navigation\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\n            }\n            triggerAfterEach(toLocation, from, failure);\n            return failure;\n        });\n    }\n    /**\n     * Helper to reject and skip all navigation guards if a new navigation happened\n     * @param to\n     * @param from\n     */\n    function checkCanceledNavigationAndReject(to, from) {\n        const error = checkCanceledNavigation(to, from);\n        return error ? Promise.reject(error) : Promise.resolve();\n    }\n    // TODO: refactor the whole before guards by internally using router.beforeEach\n    function navigate(to, from) {\n        let guards;\n        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\n        // all components here have been resolved once because we are leaving\n        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\n        // leavingRecords is already reversed\n        for (const record of leavingRecords) {\n            record.leaveGuards.forEach(guard => {\n                guards.push(guardToPromiseFn(guard, to, from));\n            });\n        }\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\n        guards.push(canceledNavigationCheck);\n        // run the queue of per route beforeRouteLeave guards\n        return (runGuardQueue(guards)\n            .then(() => {\n            // check global guards beforeEach\n            guards = [];\n            for (const guard of beforeGuards.list()) {\n                guards.push(guardToPromiseFn(guard, to, from));\n            }\n            guards.push(canceledNavigationCheck);\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // check in components beforeRouteUpdate\n            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\n            for (const record of updatingRecords) {\n                record.updateGuards.forEach(guard => {\n                    guards.push(guardToPromiseFn(guard, to, from));\n                });\n            }\n            guards.push(canceledNavigationCheck);\n            // run the queue of per route beforeEnter guards\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // check the route beforeEnter\n            guards = [];\n            for (const record of to.matched) {\n                // do not trigger beforeEnter on reused views\n                if (record.beforeEnter && !from.matched.includes(record)) {\n                    if (Array.isArray(record.beforeEnter)) {\n                        for (const beforeEnter of record.beforeEnter)\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\n                    }\n                    else {\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\n                    }\n                }\n            }\n            guards.push(canceledNavigationCheck);\n            // run the queue of per route beforeEnter guards\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\n            to.matched.forEach(record => (record.enterCallbacks = {}));\n            // check in-component beforeRouteEnter\n            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\n            guards.push(canceledNavigationCheck);\n            // run the queue of per route beforeEnter guards\n            return runGuardQueue(guards);\n        })\n            .then(() => {\n            // check global guards beforeResolve\n            guards = [];\n            for (const guard of beforeResolveGuards.list()) {\n                guards.push(guardToPromiseFn(guard, to, from));\n            }\n            guards.push(canceledNavigationCheck);\n            return runGuardQueue(guards);\n        })\n            // catch any navigation canceled\n            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)\n            ? err\n            : Promise.reject(err)));\n    }\n    function triggerAfterEach(to, from, failure) {\n        // navigation is confirmed, call afterGuards\n        // TODO: wrap with error handlers\n        for (const guard of afterGuards.list())\n            guard(to, from, failure);\n    }\n    /**\n     * - Cleans up any navigation guards\n     * - Changes the url if necessary\n     * - Calls the scrollBehavior\n     */\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\n        // a more recent navigation took place\n        const error = checkCanceledNavigation(toLocation, from);\n        if (error)\n            return error;\n        // only consider as push if it's not the first navigation\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\n        const state = !isBrowser ? {} : history.state;\n        // change URL only if the user did a push/replace and if it's not the initial navigation because\n        // it's just reflecting the url\n        if (isPush) {\n            // on the initial navigation, we want to reuse the scroll position from\n            // history state if it exists\n            if (replace || isFirstNavigation)\n                routerHistory.replace(toLocation.fullPath, assign({\n                    scroll: isFirstNavigation && state && state.scroll,\n                }, data));\n            else\n                routerHistory.push(toLocation.fullPath, data);\n        }\n        // accept current navigation\n        currentRoute.value = toLocation;\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\n        markAsReady();\n    }\n    let removeHistoryListener;\n    // attach listener to history to trigger navigations\n    function setupListeners() {\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\n            // cannot be a redirect route because it was in history\n            const toLocation = resolve(to);\n            // due to dynamic routing, and to hash history with manual navigation\n            // (manually changing the url or calling history.hash = '#/somewhere'),\n            // there could be a redirect record in history\n            const shouldRedirect = handleRedirectRecord(toLocation);\n            if (shouldRedirect) {\n                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);\n                return;\n            }\n            pendingLocation = toLocation;\n            const from = currentRoute.value;\n            // TODO: should be moved to web history?\n            if (isBrowser) {\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\n            }\n            navigate(toLocation, from)\n                .catch((error) => {\n                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\n                    return error;\n                }\n                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\n                    // Here we could call if (info.delta) routerHistory.go(-info.delta,\n                    // false) but this is bug prone as we have no way to wait the\n                    // navigation to be finished before calling pushWithRedirect. Using\n                    // a setTimeout of 16ms seems to work but there is not guarantee for\n                    // it to work on every browser. So Instead we do not restore the\n                    // history entry and trigger a new navigation as requested by the\n                    // navigation guard.\n                    // the error is already handled by router.push we just want to avoid\n                    // logging the error\n                    pushWithRedirect(error.to, toLocation\n                    // avoid an uncaught rejection, let push call triggerError\n                    )\n                        .then(failure => {\n                        // manual change in hash history #916 ending up in the URL not\n                        // changing but it was changed by the manual url change, so we\n                        // need to manually change it ourselves\n                        if (isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ |\n                            16 /* NAVIGATION_DUPLICATED */) &&\n                            !info.delta &&\n                            info.type === NavigationType.pop) {\n                            routerHistory.go(-1, false);\n                        }\n                    })\n                        .catch(noop);\n                    // avoid the then branch\n                    return Promise.reject();\n                }\n                // do not restore history on unknown direction\n                if (info.delta)\n                    routerHistory.go(-info.delta, false);\n                // unrecognized error, transfer to the global handler\n                return triggerError(error, toLocation, from);\n            })\n                .then((failure) => {\n                failure =\n                    failure ||\n                        finalizeNavigation(\n                        // after navigation, all matched components are resolved\n                        toLocation, from, false);\n                // revert the navigation\n                if (failure) {\n                    if (info.delta) {\n                        routerHistory.go(-info.delta, false);\n                    }\n                    else if (info.type === NavigationType.pop &&\n                        isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ | 16 /* NAVIGATION_DUPLICATED */)) {\n                        // manual change in hash history #916\n                        // it's like a push but lacks the information of the direction\n                        routerHistory.go(-1, false);\n                    }\n                }\n                triggerAfterEach(toLocation, from, failure);\n            })\n                .catch(noop);\n        });\n    }\n    // Initialization and Errors\n    let readyHandlers = useCallbacks();\n    let errorHandlers = useCallbacks();\n    let ready;\n    /**\n     * Trigger errorHandlers added via onError and throws the error as well\n     *\n     * @param error - error to throw\n     * @param to - location we were navigating to when the error happened\n     * @param from - location we were navigating from when the error happened\n     * @returns the error as a rejected promise\n     */\n    function triggerError(error, to, from) {\n        markAsReady(error);\n        const list = errorHandlers.list();\n        if (list.length) {\n            list.forEach(handler => handler(error, to, from));\n        }\n        else {\n            if ((process.env.NODE_ENV !== 'production')) {\n                warn('uncaught error during route navigation:');\n            }\n            console.error(error);\n        }\n        return Promise.reject(error);\n    }\n    function isReady() {\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\n            return Promise.resolve();\n        return new Promise((resolve, reject) => {\n            readyHandlers.add([resolve, reject]);\n        });\n    }\n    function markAsReady(err) {\n        if (!ready) {\n            // still not ready if an error happened\n            ready = !err;\n            setupListeners();\n            readyHandlers\n                .list()\n                .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\n            readyHandlers.reset();\n        }\n        return err;\n    }\n    // Scroll behavior\n    function handleScroll(to, from, isPush, isFirstNavigation) {\n        const { scrollBehavior } = options;\n        if (!isBrowser || !scrollBehavior)\n            return Promise.resolve();\n        const scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\n            ((isFirstNavigation || !isPush) &&\n                history.state &&\n                history.state.scroll) ||\n            null;\n        return nextTick()\n            .then(() => scrollBehavior(to, from, scrollPosition))\n            .then(position => position && scrollToPosition(position))\n            .catch(err => triggerError(err, to, from));\n    }\n    const go = (delta) => routerHistory.go(delta);\n    let started;\n    const installedApps = new Set();\n    const router = {\n        currentRoute,\n        addRoute,\n        removeRoute,\n        hasRoute,\n        getRoutes,\n        resolve,\n        options,\n        push,\n        replace,\n        go,\n        back: () => go(-1),\n        forward: () => go(1),\n        beforeEach: beforeGuards.add,\n        beforeResolve: beforeResolveGuards.add,\n        afterEach: afterGuards.add,\n        onError: errorHandlers.add,\n        isReady,\n        install(app) {\n            const router = this;\n            app.component('RouterLink', RouterLink);\n            app.component('RouterView', RouterView);\n            app.config.globalProperties.$router = router;\n            Object.defineProperty(app.config.globalProperties, '$route', {\n                enumerable: true,\n                get: () => unref(currentRoute),\n            });\n            // this initial navigation is only necessary on client, on server it doesn't\n            // make sense because it will create an extra unnecessary navigation and could\n            // lead to problems\n            if (isBrowser &&\n                // used for the initial navigation client side to avoid pushing\n                // multiple times when the router is used in multiple apps\n                !started &&\n                currentRoute.value === START_LOCATION_NORMALIZED) {\n                // see above\n                started = true;\n                push(routerHistory.location).catch(err => {\n                    if ((process.env.NODE_ENV !== 'production'))\n                        warn('Unexpected error when starting the router:', err);\n                });\n            }\n            const reactiveRoute = {};\n            for (const key in START_LOCATION_NORMALIZED) {\n                // @ts-expect-error: the key matches\n                reactiveRoute[key] = computed(() => currentRoute.value[key]);\n            }\n            app.provide(routerKey, router);\n            app.provide(routeLocationKey, reactive(reactiveRoute));\n            app.provide(routerViewLocationKey, currentRoute);\n            const unmountApp = app.unmount;\n            installedApps.add(app);\n            app.unmount = function () {\n                installedApps.delete(app);\n                // the router is not attached to an app anymore\n                if (installedApps.size < 1) {\n                    // invalidate the current navigation\n                    pendingLocation = START_LOCATION_NORMALIZED;\n                    removeHistoryListener && removeHistoryListener();\n                    currentRoute.value = START_LOCATION_NORMALIZED;\n                    started = false;\n                    ready = false;\n                }\n                unmountApp();\n            };\n            if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && isBrowser) {\n                addDevtools(app, router, matcher);\n            }\n        },\n    };\n    return router;\n}\nfunction runGuardQueue(guards) {\n    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\n}\nfunction extractChangingRecords(to, from) {\n    const leavingRecords = [];\n    const updatingRecords = [];\n    const enteringRecords = [];\n    const len = Math.max(from.matched.length, to.matched.length);\n    for (let i = 0; i < len; i++) {\n        const recordFrom = from.matched[i];\n        if (recordFrom) {\n            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))\n                updatingRecords.push(recordFrom);\n            else\n                leavingRecords.push(recordFrom);\n        }\n        const recordTo = to.matched[i];\n        if (recordTo) {\n            // the type doesn't matter because we are comparing per reference\n            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\n                enteringRecords.push(recordTo);\n            }\n        }\n    }\n    return [leavingRecords, updatingRecords, enteringRecords];\n}\n\n/**\n * Returns the router instance. Equivalent to using `$router` inside\n * templates.\n */\nfunction useRouter() {\n    return inject(routerKey);\n}\n/**\n * Returns the current route location. Equivalent to using `$route` inside\n * templates.\n */\nfunction useRoute() {\n    return inject(routeLocationKey);\n}\n\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}